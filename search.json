[{"title":"广州马拉松","path":"/memoirs/20241212/running/guangzhou/","content":"马拉松中签今年挺幸运的，第二轮的补录，中签了广州马拉松。作为全国的大满贯赛事，我还是很希望广州马拉松能够中签的，毕竟武汉马拉松连续4年没有中。 时间过得挺快的，不知不觉上一篇已经是3年前了。 今年跑步一点都不积极，月跑量可能只有20KM左右。 本来中签了孝感马拉松，但是那天我身体状态不好直接放弃了。 然后在广州马拉松开赛前的三周，我每周的跑量都是40左右，这个已经是我能够做到的极限了。 跑步是一个时间成本很高的运动，需要大量的时间。 起点 顺利完赛作为我的第一次马拉松（全马），我很认真准备了三周，最后一周的周日跑了一个21公里。 三周的训练时间，每个周末都会拉一个长距离，15KM - 18KM - 21KM，逐渐加长。 所以我对35KM是有信心完成的，后面的就不知道了，跑之前的计划是，35公里之后走一半跑一半，5小时内完赛就是胜利✌🏻 比赛当日的广州天气很好，温度很合适，而且有风，风也不大。 但是最后的8公里确实让人绝望，35KM之后的每一公里都是痛苦面具。 不过最后的成绩跟我预料的相差不大。 成绩 完赛前的视频 Your browser does not support the video tag. 夜游广州多年后来到广州，重新去了珠江边，上了珠江边的那个发着光的大桥。 当然首先是吃了一个晚饭，或者说中饭。因为我拿到赛事大礼包的时候已经3点多了，将近4点。 米粒和夕夕 大桥可以联通到珠江中间的二沙岛，二沙岛旁边就是马拉松的终点 - 海心沙 远远看去，那座桥像鹊桥一样，勾勒出一个很好看的弧形一直延伸到珠江中间的岛上。 因为桥的轮廓是发着光的，很有未来科技的感觉，反而是珠江中间的海心沙，融入黑暗中，让人感觉这座发光的鹊桥横跨了黑暗，一路延伸。 米粒米粒 长隆野生动物园第二天约好了一起去长隆野生动物园，不过因为要补课要12点才能下课，我们只能中午吃完饭之后出发，到达长隆的时候已经是2点多了。 我好像从没去过长隆，以前在广州的时候没有机会体验这些。 长隆有一点类似迪士尼的样子，不过长隆把几个乐园分开了，欢乐世界、水上乐园、野生动物园。同样的，门票也分开了，相比于迪士尼的599，还是相对便宜的，也只是相对便宜而已！ 长隆野生动物园还是非常适合小孩子的，坐着小火车穿越丛林、草原，非洲的、美洲的，还有亚洲的动物都可以看见。 那些狮子老虎居然躺在山上看着我们，我们可以在小火车上跟狮子遥相对望。不过狮子们好像对我们没有兴趣，它们是我们的风景，我们也是他们的风景。 每每去动物园看这些，我都会想起一个电影《楚门的世界》。这个世界好像一个巨大的楚门的世界，每个人都在表演，表演活着，表演高兴、悲伤、痛苦，以及生离死别。 非洲大草原 做完火车之后就可以自由选择路线了，有的孩子愿意去青龙山看蛇和恐龙，由于之前有一个小朋友被恐龙吓哭了，我们就不去看恐龙了。 另外一条路线可以看花车游行，还可以看见大熊猫，看完大熊猫可以坐缆车回去。 花车游行的时候我抱着小米粒，所以没办法拍视频，只有米粒和八戒的合照🙂🙂🙂 米粒和八戒 后面游行完之后还有看大熊猫，三胞胎的大兄弟，全国也只有这一对。 但是这个时候我已经是困得不行了，加上看熊猫的人太热情了，人巨多，最后我累倒在一个小游乐场的餐桌前。 我只记得我趴着睡着了，睡醒的时候已经天黑了。小朋友们还很有激情，看着转转的飞天座椅，兴冲冲的排队。 结果在关门前的最后一轮，被挡在了前面，没有成功上去。 小朋友吃完了零食和冰淇淋，只能很失望的下山了。 返程返程日的天气真好，阳光明媚的。 完赛之后大概是12点半，阳台晒在身上懒洋洋的，像一个调皮的孩子在你的皮肤上打滚，或者开心的在上面跳舞。 从海心沙走到地铁站真的好远啊，我跑完了42公里，还要走半个小时才能到地铁站。 从广州塔出来，阳光更舒服了，基本上可以穿着短袖短裤享受阳光。 米粒和广州塔 在广州塔玩耍了几个小时，到了吃饭的点，吃完饭就该去赶火车了。 这个时候身体已经冷下来了，右腿一脚不能弯曲了，一弯曲就疼的不行，基本上只能一瘸一拐的走路。 综合我的训练量，这个结果是必然的，最后的8公里已经超出了我的能力极限。 广马是什么？ 是无数颗心不舍昼夜 是无数颗心不舍昼夜 共同书写的一场 关于热爱和信念的伟大篇章 是讲述不完的一个个故事 是分享不完的一串串感动 ----是 “我们的力量”","tags":["随便写写"],"categories":["跑步的故事"]},{"title":"乡土中国","path":"/memoirs/20210915/乡土中国/","content":"《乡土中国》是社会学的经典书，可以说是经典中的经典，也是所有研究中国的人必读的一本书。 这本书讲的是中国人的社会操作系统，是研究中国人复杂思维非常重要的一块基石， 一、乡土本色 中国基层社会是“乡土性的”。“乡土性”对应着自古以来人们对土地的依附和“不流动”。 从历史的角度：“我们的民族确是和泥土分不开的了。 从土里长出过光荣的历史，自然也会受到土的束缚…” 从地理的角度：“农业和游牧或工业不同，它是直接取资于土地的。游牧的人可以逐水草而居，飘忽无定；做工业的人可以择地而居，迁移无碍；而种地的人却搬不动地，长在土里的庄稼行动不得，侍候庄稼的老农也因之像是半身插入了土里，土气是因为不流动而发生的。” “不流动”是指中国农村以村落为单位彼此孤立隔绝。 “不流动是从人和空间的关系上说的，从人和人在空间的排列关系上说就是孤立和隔膜。孤立和隔膜并不是以个人为单位的，而是以住在一处的集团为单位的。” 中国农村聚村而居大致由于4个原因：小农经营下屋舍与农田较近、共用水力设施的需要、安全的需要、土地不断继承积累。 在缺乏流动性的乡土社会，每个人从出生便被嵌入了熟人社会的网络。 “乡土社会在地方性的限制下成了生于斯、死于斯的社会。常态的生活是终老是乡。…这是一个“熟悉”的社会，没有陌生人的社会。” 传统熟人社会依靠习俗和人与人之间的了解维系，与现代社会所讲的规则和契约精神产生了冲突。 “在一个熟悉的社会中，我们会得到从心所欲而不逾规矩的自由。这和法律所保障的自由不同。规矩不是法律，规矩是“习”出来的礼俗。从俗即是从心。换一句话说，社会和个人在这里通了家。” “乡土社会的信用并不是对契约的重视，而是发生于对一种行为的规矩熟悉到不假思索时的可靠性。” “这种办法在一个陌生人面前是无法应用的。在我们社会的急速变迁中，从乡土社会进入现代社会的过程中，我们在乡土社会中所养成的生活方式处处产生了流弊。陌生人所组成的现代社会是无法用乡土社会的习俗来应付的。” 二、文字下乡（空间尺度上文字在乡村的价值） 乡下人与城里人知识结构不尽相同，易产生乡下人“愚”的误解。 “乡下多文盲”与熟人社会下运用“特殊语言”比文字间接表意更有效有关。面对面能解决的事不必诉诸文字。 “特殊语言”不过是亲密社群中所使用的象征体系的一部分，用声音来作象征的那一部分。在亲密社群中可用来作象征体系的原料比较多。表情、动作，在面对面的情境中，有时比声音更容易传情达意。 “特殊语言”常是特别有效，因为它可以摆脱字句的固定意义。语言像是个社会定下的筛子，如果我们有一种情意和这筛子的格子不同也就漏不过去。 “在乡土社会中，不但文字是多余的，连语言都并不是传达情意的唯一象征体系。” 文字下乡需要结合现实情况。 “我决不是说我们不必推行文字下乡，在现代化的过程中，我们已经开始抛离乡土社会，文字是现代化的工具。我要辨明的是乡土社会中的文盲，并非出于乡下人的“愚”，而是由于乡土社会的本质。 而且我还愿意进一步说，单从文字和语言的角度中去批判一个社会中人和人的了解程度是不够的，因为文字和语言，只是传情达意的一种工具，并非唯一的工具；而且这工具本身也是有缺陷的，能传的情、能达的意是有限的。 所以提倡文字下乡的人，必须先考虑到文字和语言的基础。” 三、再论文字下乡（时间尺度上文字在乡村的价值） 人靠一套象征体系来存储记忆，因为人凭借记忆积累的过去的经验对现在的生活有益。而对集体而言，共同的记忆就是文化。 “文化是依赖象征体系和个人的记忆而维护着的社会共同经验。” 这套象征体系中最重要的就是“词”，但“词”不等于“文”，前者是文化存续的前提而后者不是。 “我们不断地在学习时说着话，把具体的情境抽象成一套能普遍应用的概念，概念必然是用词来表现的，于是我们靠着词，使我们从特殊走上普遍，在个别情境中搭下了桥梁；又使我们从当前走到今后，在片刻情境中搭下了桥梁。” “没有象征体系也就没有概念，人的经验也就不能或不易在时间里累积” “但是词却不一定要文。文是用眼睛可以看得到的符号，就是字。词不一定是刻出来或写出来的符号，也可以是用声音说出来的符号，语言。一切文化中不能没有“词”，可是不一定有“文字”。” 乡土社会的人日出而作日落而息生活定型，乡土社会的历史轨迹也是一条直线，语言足以传递代际经验，不需要文字了。而文字既不产生于基层也不属于基层乡土社会。所以只有在乡土性的基层发生了变化后，文字才能下乡。 “当一个人碰着生活上的问题时，他必然能在一个比他年长的人那里问得到解决这问题的有效办法，因为大家在同一环境里，走同一道路，他先走，你后走；后走的所踏的是先走的人的脚印，口口相传，不会有遗漏。哪里用得着文字？时间里没有阻隔，拉得十分紧，全部文化可以在亲子之间传授无缺。” 四、差序格局（划重点） 在中国，由“私”引起的社会问题很普遍，“私”与“差序格局”密切相关。 “一说是公家的，差不多就是说大家可以占一点便宜的意思，有权利而没有义务了。” “于是像格兰亨姆的公律，坏钱驱逐好钱一般，公德心就在这里被自私心驱走。”（外在激励与自我利益最大化） “所谓贪污无能，并不是每个人绝对的能力问题，而是相对的，是从个人对公家的服务和责任上说的。” 与西方社会界限分明的“团体格局”不同，中国的“差序格局”下，团体的界限并不清晰，无论是在亲属关系还是地缘关系中，团体以个人为中心，其覆盖范围是任意的，正如投石入水激起的涟漪。 “这个网络像个蜘蛛的网，有一个中心，就是自己。我们每个人都有这么一个以亲属关系布出去的网，但是没有一个网所罩住的人是相同的。在一个社会里的人可以用同一个体系来记认他们的亲属，所同的只是这体系罢了。体系是抽象的格局” “中国人也特别对世态炎凉有感触，正因为这富于伸缩的社会圈子会因中心势力的变化而大小。” 正是因为团体界限不清晰，我们乡土社会讲交情而不是权利。 “在孩子成年了住在家里都得给父母膳食费的西洋社会里，大家承认团体的界限。在团体里的有一定的资格。资格取消了就得走出这个团体。在他们不是人情冷热的问题，而是权利问题。在西洋社会里争的是权利，而在我们却是攀关系、讲交情。” 正是因为以“己”为中心，乡土社会利己的自我主义突出。 “在个人主义下，一方面是平等观念，指在同一团体中各分子的地位相等，个人不能侵犯大家的权利；一方面是宪法观念，指团体不能抹煞个人，只能在个人们所愿意交出的一分权利上控制个人。 这些观念必须先假定了团体的存在。在我们中国传统思想里是没有这一套的，因为我们所有的是自我主义，一切价值是以“己”作为中心的主义。” 与西方不同，乡土社会的“公”与“私”是相对的，不利于现代国家观念的形成。 “国是皇帝之家，界线从来就是不清不楚的，不过是从自己这个中心里推出去的社会势力里的一圈而已。 所以可以着手的，具体的只有己，克己也就成了社会生活中最重要的德行，他们不会去克群，使群不致侵略个人的权利。 在这种差序格局中，是不会发生这问题的。” 五、系维着私人的道德 社会结构或者说社会格局决定社会的道德观念。 “道德观念是在社会里生活的人自觉应当遵守社会行为规范的信念。它包括着行为规范、行为者的信念和社会的制裁。它的内容是人和人关系的行为规范，是依着该社会的格局而决定的。 从社会观点说，道德是社会对个人行为的制裁力，使他们合于规定下的形式行事，用以维持该社会的生存和绵续。” 西方“团体格局”在宗教的影响下形成，“神”象征着团体，人在神前平等，在团体（如国家）中平等享有权利履行义务，没有人可以凌驾于神或团体之上。 “宗教的虔诚和信赖不但是他们道德观念的来源，而且是支持行为规范的力量，是团体的象征。在象征着团体的神的观念下，有着两个重要的派生观念：一是每个个人在神前的平等；一是神对每个个人的公道。” “可是上帝是在冥冥之中，正象征团体无形的实在；但是在执行团体的意志时，还得有人来代理。“代理者”Minister是团体格局的社会中一个基本的概念。 执行上帝意志的牧师是Minister，执行团体权力的官吏也是Minister，都是“代理者”，而不是神或团体的本身” 中国没有平等爱人的宗教文化，只有以自我为中心的有等级差序的爱，难有统一的公共道德标准，道德依附在私人关系上。 “不但在我们传统道德系统中没有一个像基督教里那种“爱”的观念—不分差序的兼爱；而且我们也很不容易找到个人对于团体的道德要素。 在西洋团体格局的社会中，公务，履行义务，是一个清楚明白的行为规范。而这在中国传统中是没有的。” “而忠君并不是个人与团体的道德要素，而依旧是对君私之间的关系。 团体道德的缺乏，在公私的冲突里更看得清楚。” “传统的道德里不另找出一个笼统性的道德观念来，所有的价值标准也不能超脱于差序的人伦而存在了。 中国的道德和法律，都因之得看所施的对象和“自己”的关系而加以程度上的伸缩。” 六、家族 理清本书说述“差序格局”不是指中国没有诸如家庭和氏族等“团体”，而是指“从主要的格局说，在中国乡土社会中，差序格局和社会圈子的组织是比较的重要。” 家庭不仅有生育合作功能，还有组织经济等功能，可以按需要任意伸缩范围，扩大路线一般只按父系，其性质近似与氏族。 “家庭这概念在人类学上有明确的界说：这是个亲子所构成的生育社群。” “依人类学上的说法，氏族是一个事业组织，再扩大就可以成为一个部落” “我的假设是中国乡土社会采取了差序格局，利用亲属的伦常去组合社群，经营各种事业，使这基本的家，变成氏族性了。 家的结构不能限于亲子的小组合，必须加以扩大。而且凡是政治、经济、宗教等事物都需要长期绵续性的，这个基本社群决不能像西洋的家庭一般是临时的。 家必须是绵续的，不因个人的长成而分裂，不因个人的死亡而结束，于是家的性质变成了族。氏族本是长期的，和我们的家一般。 我称我们这种社群作小家族，也表示了这种长期性在内，和家庭的临时性相对照。” “中国的家是一个事业组织，家的大小是依着事业的大小而决定。” 家庭包含了太多生育之外的功能，导致“中国人在感情上，尤其是在两性间的矜持和保留。” 七、男女有别 中国传统感情定向是接受秩序的安排。 “在上篇我说家族在中国的乡土社会里是一个事业社群，凡是做事业的社群，纪律是必须维持的，纪律排斥了私情。” 乡土社会的社会关系生而定型，不需创造新的社会关系，它追求的是稳定，因此“男女间的关系必须有一种安排，使他们之间不发生激动性的感情。那就是男女有别的原则。” “社会秩序范围着个性，为了秩序的维持，一切足以引起破坏秩序的要素都被遏制着。男女之间的鸿沟从此筑下。乡土社会是个男女有别的社会，也是个安稳的社会。” 八、礼治秩序 “人治”与“法治”的区别不在于有没有法律可依据，而在于“维持秩序时所用的力量，和所根据的规范的性质。” 但无“法”并不会使乡土社会混乱不堪，因为有“礼治”的维系。 “礼是社会公认的行为规范，它本和法律无异，不同之处在于法律是靠国家的权力来推行的，而礼却不需要这样有形的权力机构来维持，维持礼这种规范的是传统。” “法”由外而内约束人，“礼”由内而外控制人。 “礼并不是靠一个外在的权力来推行的，而是从教化中养成了个人的敬畏感，使人服膺，人服礼是主动的” 九、无讼 传统生活是礼治社会，违背规矩是道德问题，需要的是教育和教化。而现代法治社会讲个人权利，权利不可侵犯，以刑法保护个人的权利和社会的安全。 “但是在乡土社会的礼治秩序中做人，如果不知道“礼”，就成了撒野，没有规矩，简直是个道德问题，不是个好人。一个负责地方秩序的父母官，维持礼治秩序的理想手段是教化，而不是折狱。” “一个法官并不考虑道德问题、伦理观念，他并不在教化人。刑罚的用意已经不复“以儆效尤”，而是在保护个人的权利和社会的安全。尤其在民法范围里，他并不是在分辨是非，而是在厘定权利。” 法治秩序的建立不能单靠制定若干法律条文和设立若干法庭，还得看人民怎么去应用这些设备。社会结构和思想理念还得先有一番改革。 十、无为政治 权力有两种用途，一是在阶级斗争中平衡冲突的工具，二是支配社会分工。即横暴权力和同意权力。 “冲突的性质并没有消弭，但是武力的阶段过去了，被支配的一方面已认了输，屈服了。但是他们并没有甘心接受胜利者所规定下的条件，非心服也。于是两方面的关系中发生了权力。 权力是维持这关系所必需的手段，它是压迫性质的，是上下之别” “这种权力的基础是社会契约，是同意。社会分工愈复杂，这权力也愈扩大。” 权力的诱人之处在于它可能带来经济利益，但农业社会被权力征服的团体生产力不高，吸引力不强，但易于被征服。 权力滋长靠内部农业生产力的提高，而和平有利于人口增长和农业社会力量的积聚，所以需要“养民”。 “皇权力求无为，所谓养民。养到一个时候，皇权逐渐累积了一些力量，这力量又刺激皇帝的雄图大略，这种循环也因而复始。 为了皇权自身的维持，在历史的经验中，找到了“无为”的生存价值，确立了无为政治的理想。” 十一、长老统治 中国社会基层存在一种长老式的权力 “既不是横暴性质，也不是同意性质；既不是发生于社会冲突，也不是发生于社会合作；它是发生于社会继替的过程，是教化性的权力，或是说爸爸式的，英文里是Paternalism。” 教化权力没有政治权力的强制性，但由于人人都认可，也形成了一种每个成员都被迫接受的规范。 “所谓社会契约必先假定个人的意志。个人对于这种契约虽则并没有自由解脱的权利，但是这种契约性的规律在形成的过程中，必须尊重各个人的自由意志，民主政治的形式就是综合个人意志和社会强制的结果。 在教化过程中并不发生这个问题，被教化者并没有选择的机会。” “凡是文化性的，不是政治性的强制都包含这种权力。 文化和政治的区别就在这里：凡是被社会不成问题地加以接受的规范，是文化性的；当一个社会还没有共同接受一套规范，各种意见纷呈，求取临时解决办法的活动是政治。 文化的基础必须是同意的，但文化对于社会的新分子是强制的，是一种教化过程。” 文化性规范不如成文的政治性规范稳定，因此在社会变迁中需要年长者的维系。 十二、血缘和地缘 长幼权力差别形成了血缘社会个人权利义务不同的基础，这种基础与生俱来不可选择。 “缺乏变动的文化里，长幼之间发生了社会的差次，年长的对年幼的具有强制和权力。这是血缘社会的基础。” “血缘的意思是人和人的权利和义务根据亲属关系来决定。” 血缘与地缘存在联系与冲突。 “血缘是稳定的力量。在稳定的社会中，地缘不过是血缘的投影，不分离的。” “籍贯只是“血缘的空间投影。” “地缘是从商业里发展出来的社会关系。血缘是身份社会的基础，而地缘却是契约社会的基础。” 现代社会讲求契约关系，是乡土社会所欠缺的，需要从血缘关系到地缘关系的转变。 “契约的完成是权利义务的清算，须要精密的计算、确当的单位、可靠的媒介。在这里是冷静的考虑，不是感情，于是理性支配着人们的活动—这一切是现代社会的特性，也正是乡土社会所缺的。 从血缘结合转变到地缘结合是社会性质的转变，也是社会史上的一个大转变。” 十三、名实的分离 社会变动分为“社会继替”和“社会变迁”，二者同时存在，但前者更明显，后者由于需求作用不显著。 “社会继替是指人物在固定的社会结构中的流动；社会变迁却是指社会结构本身的变动。这两种过程并不是冲突的，而是同时存在的。” 乡土社会并非绝对静止，在其缓慢的变化中，长老权力在社会继替中壮大在“社会继替”中产生长老权力，如果社会变动得慢，长老权力也就更有势力。 “社会结构的变动是人要它变的，要它变的原因是在它已不能答复人的需要。” “社会变迁可以吸收在社会继替之中的时候，我们可以称这社会是安定的。” 长老权力在乡土社会生命力极强。 “儒家所注重的“孝”道，其实是维持社会安定的手段，孝的解释是“无违”，那就是承认长老权力。 长老代表传统，遵守传统也就可以无违于父之教。” “长老权力是建立在教化作用之上的，教化是有知对无知，如果所传递的文化是有效的，被教的自没有反对的必要；如果所传递的文化已经失效，根本也就失去了教化的意义。“反对”在这种关系里是不发生的。” 长老依靠“加入注释”维系权力，而注释的变动可以引起名实之间发生极大的分离。 “长老权力下，传统的形式是不准反对的，但是只要表面上承认这形式，内容却可以经注释而改变。结果不免是口是心非。 在中国旧式家庭中生长的人都明白家长的意志怎样在表面的无违下，事实上被歪曲的。 虚伪在这种情境中不但是无可避免而且是必需的。” 十四、从欲望到需要 乡土社会靠欲望行事能自洽。 “在十九世纪发生了一种理论说，每个人只要能“自私”，那就是充分地满足我们本性里带来的欲望，社会就会形成一个最好、最融洽的秩序。” “在乡土社会中，这种理论多少可以说是正确的，正确的原因并不是真是有个“冥冥中”的那只手，而是在乡土社会中个人的欲望常是合于人类生存条件的。” 于是乡土社会靠欲望，不像现代社会靠理性和计划。 “在乡土社会中人可以靠欲望去行事，但在现代社会中欲望并不能作为人们行为的指导，于是产生“需要”，因之有了“计划”。从欲望到需要是社会变迁中一个很重要的里程碑。” 乡土社会依赖经验，现代社会依赖知识。 “乡土社会是个传统社会，传统就是经验的累积，能累积就是说经得起自然选择的，各种“错误”—不合于生存条件的行为—被淘汰之后留下的那一套生活方式。不论行为者对于这套方式怎样说法，它们必然是有助于生存的。” “在现代社会里知识即是权力，因为在这种社会里生活的人要依他们的需要去做计划。从知识里得来的权力是我在上文中所称的时势权力。”","categories":["关于世界的一切"]},{"title":"套路真多","path":"/memoirs/20210820/套路真多/","content":"小说的那些套路 1.落魄大叔爱喝酒，以前肯定是高手。 2.高手厌倦俗世纷争，避世隐居。但往往无论什么杂鱼都知道他隐居到哪儿去了。 3.几拨人同时上山去请一个高手，谁先上去谁倒霉。高手都是跟着最后上去的那拨人走的。 4.大家族里从来不学文化课，整天研究怎么打架，年轻一代天天就盘算着出去强抢民女。就这点出息，见笑了。 5.叶、萧、林、易，四大修真家族，长期为修真界输送着各种优秀人才。 6.统领一方地界的强者，见到少年高手从来不想着笼络，只想着灭口。难怪手下只剩下些弱智。 7.超级废柴划入外门，走上人生巅峰。顶级天才被收为入室弟子，从此暗淡无光。 8.顶级高手的孩子自带GPS，不管小时候扔多远，最后总能找回来。 9.圣女选出来就是为了让人拐跑的。 10.名医给病人治完病往往会顺带把自家闺女搭出去。 11.一个普通人活了几十年学会写字绘画，修身养性。一个修真者修炼数百年满脑子是女人和钱。 12.但凡大家族都有一套特别邪门的武功，用了会短命的那种。 13.著名学院附近多半有树林，树林里必定蹲着一些特别危险的上古魔兽。 14.顶级高手不是二十岁以下的就是几百岁以上的，中间好几代人都在打酱油。 15.高手出招如电如风，但一定会很礼貌地等敌人摆完姿势喊完招式名才动手。 16.无论什么高级毒药都是可以化解的，唯独泻药无解。不管是什么等级的高手，服了泻药没有几个能解掉的。 17.正道长期向魔道输送高级人才魔道长期向正道提供绝世神兵。 18.他是众口相传的绝顶高手，令后辈敬仰的不朽传奇重新出山不到三天,就被新人按在地上暴打。 19.看管门派重地的人都很喜欢私自放人进去。 20.名门大派的后山或者断崖往往藏着一些不得了的东西。 21.有些感觉敏锐的掌门可能会发现，自从某个弟子加入之后，什么寻仇的，叛变的，踢馆的就都找上门了，各种上古魔兽、神级高手排着队来搞事，传说中的丧门星可能真的是存在的。 后续持续更新。。。","categories":["关于世界的一切"]},{"title":"乌合之众","path":"/memoirs/20210729/乌合之众/","content":"1.人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人备感安全的归属感。 2.我们始终有一种错觉，以为我们的感情源自于我们自己的内心。 3.群体只会干两种事——锦上添花或落井下石。 4.个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到的约束的一面。群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。 5.我们以为自己是理性的，我们以为自己的一举一动都是有其道理的。但事实上，我们的绝大多数日常行为，都是一些我们自己根本无法了解的隐蔽动机的结果。 6.所谓的信仰，它能让一个人变得完全受自己的梦想奴役。 7.在与理性永恒的冲突中，感情从未失过手。 8.有时不真实的东西比真实的东西包含更多的真理。 9.群众没有真正渴求过真理，面对那些不合口味的证据，他们会充耳不闻…凡是能向他们提供幻觉的，都可以很容易地成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。 10.数量，即是正义。 11.掌握了影响群众想象力的艺术，也就掌握了统治他们的艺术。 12.没有传统，就没有文明；没有对传统的缓慢淘汰，就没有进步。 13.孤立的个人很清楚，在孤身一人时，他不能焚烧宫殿或洗劫商店，即使受到这样做的诱惑，他也很容易抵制这种诱惑。但是在成为群体的一员时，他就会意识到人数赋予他的力量，这足以让他生出杀人劫掠的念头，并且会立刻屈从于这种诱惑。出乎预料的障碍会被狂暴地摧毁。人类的机体的确能够产生大量狂热的激情，因此可以说，愿望受阻的群体所形成的正常状态，也就是这种激愤状态。 14.一个国家为其年轻人所提供的教育，可以让我们看到这个国家未来的样子。 15.能够感觉到的现象可以比作波浪，是海洋深处我们一无所知的那些乱象在洋面上的表象。 16.昨天受群众拥戴的英雄一旦失败，今天就会受到侮辱。当然名望越高，反应就会越强烈。在这种情况下，群众就会把末路英雄视为自己的同类，为自己曾向一个已不复存在的权威低头哈腰而进行报复。 17.群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。 18.群体因为夸大自己的感情，因此它只会被极端感情所打动。希望感动群体的演说家，必须出言不逊，信誓旦旦。夸大其辞、言之凿凿、不断重复、绝对不以说理的方式证明任何事情——这些都是公众集会上的演说家惯用的论说技巧。 19.令人难忘的历史事件，只是人类思想无形的变化造成的有形的后果而已。 20.孤立的个体具有控制自身反应行为的能力，而群体则不具备。 21.专横和偏执是一切类型的群体的共性。 22.影响民众想象力的，并不是事实本身，而是它们发生和引起注意的方式。 23.群体总是对强权俯首帖耳，却很少为仁慈善行感动！在他们看来，仁慈善良只不过是软弱可欺的代名词。 24.大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍赞同! 25.群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。 26.从长远看，不断重复的说法会进入我们无意识的自我的深层区域，而我们的行为动机正是在这里形成的。到了一定的时候，我们会忘记谁是那个不断被重复的主张的作者，我们最终会对它深信不移。 27.群体中的个人是沙中之沙，风可以随意搅动他们。 28.群体表现出来的感情不管是好是坏，其突出的特点就是极为简单而夸张。 29.但凡能够成就大业的领袖人物，他重要的品质不是博学多识，而是必须具备强大而持久的意志力，这是一种极为罕见，极为强大的品质，它足以征服一切。 30.文明向来只由少数知识贵族阶级而非群体来创造。 31.身为一位领袖，如果想要让自己创立的宗教或政治信条站住脚，就必须成功地激起群众想入非非的感情。 32.结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没有什么事情是办不到的。 33.当一个人融入社会之中时，他便失去了自我。 34.在迫不得已的情况下，我们也许还是会愿意接受传统教育当中所有的弊端，因为尽管它只会培养一些被社会所抛弃的人、心怀不满的人，但起码，对冗繁知识的肤浅掌握，对成堆教科书的完美背诵，或许可以提高智力水平。但事实上它真的能提高智力吗？不可能！在生活中，判断力、经验、进取心和个性，这些才是取得成功的条件，这些都不是书本所能够给予的。书本是可供查询的有用字典，但倘若把这些冗长的词条都装在脑子里，那可是一点用都没有。 35.文明赖以形成的道德力量失去效力时，它的最终瓦解总是由无意识且野蛮的群体来完成的。 36.一切政治、神学或社会信条，要想在群众中扎根，都必须采取宗教的形式——能够把危险的讨论排除在外的形式。 37.群体精神最需要的不是自由而是服从。他们如此甘愿听从别人的意志，以至于只要有人自称是它们的主人，他们就会本能地听命于他。 38.尽管在那一天的那两个小时里他们做到了或者几乎做到了，到一个月以后他们却不再具备这种能力。他们无法再次通过考试。他们脑中不断丢失大量过于沉重的知识，而且没有新的知识来填充。他们的思想活力开始衰退，促进成长的才能渐渐干涸，这时一个得到充分发展的人诞生了，但此时的他早已疲惫不堪。结婚过上安定的生活，陷入某种循环，并永无止境地重复下去；他将自己封闭在狭隘的工作中，尽职尽责，仅此而已。他们最终变为了平庸之辈。 39.个人一旦融入群体，他的个性便会被湮没，群体的思想便会占据绝对的统治地位，而与此同时，群体的行为也会表现出排斥异议，极端化、情绪化及低智商化等特点。进而对社会产生破坏性的影响。 40.所有时代和所有国家的伟大政客，包括最专横的暴君，也都把群众的想象力视为他们权力的基础，他们从来没有设想过通过与它作对而进行统治。要想掌握这种本领，万万不可求助于智力或推理，也就是说，绝对不可以采用论证的方式。 41.群体的叠加只是愚蠢的叠加，而真正的智慧被愚蠢的洪流淹没。 42.人们经常说起那家大众剧院，它只演令人压抑的戏剧，散场后，必须保护扮演叛徒的演员，免得他遭到观众的暴打。他所犯的罪行，当然是想象出来的，引起了群众的巨大愤怒。我觉得这是群体精神状态最显著的表现之一，这清楚地说明，要给他们什么暗示是一件多么容易的事情。对他们来说，假与真几乎同样奏效。他们明显地表现出真假不分的倾向。 43.各种制度并没有固定的优点，就它们本身而言，它们无所谓好坏。因为在特定的时刻对一个民族有益的制度，对另一个民族也许是极为有害的 。 44.群体也许永远是无意识的，但这种无意识本身，可能就是它力量强大的秘密之一。在自然界，绝对服从本能的生物，其行为会复杂得让我们不敢相信。理智是人类新近才有的东西，太不完美了，不能向我们揭示无意识的规律，更不能替代它。在我们的行为举止中，无意识部分占的比重很大，理智所占的比例却很小。无意识现在仍作为未知的力量在起作用。 45.到了一定的时候我们不会记得那个不断被重复的主张的人是谁，我们最终会对它深信不疑，广告能有令人吃惊的威力，这就是原因 。 46.教育既不会让人更道德，同样不会使他更幸福，它既不能将他的本能改变 ，也不能将他天生的热情改变，而且有在进行不良引导后，它的害处远大于好处。 47.单独一个人必须要为他的行为承担责任——法律上或者道德上。但是，群体则不然，群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体就是道德，群体的行为自然是合理的。 48.名望的产生与若干因素有关，而成功永远是其中最重要的一个。 49.学习课程，把一种语法或一篇纲要牢记在心，重复得好，模仿也出色——这实在是一种十分可笑的教育方式，它的每项工作都是一种信仰行为，即默认教师不可能犯错误。这种教育的唯一结果，就是贬低自我，让我们变得无能。 50.民众的想象力是政客的权力基础。 51.在决定人们历史地位上起着更大作用的，不是他们的“真实”面目，而是后人对他们的认识和感受。 52.群体会让每个人在其中的错误缩小，同时让每个人的恶意被无限放大。 54.束缚个人行为的责任感一消失，人便会随心所欲，肆意妄为。 55.群体的无意识行为取代了个体有意识的行为，这是现时代最显著的特征之一。 56.偶像崇拜的五大标识： 第一，偶像总是凌驾于信徒，处于高高在上的地位，这一点有着决定性地作用。 第二，信徒总是盲目服从偶像的命令。 第三，信徒没有能力，也不愿意对偶像规定的信条进行讨论。 第四，信徒有着狂热的愿望，希望把偶像的信条广加传播。 第五，信徒倾向于把不接受它们的任何人视为仇敌。 当群体符合第一条，其形式就等同于宗教，而这种情感就变成了宗教信仰。 对群体来说，也许最不合理的才是最合理的选择 57.群众日益被大众文化所湮没，这种文化把平庸低俗当作最有价值的东西。 58.所以不要轻易地成为集体的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一下而已，实际上你已经成了帮凶。 59.群体的夸张倾向只作用于感情，对智力不起任何作用。 60.群体不善推理，却又急于行动。","categories":["关于世界的一切"]},{"title":"React 技术栈（一）","path":"/memoirs/20210619/ReactStack-1/","content":"ECMAScript 6 简介除开JavaScript的基础内容，React 必备的知识肯定非 ES6，其实前面的文章已经讲了一部分的ES6的内容，这边只记录，我觉得比较重要的ES6的内容ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 let 和 const 命令let var这个很简单，不需要解释了，跟现在新的语言的用法一致，const 就是类似 C 里面修饰指针，则指针不变，修饰常量则常量不可变化，没什么可说的。JavaScript 以前的var就挺曹丹的，现在的用法起码像个人了。 箭头函数箭头函数有几个使用注意点。 （1）箭头函数没有自己的this对象（详见下文）。 （2）不可以当作构造函数，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，最重要的是第一点。对于普通函数来说，内部的this指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的this对象，内部的this就是定义时上层作用域中的this。也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的。 function foo() setTimeout(() = console.log(id:, this.id); , 100);var id = 21;foo.call( id: 42 );// id: 42 上面代码中，setTimeout()的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以打印出来的是42。 箭头函数的什么教程一大堆，在我看来都是为了之前的设计买单而已，如果真的是像写Java 一样写，this的指向不会出现任何问题，普通函数的this 是不确定的，那么使用普通函数的时候bind一个this就完全可以解决了。 JavaScript 是一个很让人头疼的语言，有些人总是摸着规则的边缘写代码，然后减少了几行代码，以为有多厉害。我只想说，并不是人家看不懂就厉害的，那些白痴们。如果只学习JavaScript一种语言，那他的代码肯定是乱七八糟的。所以我每年基本上都会复习一下C的知识，还是很有用的，了解程序运行的底层逻辑，才能更好地写代码。 对象的扩展对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍Object对象的新增方法。 属性的赋值器（setter）和取值器（getter）const cart = _wheels: 4, get wheels () return this._wheels; , set wheels (value) if (value this._wheels) throw new Error(数值太小了！); this._wheels = value; super 关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 const proto = foo: hello;const obj = foo: world, find() return super.foo; ;Object.setPrototypeOf(obj, proto);obj.find() // hello 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 // 报错const obj = foo: super.foo// 报错const obj = foo: () = super.foo// 报错const obj = foo: function () return super.foo 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。 const proto = x: hello, foo() console.log(this.x); ,;const obj = x: world, foo() super.foo(); Object.setPrototypeOf(obj, proto);obj.foo() // world 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。","tags":["基础知识","React","JavaScript"],"categories":["IT技术"]},{"title":"JavaScript 温习记录（二）","path":"/memoirs/20201102/JavaScript-study-record-2/","content":"写在前面的话JavaScript 语言的内容，前面基本上也记录的差不多了。这里就聊一些JavaScript语言更深入的问题，加深对这个语言的理解。C 和 Java 始终是 JavaScript 的基础，很多概念都是直接继承过来的，所以学习 C 是很重要的。我基本上每年都会对 C 有一个回顾，然后把数据结构的书再看一遍。扯远了，这边只是记录 JavaScript 一些知识点，让我以后更好地上手 JavaScript，也是学习React的一个必要的过程。虽然我已经有一个上线的 React 项目，但是React的很多原理我基本上是抓瞎的。作为一个移动端，在现在大前端的趋势下，多一个React的能力也挺好的。好几年前已经用Vue上线过一个项目了，但是那个项目比较简单，所以几年过去，我基本上忘的差不多了。 继承与原型链对于使用过基于类的语言 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）。 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 尽管这种原型继承通常被认为是 JavaScript 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。 基于原型链的继承JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指向 someObject 的原型。从 ECMAScript 6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。 但它不应该与构造函数 func 的 prototype 属性相混淆。被构造函数创建的实例对象的 [[Prototype]] 指向 func 的 prototype 属性。Object.prototype 属性表示 Object 的原型对象。 // 让我们从一个函数里创建一个对象o，它自身拥有属性a和b的：let f = function () this.a = 1; this.b = 2;/* 这么写也一样function f() this.a = 1; this.b = 2;*/let o = new f(); // a: 1, b: 2// 在f函数的原型上定义属性f.prototype.b = 3;f.prototype.c = 4;// 不要在 f 函数的原型上直接定义 f.prototype = b:3,c:4;这样会直接打破原型链// o.[[Prototype]] 有属性 b 和 c// (其实就是 o.__proto__ 或者 o.constructor.prototype)// o.[[Prototype]].[[Prototype]] 是 Object.prototype.// 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null// 这就是原型链的末尾，即 null，// 根据定义，null 就是没有 [[Prototype]]。// 综上，整个原型链如下:// a:1, b:2 --- b:3, c:4 --- Object.prototype--- nullconsole.log(o.a); // 1// a是o的自身属性吗？是的，该属性的值为 1console.log(o.b); // 2// b是o的自身属性吗？是的，该属性的值为 2// 原型上也有一个b属性，但是它不会被访问到。// 这种情况被称为属性遮蔽 (property shadowing)console.log(o.c); // 4// c是o的自身属性吗？不是，那看看它的原型上有没有// c是o.[[Prototype]]的属性吗？是的，该属性的值为 4console.log(o.d); // undefined// d 是 o 的自身属性吗？不是，那看看它的原型上有没有// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有// o.[[Prototype]].[[Prototype]] 为 null，停止搜索// 找不到 d 属性，返回 undefined 在 JavaScript 中使用原型接下去，来仔细分析一下这些应用场景下， JavaScript 在背后做了哪些事情。正如之前提到的，在 JavaScript 中，函数（function）是允许拥有属性的。所有的函数会有一个特别的属性 —— prototype 。请注意，以下的代码是独立的（出于严谨，假定页面没有其他的JavaScript代码）。为了最佳的学习体验，我们强烈建议阁下打开浏览器的控制台（在Chrome和火狐浏览器中，按Ctrl+Shift+I即可），进入“console”选项卡，然后把如下的JavaScript代码复制粘贴到窗口中，最后通过按下回车键运行代码。 function doSomething()console.log( doSomething.prototype );// 和声明函数的方式无关，// JavaScript 中的函数永远有一个默认原型属性。var doSomething = function();console.log( doSomething.prototype ); 在控制台显示的JavaScript代码块中，我们可以看到doSomething函数的一个默认属性prototype。而这段代码运行之后，控制台应该显示类似如下的结果： constructor: ƒ doSomething(), __proto__: constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() // 我们可以给doSomething函数的原型对象添加新属性function doSomething()doSomething.prototype.foo = bar;console.log( doSomething.prototype );// 可以看到运行后的结果 foo: bar, constructor: ƒ doSomething(), __proto__: constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() 现在我们可以通过new操作符来创建基于这个原型对象的doSomething实例。使用new操作符，只需在调用doSomething函数语句之前添加new。这样，便可以获得这个函数的一个实例对象。一些属性就可以添加到该原型对象中。 function doSomething()doSomething.prototype.foo = bar; // add a property onto the prototypevar doSomeInstancing = new doSomething();doSomeInstancing.prop = some value; // add a property onto the objectconsole.log( doSomeInstancing ); prop: some value, __proto__: foo: bar, constructor: ƒ doSomething(), __proto__: constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() 如上所示, doSomeInstancing 中的__proto__是 doSomething.prototype. 但这是做什么的呢？当你访问doSomeInstancing 中的一个属性，浏览器首先会查看doSomeInstancing 中是否存在这个属性。 如果 doSomeInstancing 不包含属性信息, 那么浏览器会在 doSomeInstancing 的 __proto__ 中进行查找(同 doSomething.prototype). 如属性在 doSomeInstancing 的 __proto__ 中查找到，则使用 doSomeInstancing 中 __proto__ 的属性。 否则，如果 doSomeInstancing 中 __proto__ 不具有该属性，则检查doSomeInstancing 的 __proto__ 的 __proto__ 是否具有该属性。默认情况下，任何函数的原型属性 __proto__ 都是 window.Object.prototype. 因此, 通过doSomeInstancing 的 __proto__ 的 __proto__ ( 同 doSomething.prototype 的 __proto__ (同 Object.prototype)) 来查找要搜索的属性。 如果属性不存在 doSomeInstancing 的 __proto__ 的 __proto__ 中， 那么就会在 doSomeInstancing 的 __proto__ 的 __proto__ 的 __proto__ 中查找。然而, 这里存在个问题：doSomeInstancing 的 __proto__ 的 __proto__ 的 __proto__ 其实不存在。因此，只有这样，在 __proto__ 的整个原型链被查看之后，这里没有更多的 __proto__ ， 浏览器断言该属性不存在，并给出属性值为 undefined 的结论。 使用不同的方法来创建对象和生成原型链使用语法结构创建的对象var o = a: 1;// o 这个对象继承了 Object.prototype 上面的所有属性// o 自身没有名为 hasOwnProperty 的属性// hasOwnProperty 是 Object.prototype 的属性// 因此 o 继承了 Object.prototype 的 hasOwnProperty// Object.prototype 的原型为 null// 原型链如下:// o --- Object.prototype --- nullvar a = [yo, whadup, ?];// 数组都继承于 Array.prototype// (Array.prototype 中包含 indexOf, forEach 等方法)// 原型链如下:// a --- Array.prototype --- Object.prototype --- nullfunction f() return 2; 使用构造器创建的对象function Graph() this.vertices = []; this.edges = [];Graph.prototype = addVertex: function(v) this.vertices.push(v); ;var g = new Graph();// g 是生成的对象，他的自身属性有 vertices 和 edges。// 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。 使用 Object.create 创建的对象ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数： var a = a: 1;// a --- Object.prototype --- nullvar b = Object.create(a);// b --- a --- Object.prototype --- nullconsole.log(b.a); // 1 (继承而来)var c = Object.create(b);// c --- b --- a --- Object.prototype --- nullvar d = Object.create(null);// d --- nullconsole.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype 使用 class 关键字创建的对象ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 class, constructor，static，extends 和 super。 use strict;class Polygon constructor(height, width) this.height = height; this.width = width; class Square extends Polygon constructor(sideLength) super(sideLength, sideLength); get area() return this.height * this.width; set sideLength(newLength) this.height = newLength; this.width = newLength; var square = new Square(2); 内存管理像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 内存生命周期不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放\\归还 所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。 JavaScript 的内存分配为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。 var n = 123; // 给数值变量分配内存var s = azerty; // 给字符串分配内存var o = a: 1, b: null; // 给对象及其包含的值分配内存// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, abra];function f(a) return a + 2; // 给函数（可调用的对象）分配内存// 函数表达式也能分配一个对象someElement.addEventListener(click, function() someElement.style.backgroundColor = blue;, false); 通过函数调用分配内存 var d = new Date(); // 分配一个 Date 对象var e = document.createElement(div); // 分配一个 DOM 元素// 有些方法分配新变量或者新对象：var s = azerty;var s2 = s.substr(0, 3); // s2 是一个新的字符串// 因为字符串是不变量，// JavaScript 可能决定不分配内存，// 只是存储了 [0-3] 的范围。var a = [ouais ouais, nan nan];var a2 = [generation, nan nan];var a3 = a.concat(a2);// 新数组有四个元素，是 a 连接 a2 的结果 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 当内存不再需要使用时释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 垃圾回收如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 var o = a: b:2 ;// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = yo; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了// 但是它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了// 它可以被垃圾回收了 该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 function f() var o = ; var o2 = ; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return azerty;f(); 这里的内存管理讲的很一般，如果要详细的了解，还是要去看 C 的指针部分的内容。不过 C 的指针内容很复杂，需要慢慢斟酌，慢慢理解 函数函数算是 js 里面花样最多的了，其他语言也有闭包，函数式编程，但是花样这么多，用法这么乱的挺少的。起码Swift的 函数真的很好用，然后对于引用对象的 拷贝也是正常的 C 的逻辑，js的我现在很难理解，也看不到底层的内存分布是怎么个逻辑。 还是先看看 函数的 教程吧 箭头函数箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 语法基础语法 (param1, param2, …, paramN) = statements (param1, param2, …, paramN) = expression//相当于：(param1, param2, …, paramN) = return expression; // 当只有一个参数时，圆括号是可选的：(singleParam) = statements singleParam = statements // 没有参数的函数应该写成一对圆括号。() = statements 高级语法 //加括号的函数体返回对象字面量表达式：params = (foo: bar)//支持剩余参数和默认参数(param1, param2, ...rest) = statements (param1 = defaultValue1, param2, …, paramN = defaultValueN) = statements//同样支持参数列表解构let f = ([a, b] = [1, 2], x: c = x: a + b) = a + b + c;f(); // 6 描述引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 更短的函数 var elements = [ Hydrogen, Helium, Lithium, Beryllium];elements.map(function(element) return element.length;); // 返回数组：[8, 6, 7, 9]// 上面的普通函数可以改写成如下的箭头函数elements.map((element) = return element.length;); // [8, 6, 7, 9]// 当箭头函数只有一个参数时，可以省略参数的圆括号elements.map(element = return element.length;); // [8, 6, 7, 9]// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号elements.map(element = element.length); // [8, 6, 7, 9]// 在这个例子中，因为我们只需要 `length` 属性，所以可以使用参数解构// 需要注意的是字符串 `length` 是我们想要获得的属性的名称，而 `lengthFooBArX` 则只是个变量名，// 可以替换成任意合法的变量名elements.map(( length: lengthFooBArX ) = lengthFooBArX); // [8, 6, 7, 9] 没有单独的this 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值： 如果是该函数是一个构造函数，this指针指向一个新的对象 在严格模式下的函数调用下，this指向undefined 如果是该函数是一个对象的方法，则它的this指针指向这个对象 等等 This被证明是令人厌烦的面向对象风格的编程。 function Person() // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; , 1000);var p = new Person();// 在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。function Person() var that = this; that.age = 0; setInterval(function growUp() // 回调引用的是`that`变量, 其值是预期的对象. that.age++; , 1000); 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同.严格模式的其他规则依然不变. function Person() this.age = 0; setInterval(() = this.age++; // |this| 正确地指向 p 实例 , 1000);var p = new Person(); 通过 call 或 apply 调用由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this—译者注），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立—译者注） var adder = base : 1, add : function(a) var f = v = v + this.base; return f(a); , addThruCall: function(a) var f = v = v + this.base; var b = base : 2 ; return f.call(b, a); ;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2 箭头函数不绑定Arguments 对象。因此，在本示例中，arguments只是引用了封闭作用域内的arguments： var arguments = [1, 2, 3];var arr = () = arguments[0];arr(); // 1function foo(n) var f = () = arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n,即传给foo函数的第一个参数 return f();foo(1); // 2foo(2); // 4foo(3); // 6foo(3,2);//6foo(4);//8// 在大多数情况下，使用剩余参数是相较使用arguments对象的更好选择。function foo(arg) var f = (...args) = args[0]; return f(arg);foo(1); // 1function foo(arg1,arg2) var f = (...args) = args[1]; return f(arg1,arg2);foo(1,2); //2 最后就到这里吧，js的内容看得我头疼，又很困。 参考文档JavaScript","tags":["Web","基础知识","JavaScript"],"categories":["IT技术"]},{"title":"JavaScript 温习记录（一）","path":"/memoirs/20201030/JavaScript-study-record/","content":"写在前面的话最近用react-native 完成了一个公司的项目，JavaScript 其实已经看过很多遍了，上个月就看了一遍全部的教程，但是没有系统的记录，以及一些比较麻烦的地方。有一些三方的源码还是看的不太懂，而且js的坑不算少，我希望能够记录一下，下次能够快速定位问题。（起码我可以看得懂三方的源代码o(╯□╰)o） 让我们愉快的开始吧JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 Node.js、 Apache CouchDB 和 Adobe Acrobat。JavaScript 是一种基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。了解更多 JavaScript。 一些基础的知识这里就不说了，主要是一些值得注意的。 Promises从 ECMAScript 6 开始，JavaScript 增加了对 Promise 对象的支持，它允许你对延时和异步操作流进行控制。Promise 对象有以下几种状态： pending：初始的状态，即正在执行，不处于 fulfilled 或 rejected 状态。 fulfilled：成功的完成了操作。 rejected：失败，没有完成操作。 settled：Promise 处于 fulfilled 或 rejected 二者中的任意一个状态, 不会是 pending。 通过 XHR 加载图片你可以在 MDN GitHub promise-test 中找到这个简单的例子，它使用了 Promise 和 XMLHttpRequest 来加载一张图片，你也可以直接在这个页面查看他的效果。同时为了让你更清楚的了解 Promise 和 XHR 的结构，代码中每一个步骤后都附带了注释。 这里有一个未注释的版本，展现了 Promise 的工作流，希望可以对你的理解有所帮助。 function imgLoad(url) return new Promise(function(resolve, reject) var request = new XMLHttpRequest(); request.open(GET, url); request.responseType = blob; request.onload = function() if (request.status === 200) resolve(request.response); else reject(Error(Image didn\\t load successfully; error code: + request.statusText)); ; request.onerror = function() reject(Error(There was a network error.)); ; request.send(); ); Promise 这里只是简单介绍，后面会用单独的部分来讲解的 函数函数是 JavaScript 中的基本组件之一。 一个函数是 JavaScript 过程 — 一组执行任务或计算值的语句。要使用一个函数，你必须将其定义在你希望调用它的作用域内。 一个JavaScript 函数用function关键字定义，后面跟着函数名和圆括号。 函数很重要，函数作用域很重要，最关键的是js的作用域有很多奇葩的地方 在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。换言之，定义在全局域中的函数可以访问所有定义在全局域中的变量。在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量。 // 下面的变量定义在全局作用域(global scope)中var num1 = 20, num2 = 3, name = Chamahk;// 本函数定义在全局作用域function multiply() return num1 * num3;function change() num1 = 40; num2 = 3;function multiplyWithNumber(num1: number, num2: number) const num = num1 * num2; return num;multiply(); // 返回 60multiplyWithNumber(num1, num2)change();multiply(); // 返回 ??? 120var c = num: 10var d = var a = init(num, obj) this.num = num this.obj = obj a.init(c.num, d)c.num = 20d = aaaa: 1 var b = num: a.num, change: function() num = 20 b.change()a.numb.num 嵌套函数和闭包你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）。 既然嵌套函数是一个闭包，就意味着一个嵌套函数可以”继承“容器函数的参数和变量。换句话说，内部函数包含外部函数的作用域。 function outside(x) function inside(y) return x + y; return inside;fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加3result = fn_inside(5); // returns 8result1 = outside(3)(5); // returns 8 闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。 此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。 函数参数从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。在JavaScript中，函数参数的默认值是undefined。然而，在某些情况下设置不同的默认值是有用的。这时默认参数可以提供帮助。 剩余参数语法允许将不确定数量的参数表示为数组。在下面的例子中，使用剩余参数收集从第二个到最后参数。然后，我们将这个数组的每一个数与第一个参数相乘。这个例子是使用了一个箭头函数，这将在下面介绍。 function multiply(multiplier, ...theArgs) return theArgs.map(x = multiplier * x);var arr = multiply(2, 1, 2, 3);console.log(arr); // [2, 4, 6] 箭头函数箭头函数表达式（也称胖箭头函数）相比函数表达式具有较短的语法并以词法的方式绑定 this。箭头函数总是匿名的。另见 hacks.mozilla.org 的博文：“深度了解ES6：箭头函数”。 有两个因素会影响引入箭头函数：更简洁的函数和 this。 数字和日期数字在 JavaScript 里面，数字均为双精度浮点类型（double-precision 64-bit binary format IEEE 754），即一个介于±2−1023和±2+1024之间的数字，或约为±10−308到±10+308，数字精度为53位。整数数值仅在±(253 - 1)的范围内可以表示准确。 JavaScript最近添加了 BigInt 的支持，能够用于表示极大的数字。使用 BigInt 的时候有一些注意事项，例如，你不能让 BigInt 和 Number 直接进行运算，你也不能用 Math 对象去操作 BigInt 数字。 请参见Javascript指南中的 JavaScript 数据类型和数据结构 ，了解其他更多的基本类型。 日期对象JavaScript没有日期数据类型。但是你可以在你的程序里使用 Date 对象和其方法来处理日期和时间。Date对象有大量的设置、获取和操作日期的方法。 它并不含有任何属性。JavaScript 处理日期数据类似于Java。这两种语言有许多一样的处理日期的方法，也都是以1970年1月1日00:00:00以来的毫秒数来储存数据类型的。 处理日期时间的Date对象方法可分为以下几类： “set” 方法, 用于设置Date对象的日期和时间的值。 “get” 方法,用于获取Date对象的日期和时间的值。 “to” 方法,用于返回Date对象的字符串格式的值。 parse 和UTC 方法, 用于解析Date字符串。 正则表达式正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。本章介绍 JavaScript 正则表达式。 字符 含义 \\ 依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 “ 的 “b” 通常匹配小写字母 “b”，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 “，它将不再匹配任何字符，而是表示一个字符边界。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 “转义（Escaping）” 部分。如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。[a-z]\\si 和 new RegExp(“[a-z]\\s”, “i”) 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\\s 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 [a-z]:\\i 和 new RegExp(“[a-z]:\\\\“,”i”) 会创建相同的表达式，即匹配类似 “C: 字符串。 ^ 匹配输入的开始 $ 匹配输入的结束 * 匹配前一个表达式 0 次或多次。等价于 {0,} + 匹配前面一个表达式 1 次或者多次。等价于 {1,} ? 匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。 . （小数点）默认匹配除换行符之外的任何单个字符。 x|y 匹配‘x’或者‘y’。 例如, a{2,} 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。 (x) 像下面的例子展示的那样，它会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。 (?:x) 匹配 ‘x’ 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。 x(?y) 匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。 (?y)x 匹配’x’仅当’x’前面是’y’.这种叫做后行断言。 x(?!y) 仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。 (?!y)x 仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。 {n} n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。比如， a{2} 不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个’a’。 {n,} n是一个正整数，匹配前一个字符至少出现了n次。例如, a{2,} 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。 {n,m} n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，a{1, 3} 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。 [xyz] 一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。[a-z.]+ 和[\\w.]+与字符串“test.i.ng”匹配。 [^xyz] 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。 [\\b] 匹配一个退格(U+0008)。（不要和\\b混淆了。） \\b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\\b]混淆了）使用”moon”举例：\\bm匹配“moon”中的‘m’；oo\\b并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。oon\\b匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 \\B 匹配一个非单词边界。 \\d 匹配一个数字。等价于[0-9]。例如， \\d 或者 [0-9] 匹配”B2 is the suite number.”中的’2’。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符 (U+000C)。 匹配一个换行符 (U+000A)。 \\r 匹配一个回车符 (U+000D)。 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符。 \\S 匹配一个非空白字符。 \\t 匹配一个水平制表符 (U+0009)。 \\v 匹配一个垂直制表符 (U+000B)。 \\w 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。例如, \\w 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。 \\W 匹配一个非单字字符。等价于 [^A-Za-z0-9_]。例如, \\W 或者 [^A-Za-z0-9_] 匹配 “50%.” 中的 ‘%’。 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 apple(,)\\sorange\\1 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。 \\0 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 \\0 是一个八进制转义序列。 \\xhh 匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。 \\uhhhh 匹配一个四位十六进制数表示的 UTF-16 代码单元。 \\u{hhhh}或\\u{hhhhh} （仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。 数组对象(Array object)数组(array)是一个有序的数据集合，我们可以通过数组名称(name)和索引(index)进行访问。例如，我们定义了一个数组emp，数组中的每个元素包含了一个雇员的名字以及其作为索引的员工号。那么emp[1]将会代表1号员工，emp[2]将会代表2号员工，以此类推。 JavaScript中没有明确的数组数据类型。但是，我们可以通过使用内置Array对象和它的方法对数组进行操作。Array对象有很多操作数组的方法，比如合并、反转、排序等。数组对象有一个决定数组长度和使用正则表达式操作其他属性的属性。 var arr = new Array(element0, element1, ..., elementN);var arr = Array(element0, element1, ..., elementN);var arr = [element0, element1, ..., elementN];// 译者注: var arr=[4] 和 var arr=new Array(4)是不等效的，// 后者4指数组长度，所以使用字面值(literal)的方式应该不仅仅是便捷，同时也不易踩坑var arr = new Array(arrayLength);var arr = Array(arrayLength);// 这样有同样的效果var arr = [];arr.length = arrayLength; 数组的方法(array methods)Array 对象具有下列方法：concat() 连接两个数组并返回一个新的数组。 var myArray = new Array(1, 2, 3);myArray = myArray.concat(a, b, c); // myArray is now [1, 2, 3, a, b, c] join(deliminator ‘,’) 将数组的所有元素连接成一个字符串。 var myArray = new Array(Wind, Rain, Fire);var list = myArray.join( - ); // list is Wind - Rain - Fire push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。 var myArray = new Array(1, 2);myArray.push(3); // myArray is now [1, 2, 3] pop() 从数组移出最后一个元素，并返回该元素。 var myArray = new Array(1, 2, 3);var last = myArray.pop();// myArray is now [1, 2], last = 3 shift() 从数组移出第一个元素，并返回该元素。 var myArray = new Array (1, 2, 3);var first = myArray.shift(); // myArray is now [2, 3], first is 1 unshift() 在数组开头添加一个或多个元素，并返回数组的新长度。 var myArray = new Array (1, 2, 3);myArray.unshift(4, 5); // myArray becomes [4, 5, 1, 2, 3] 其他的就不一一介绍了 类型化数组(Typed Arrays )JavaScript typed arrays 是类数组对象（array-like object），其提供访问原始二进制数据的机制。 就像你知道的那样, Array 对象动态增长和收缩，可以有任何JavaScript值。但对于类型化数组，JavaScript引擎执行优化使得这些数组访问速度快速。 随着Web应用程序变得越来越强大，添加音频和视频处理等功能、可以使用 WebSockets 、使用原始数据， 这都需要访问原始的二进制数据，所以专门的优化将有助于JavaScript代码能够快速和容易地操纵原始二进制数据类型的数组。 映射Map对象ECMAScript 2015 引入了一个新的数据结构来将一个值映射到另一个值。一个Map对象就是一个简单的键值对映射集合，可以按照数据插入时的顺序遍历所有的元素。 Object和Map的比较一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。 Object的键均为Strings类型，在Map里键可以是任意类型。必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。Map的遍历遵循元素的插入顺序。Object有原型，所以映射中有一些缺省的键。（可以用 map = Object.create(null) 回避）。 这三条提示可以帮你决定用Map还是Object： 如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。如果需要对个别元素进行操作，使用Object。 WeakMap对象WeakMap对象也是键值对的集合。它的键必须是对象类型，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被GC回收掉。WeakMap提供的接口与Map相同。 与Map对象不同的是，WeakMap的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。 对象（Object）javascript 中的对象(物体)，和其它编程语言中的对象一样，可以比照现实生活中的对象(物体)来理解它。 javascript 中对象(物体)的概念可以比照着现实生活中实实在在的物体来理解。 在javascript中，一个对象可以是一个单独的拥有属性和类型的实体。我们拿它和一个杯子做下类比。一个杯子是一个对象(物体)，拥有属性。杯子有颜色，图案，重量，由什么材质构成等等。同样，javascript对象也有属性来定义它的特征。 创建新对象JavaScript 拥有一系列预定义的对象。另外，你可以创建你自己的对象。从 JavaScript 1.2 之后，你可以通过对象初始化器（Object Initializer）创建对象。或者你可以创建一个构造函数并使用该函数和 new 操作符初始化对象。 PromisePromise 是一个对象，它代表了一个异步操作的最终完成或者失败。因为大多数人仅仅是使用已创建的 Promise 实例对象，所以本教程将首先说明怎样使用 Promise，再说明如何创建 Promise。 本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。 假设现在有一个名为 createAudioFileAsync() 的函数，它接收一些配置和两个回调函数，然后异步地生成音频文件。一个回调函数在文件成功创建时被调用，另一个则在出现异常时被调用。 链式调用连续执行两个或者多个异步操作是一个常见的需求，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 Promise 链来实现这种需求。 doSomething().then(function(result) return doSomethingElse(result);).then(function(newResult) return doThirdThing(newResult);).then(function(finalResult) console.log(Got the final result: + finalResult);).catch(failureCallback);// 我们也可以用箭头函数来表示doSomething().then(result = doSomethingElse(result)).then(newResult = doThirdThing(newResult)).then(finalResult = console.log(`Got the final result: $finalResult`);).catch(failureCallback); 错误传递在之前的回调地狱示例中，你可能记得有 3 次 failureCallback 的调用，而在 Promise 链中只有尾部的一次调用。通常，一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch() 指定的回调函数。这和以下同步代码的工作原理（执行过程）非常相似。 try let result = syncDoSomething(); let newResult = syncDoSomethingElse(result); let finalResult = syncDoThirdThing(newResult); console.log(`Got the final result: $finalResult`); catch(error) failureCallback(error);// 在 ECMAScript 2017 标准的 async/await 语法糖中，这种异步代码的对称性得到了极致的体现：async function foo() try const result = await doSomething(); const newResult = await doSomethingElse(result); const finalResult = await doThirdThing(newResult); console.log(`Got the final result: $finalResult`); catch(error) failureCallback(error); Promise 拒绝事件当 Promise 被拒绝时，会有下文所述的两个事件之一被派发到全局作用域（通常而言，就是window；如果是在 web worker 中使用的话，就是 Worker 或者其他 worker-based 接口）。这两个事件如下所示： rejectionhandled 当 Promise 被拒绝、并且在 reject 函数处理该 rejection 之后会派发此事件。 unhandledrejection 当 Promise 被拒绝，但没有提供 reject 函数来处理该 rejection 时，会派发此事件。 以上两种情况中，PromiseRejectionEvent 事件都有两个属性，一个是 promise 属性，该属性指向被驳回的 Promise，另一个是 reason 属性，该属性用来说明 Promise 被驳回的原因。 元编程从ECMAScript 2015 开始，JavaScript 获得了 Proxy 和 Reflect 对象的支持，允许你拦截并定义基本语言操作的自定义行为（例如，属性查找，赋值，枚举，函数调用等）。借助这两个对象，你可以在 JavaScript 元级别进行编程。 代理在 ECMAScript 6 中引入的 Proxy 对象可以拦截某些操作并实现自定义行为。 let handler = get: function(target, name) return name in target ? target[name] : 42; ;let p = new Proxy(, handler);p.a = 1;console.log(p.a, p.b); // 1, 42 Proxy 对象定义了一个目标（这里是一个空对象）和一个实现了 get 陷阱的 handler 对象。这里，代理的对象在获取未定义的属性时不会返回 undefined，而是返回 42。 反射Reflect 是一个内置对象，它提供了可拦截 JavaScript 操作的方法。该方法和代理句柄类似，但 Reflect 方法并不是一个函数对象。 客户端 Web API当你给网页或者网页应用编写客户端的JavaScript时， 你很快会遇上应用程序接口（API ）—— 这些编程特性可用来操控网站所基于的浏览器与操作系统的不同方面，或是操控由其他网站或服务端传来的数据。在这个单元里，我们将一同探索什么是API，以及如何使用一些在你开发中将经常遇见的API。 Web API简介首先, 我们将从一个更高的角度来看这些API —它们是什么，它们怎么起作用的，你该怎么在自己的代码中使用它们以及他们是怎么构成的？ 我们依旧会再来看一看这些API有哪些主要的种类和他们会有哪些用处。 操作文档当你在制作WEB页面和APP时,一个你最经常想要做的事就是通过一些方法来操作WEB文档。这其中最常见的方法就是使用文档对象模型Document Object Model (DOM)，它是一系列大量使用了 Document object的API来控制HTML和样式信息。通过这篇文章，我们来看看使用DOM方面的一些细节， 以及其他一些有趣的API能够通过一些有趣的方式改变你的环境。 从服务器获取数据在现代网页及其APP中另外一个很常见的任务就是与服务器进行数据交互时不再刷新整个页面，这看起来微不足道，但却对一个网页的展现和交互上起到了很大的作用，在这篇文章里，我们将阐述这个概念，然后来了解实现这个功能的技术，例如 XMLHttpRequest 和 Fetch API.（抓取API）。 第三方 API到目前为止我们所涉及的API都是浏览器内置的，但并不代表所有。许多大网站如Google Maps, Twitter, Facebook, PayPal等，都提供他们的API给开发者们去使用他们的数据（比如在你的博客里展示你分享的推特内容）或者服务（如在你的网页里展示定制的谷歌地图或接入Facebook登录功能）。这篇文章介绍了浏览器API和第三方API 的差别以及一些最新的典型应用。 绘制图形浏览器包含多种强大的图形编程工具，从可缩放矢量图形语言Scalable Vector Graphics (SVG) language，到HTML绘制元素canvas元素(The Canvas API and WebGL). 这篇文章提供了部分canvas的简介，以及让你更深入学习的资源。 视频和音频 APIHTML5能够通过元素标签嵌入富媒体——video and audio——而将有自己的API来控制回放，搜索等功能。本文向您展示了如何创建自定义播放控制等常见的任务。 客户端存储现代web浏览器拥有很多不同的技术，能够让你存储与网站相关的数据，并在需要时调用它们，能够让你长期保存数据、保存离线网站及其他实现其他功能。本文解释了这些功能的基本原理。 详细的内容以后在慢慢补充吧，这种 api 对于我来说没多大作用，我还是主要在语言方面多了解一些。 重新介绍 JavaScript（JS 教程）为什么会有这一篇“重新介绍”呢？因为 JavaScript 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤为必要。 我们有必要先从这门语言的历史谈起。在1995 年 Netscape 一位名为 Brendan Eich 的工程师创造了 JavaScript，随后在 1996 年初，JavaScript 首先被应用于 Netscape 2 浏览器上。最初的 JavaScript 名为 LiveScript，但是因为一个糟糕的营销策略而被重新命名，该策略企图利用Sun Microsystem的Java语言的流行性，将它的名字从最初的 LiveScript 更改为 JavaScript——尽管两者之间并没有什么共同点。这便是之后混淆产生的根源。 几个月后，Microsoft 随 IE 3 发布推出了一个与之基本兼容的语言 JScript。又过了几个月，Netscape 将 JavaScript 提交至 Ecma International（一个欧洲标准化组织）， ECMAScript 标准第一版便在 1997 年诞生了，随后在 1999 年以 ECMAScript 第三版的形式进行了更新，从那之后这个标准没有发生过大的改动。由于委员会在语言特性的讨论上发生分歧，ECMAScript 第四版尚未推出便被废除，但随后于 2009 年 12 月发布的 ECMAScript 第五版引入了第四版草案加入的许多特性。第六版标准已经于 2015 年 6 月发布。 与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在宿主环境（host environment）下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。浏览器是最常见的宿主环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Adobe Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，Node.js 之类的服务器端环境，NoSQL 数据库（如开源的 Apache CouchDB）、嵌入式计算机，以及包括 GNOME （注：GNULinux 上最流行的 GUI 之一）在内的桌面环境等等。 概览JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。JavaScript 通过原型链而不是类来支持面向对象编程（有关 ES6 类的内容参考这里Classes，有关对象原型参考见此继承与原型链）。JavaScript同样支持函数式编程——因为它们也是对象，函数也可以被保存在变量中，并且像其他对象一样被传递。 先从任何编程语言都不可缺少的组成部分——“类型”开始。JavaScript 程序可以修改值（value），这些值都有各自的类型。JavaScript 中的类型包括： Number（数字） String（字符串） Boolean（布尔） Function（函数） Object（对象） Symbol（ES2015 新增） 还有看上去有些…奇怪的 undefined（未定义）类型和 null（空）类型。此外还有Array（数组）类型，以及分别用于表示日期和正则表达式的 Date（日期）和 RegExp（正则表达式），这三种类型都是特殊的对象。严格意义上说，Function（函数）也是一种特殊的对象。所以准确来说，JavaScript 中的类型应该包括这些： Number（数字） String（字符串） Boolean（布尔） Symbol（符号）（ES2015 新增） Object（对象） Function（函数） Array（数组） Date（日期） RegExp（正则表达式） null（空） undefined（未定义） JavaScript 还有一种内置的 Error（错误）类型。但是，如果我们继续使用上面的分类，事情便容易得多；所以，现在，我们先讨论上面这些类型。 数字根据语言规范，JavaScript 采用“遵循 IEEE 754 标准的双精度 64 位格式”（”double-precision 64-bit format IEEE 754 values”）表示数字。——在JavaScript（除了BigInt）当中，并不存在整数整型(Integer)。 console.log(3 / 2); // 1.5,not 1console.log(Math.floor(3 / 2)); // 1// 你可以使用内置函数 parseInt() 将字符串转换为整型。parseInt(123, 10); // 123parseInt(010, 10); // 10// 一些老版本的浏览器会将首字符为“0”的字符串当做八进制数字，2013 年以前的 JavaScript 实现parseInt(010); // 8parseInt(0x10); // 16// 这是因为字符串以数字 0 开头，parseInt()函数会把这样的字符串视作八进制数字；// 同理，0x开头的字符串则视为十六进制数字。 JavaScript 还有两个特殊值：Infinity（正无穷）和 -Infinity（负无穷）：可以使用内置函数 isFinite() 来判断一个变量是否是一个有穷数， 如果类型为Infinity, -Infinity 或 NaN则返回false： 1 / 0; // Infinity-1 / 0; // -InfinityisFinite(1/0); // falseisFinite(Infinity); // falseisFinite(-Infinity); // falseisFinite(NaN); // falseisFinite(0); // trueisFinite(2e64); // trueisFinite(0); // true// 如果是纯数值类型的检测，则返回 false：Number.isFinite(0); // false 字符串JavaScript 中的字符串是一串Unicode 字符序列。这对于那些需要和多语种网页打交道的开发者来说是个好消息。更准确地说，它们是一串UTF-16编码单元的序列，每一个编码单元由一个 16 位二进制数表示。每一个Unicode字符由一个或两个编码单元来表示。 其他类型与其他类型不同，JavaScript 中的 null 表示一个空值（non-value），必须使用 null 关键字才能访问，undefined 是一个“undefined（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值。我们之后再具体讨论变量，但有一点可以先简单说明一下，JavaScript 允许声明变量但不对其赋值，一个未被赋值的变量就是 undefined 类型。还有一点需要说明的是，undefined 实际上是一个不允许修改的常量。 JavaScript 包含布尔类型，这个类型的变量有两个可能的值，分别是 true 和 false（两者都是关键字）。根据具体需要，JavaScript 按照如下规则将变量转换成布尔类型： false、0、空字符串（””）、NaN、null 和 undefined 被转换为 false 所有其他值被转换为 true 变量在 JavaScript 中声明一个新变量的方法是使用关键字 let 、const 和 var： let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。const 允许声明一个不可变的常量。这个常量在定义域内总是可见的。var 是最常见的声明变量的关键字。它没有其他两个关键字的种种限制。这是因为它是传统上在 JavaScript 声明变量的唯一方法。使用 var 声明的变量在它所声明的整个函数都是可见的。 剩下的对象，函数就不一一记录了，其实跟上面的没多大区别，只是强化一下记忆。有语言基础的人应该会很好理解这些内容。 最后JavaScript还有很多的内容， 继承和原型链 是特别重要的内容，下一篇文章会详细聊一聊。 参考文档JavaScript","tags":["Web","基础知识","JavaScript"],"categories":["IT技术"]},{"title":"macbook-键盘连击问题","path":"/memoirs/20200911/other/macbook-键盘连击问题/","content":"最近一段时间，我的笔记本（17年款 macbook pro 13寸）经常出现键盘连击问题。 最大的表现是 eni 这几个按键，按下的时候，会有概率的出现两个或三个。 这不是个案搜索了一下，有不少人都反馈了相同的问题，比如 2018 款 MacBook Pro 键盘连击问题。。。MacBook Pro 键盘又连击了~😤🤪 而且苹果官方确实也承认了，这一代的键盘确实存在设计问题。 临时解决方案根据大家的经验，找到了一款软件 Unshaky ，号称可以通过软件识别连击问题。 论坛中也有人说通过这个软件解决了。 Unshaky tries to address an issue on the butterfly keyboard (Macbook, Macbook Air 2018 MacBook Pro 2016 and later): Double Key Press (See “User complaints“ below). Apple made it difficult to replace only the keyboard and it costs hundreds of dollars. Unshaky might save your keyboard by dismissing such “second key hits” (any key presses that occur no later than x milliseconds after the previous effective one). I fixed my “w” key with Unshaky, and if it does not work for you, open an issue here. The image below illustrates how Unshaky works. [May 2019] Apple extends the service program to cover all MacBook (Air Pro) with 3rd gen butterfly keyboards. 我也暂时用这个方案解决了三个按键连击的问题。 终极解决方案之所以存在连击问题，大概率是因为这一代的键盘中进灰了，影响了按压时候的判断。 苹果官方给出的解决方案，简单的说就是用压缩空气喷键盘。 这么好的东西，哪里买呢压缩空气罐淘宝上很多，20多块钱，不用买很多，一罐就够用了。除了解决键盘，还可以清理相机之类的设备。 记得不要买成别的气罐了（比如带WD-40，那是用于润滑去锈的，不要买），要纯净空气那种。 为什么不用吸尘器或者电吹风呢理论上来说，吸尘器和电吹风效果是类似的，但是不能保证你身边的空气足够干净，万一把新的灰尘吹进去了岂不是… 使用方法如果您的 MacBook（2015 年及更新机型）或 MacBook Pro（2016 年及更新机型）上的某个按键无反应，或某个按键按下时的触感与其他按键不同，请按照以下步骤用压缩空气来清洁键盘。 当您按照这些步骤进行操作时，应务必使用压缩空气自带的喷管来控制气流，在喷气时保持喷管末端距离键盘半英寸远。还要注意，喷气时不要颠倒瓶体。 以 75 度角握持 Mac 笔记本电脑，这样电脑不会完全垂直。 按从左到右的方式将压缩空气喷向键盘，或仅喷向受影响的按键。 将 Mac 笔记本电脑向右侧旋转，然后再次按从左到右的方式喷向键盘。 这一次将 Mac 笔记本电脑向左侧旋转，然后重复以上操作。 具体方法还是就要查看苹果的官方帮助文档。 更新后续的使用情况总的来说还是Unshaky还是很好用的，可以解决大部分的键盘连击问题，但是有时候键盘会有3次或者以上的连击，Unshaky没法很完美的解决这个问题。","categories":["工作日常"]},{"title":"Python-Flask基础篇(二)","path":"/memoirs/20200321/python/Python-100-Flask-2/","content":"前言前面介绍了Flask和HTTP的基础知识，下面会介绍Flask的基础用法 第4章 表单在Web程序中，表单是和用户交互最常见的方式之一。用户注册、登录、撰写文章、编辑设置，无一不用到表单。不过，表单的处理却并不简单。你不仅要创建表单，验证用户输入的内容，向用户显示错误提示，还要获取并保存数据。幸运的是，强大的WTForms可以帮我们解决这些问题。WTForms是一个使用Python编写的表单库，它使得表单的定 义、验证（服务器端）和处理变得非常轻松。这一章我们会介绍在Web 程序中处理表单的方法和技巧。 使用Flask-WTF处理表单扩展Flask-WTF集成了WTForms，使用它可以在Flask中更方便地使用WTForms。Flask-WTF将表单数据解析、CSRF保护、文件上传等功能与Flask集成，另外还附加了reCAPTCHA支持。 Flask-WTF默认为每个表单启用CSRF保护，它会为我们自动生成和 验证CSRF令牌。默认情况下，Flask-WTF使用程序密钥来对CSRF令牌 进行签名，所以我们需要为程序设置密钥： app.secret_key = secret string 定义WTForms表单类当使用WTForms创建表单时，表单由Python类表示，这个类继承从 WTForms导入的Form基类。一个表单由若干个输入字段组成，这些字 段分别用表单类的类属性来表示（字段即Field，你可以简单理解为表单 内的输入框、按钮等部件）。下面定义了一个LoginForm类，最终会生 成我们在前面定义的HTML表单： from wtforms import Form, StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms.validators import DataRequired, Length# 4.2.1 basic form exampleclass LoginForm(FlaskForm): username = StringField(Username, validators=[DataRequired()]) password = PasswordField(Password, validators=[DataRequired(), Length(8, 128)]) remember = BooleanField(Remember me) submit = SubmitField(Log in) 每个字段属性通过实例化WTForms提供的字段类表示。字段属性的名称将作为对应HTMLinput元素的name属性及id属性值。 当使用Flask-WTF定义表单时，我们仍然使用WTForms提供的字段类和验证器，创建的方式也完全相同，只不过表单类要继承Flask-WTF提供的FlaskForm类。FlaskForm类继承自Form类，进行了一些设置，并附加了一些辅助方法，以便与Flask集成。 输出HTML代码以我们使用WTForms创建的LoginForm为例，实例化表单类，然后将实例属性转换成字符串或直接调用就可以获取表单字段对应的HTML代码： form = LoginForm() form.username()uinput id=username name=username type=text value= form.submit()uinput id=submit name=submit type=submit value=Submit 在创建HTML表单时，我们经常会需要使用HTMLinput元素的其 他属性来对字段进行设置。比如，添加class属性设置对应的CSS类为字段添加样式；添加placeholder属性设置占位文本。默认情况下，WTForms输出的字段HTML代码只会包含id和name属性，属性值均为表单类中对应的字段属性名称。如果要添加额外的属性，通常有两种方法。 使用render_kw属性 username = StringField(Username, render_kw=placeholder: Your Username) input type=text id=username name=username placeholder=Your Username 在调用字段时传入 form.username(style=width: 200px;, class_=bar)ui nput class=bar id=username name=username style=width: 200px; type=text 在模板中渲染表单为了能够在模板中渲染表单，我们需要把表单类实例传入模板。首 先在视图函数里实例化表单类LoginForm，然后在render_template()函 数中使用关键字参数form将表单实例传入模板。 from flask import Flask, render_template, redirect, url_for, flashfrom forms import LoginForm@app.route(/basic)def basic(): form = LoginForm() return render_template(login.html, form=form) form method=post form.csrf_token !-- 渲染CSRF令牌隐藏字段 -- form.username.label form.username br form.password.label form.password br form.remember form.remember.label br form.submit br/form 需要注意的是，在上面的代码中，除了渲染各个字段的标签和字段本身，我们还调用了form.csrf_token属性渲染Flask-WTF为表单类自动创建的CSRF令牌字段。form.csrf_token字段包含了自动生成的CSRF令牌值，在提交表单后会自动被验证，为了确保表单通过验证，我们必须在表单中手动渲染这个字段。 处理表单数据表单数据的处理涉及很多内容，除去表单提交不说，从获取数据到保存数据大致会经历以下步骤： 解析请求，获取表单数据。 对数据进行必要的转换，比如将勾选框的值转换成Python的布尔值。 验证数据是否符合要求，同时验证CSRF令牌。 如果验证未通过则需要生成错误消息，并在模板中显示错误消息。 如果通过验证，就把数据保存到数据库或做进一步处理。 除非是简单的程序，否则手动处理不太现实，使用Flask-WTF和 WTForms可以极大地简化这些步骤。 提交表单在HTML中，当form标签声明的表单中类型为submit的提交字段被单击时，就会创建一个提交表单的HTTP请求，请求中包含表单各个字段的数据。表单的提交行为主要由三个属性控制，如下图所示。 form标签的action属性用来指定表单被提交的目标URL，默认为当前URL，也就是渲染该模板的路由所在的URL。如果你要把表单数据发送到其他URL，可以自定义这个属性值。 验证表单数据表单数据的验证是Web表单中最重要的主题之一，这一节我们会学习如何使用Flask-WTF验证并获取表单数据。 客户端验证和服务器端验证表单的验证通常分为以下两种形式： 客户端验证 客户端验证（client side validation）是指在客户端（比如Web浏览器）对用户的输入值进行验证。比如，使用HTML5内置的验证属性即可实现基本的客户端验证（type、required、min、max、accept等）。比如，下面的username字段添加了required标志： input type=text name=username required 服务器端验证 服务器端验证（server side validation）是指用户把输入的数据提交到服务器端，在服务器端对数据进行验证。如果验证出错，就在返回的响应中加入错误信息。用户修改后再次提交表单，直到通过验证。我们在Flask程序中使用WTForms实现的就是服务器端验证。 WTForms验证机制WTForms验证表单字段的方式是在实例化表单类时传入表单数据，然后对表单实例调用validate()方法。这会逐个对字段调用字段实例化时定义的验证器，返回表示验证结果的布尔值。如果验证失败，就把错误消息存储到表单实例的errors属性对应的字典中，验证的过程如下所示： from wtforms import Form, StringField, PasswordField, BooleanField from wtforms.validators import DataRequired, Length class LoginForm(Form):... username = StringField(Username, validators=[DataRequired()])... password = PasswordField(Password, validators=[DataRequired() , Length(8, 128)]) form = LoginForm(username=, password=123) form.data# 表单数据字典username: , password: 123 form.validate()False form.errors# 错误消息字典username: [uThis field is required.], password: [uField must be at least 6 characters long.] form2 = LoginForm(username=greyli, password=123456) form2.datausername: greyli, password: 123456 form2.validate()True form2.errors 在视图函数中验证表单因为现在的basic_form视图同时接收两种类型的请求：GET请求和POST请求。所以我们要根据请求方法的不同执行不同的代码。具体来说：首先是实例化表单，如果是GET请求，那么就渲染模板；如果是 POST请求，就调用validate()方法验证表单数据。 @app.route(/basic, methods=[GET, POST])def basic(): form = LoginForm() if form.validate_on_submit(): username = form.username.data flash(Welcome home, %s! % username) return redirect(url_for(index)) return render_template(login.html, form=form) 在模板中渲染错误消息如果form.validate_on_submit()返回False，那么说明验证没有通 过。对于验证未通过的字段，WTForms会把错误消息添加到表单类的 errors属性中，这是一个匹配作为表单字段的类属性到对应的错误消息 列表的字典。我们一般会直接通过字段名来获取对应字段的错误消息列表，即form.字段名.errors。比如，form.name.errors返回name字段的错 误消息列表。 form method=post form.csrf_token form.username.label br form.username() br % for message in form.username.errors % small class=error message /smallbr % endfor % form.password.label br form.password br % for message in form.password.errors % small class=error message /smallbr % endfor % form.remember form.remember.label br form.submit br/form 第5章 数据库(重点)数据库是大多数动态Web程序的基础设施，只要你想把数据存储下来，就离不开数据库。我们这里提及的数据库（Database）指的是由存储数据的单个或多个文件组成的集合，它是一种容器，可以类比为文件柜。而人们通常使用数据库来表示操作数据库的软件，这类管理数据库的软件被称为数据库管理系统（DBMS，Database Management System），常见的DBMS有MySQL、PostgreSQL、SQLite、MongoDB等。为了便于理解，我们可以把数据库看作一个大仓库，仓库里有一些负责搬运货物（数据）的机器人，而DBMS就是操控机器人搬运货物的程序。 数据库的分类数据库一般分为两种，SQL（Structured Query Language，结构化查 询语言）数据库和NoSQL（Not Only SQL，泛指非关系型）数据库。 SQLSQL数据库指关系型数据库，常用的SQL DBMS主要包括SQL Server、Oracle、MySQL、PostgreSQL、SQLite等。关系型数据库使用表来定义数据对象，不同的表之间使用关系连接。 在SQL数据库中，每一行代表一条记录（record），每条记录又由不同的列（column）组成。在存储数据前，需要预先定义表模式（schema），以定义表的结构并限定列的输入数据类型。为了避免在措辞上引起误解，我们先了解几个基本概念： 表（table）：存储数据的特定结构。 模式（schema）：定义表的结构信息。 列字段（columnfield）：表中的列，存储一系列特定的数据，列组成表。 行记录（rowrecord）：表中的行，代表一条记录。 标量（scalar）：指的是单一数据，与之相对的是集合 （collection）。 NoSQLNoSQL最初指No SQL或No Relational，现在NoSQL社区一般会解释为Not Only SQL。NoSQL数据库泛指不使用传统关系型数据库中的表格形式的数据库。近年来，NoSQL数据库越来越流行，被大量应用在实时（real-time）Web程序和大型程序中。与传统的SQL数据库相比，它在速度和可扩展性方面有很大的优势，除此之外还拥有无模式（schema- free）、分布式、水平伸缩（horizontally scalable）等特点。 最常用的两种NoSQL数据库如下所示： 文档存储（document store）文档存储是NoSQL数据库中最流行的种类，它可以作为主数据库使用。文档存储使用的文档类似SQL数据库中的记录，文档使用类JSON格式来表示数据。常见的文档存储DBMS有MongoDB、CouchDB等。 键值对存储（key-value store）键值对存储在形态上类似Python中的字典，通过键来存取数据，在读取上非常快，通常用来存储临时内容，作为缓存使用。常见的键值对 DBMS有Redis、Riak等，其中Redis不仅可以管理键值对数据库，还可以作为缓存后端（cache backend）和消息代理（message broker）。另外，还有列存储（column store，又被称为宽列式存储）、图存储（graph store）等类型的NoSQL数据库，这里不再展开介绍。 ORM魔法在Web应用里使用原生SQL语句操作数据库主要存在下面两类问题： 手动编写SQL语句比较乏味，而且视图函数中加入太多SQL语句会降低代码的易读性。另外还会容易出现安全问题，比如SQL注入。 常见的开发模式是在开发时使用简单的SQLite，而在部署时切换 到MySQL等更健壮的DBMS。但是对于不同的DBMS，我们需要使用不同的Python接口库，这让DBMS的切换变得不太容易。 尽管使用ORM可以避免SQL注入问题，但你仍然需要对传入的查询参数进行验证。另外，在执行原生SQL语句时也要注意避免使用字符串 拼接或字符串格式化的方式传入参数。使用ORM可以很大程度上解决这些问题。它会自动帮你处理查询 参数的转义，尽可能地避免SQL注入的发生。另外，它为不同的DBMS提供统一的接口，让切换工作变得非常简单。ORM扮演翻译的角色，能够将我们的Python语言转换为DBMS能够读懂的SQL指令，让我们能 够使用Python来操控数据库。 尽管ORM非常方便，但如果你对SQL相当熟悉，那么自己编写SQL代码可以获得更大的灵活性和性能优势。就像是使用IDE一样，ORM对初学者来说非常方便，但进阶以后你也许会想要自己掌控一切。ORM把底层的SQL数据实体转化成高层的Python对象，这样一来， 你甚至不需要了解SQL，只需要通过Python代码即可完成数据库操作，ORM主要实现了三层映射关系： 表→Python类。 字段（列）→类属性。 记录（行）→类实例。 比如，我们要创建一个contacts表来存储留言，其中包含用户名称和电话号码两个字段。在SQL中，下面的代码用来创建这个表，要向表中插入一条记录，需要使用下面的SQL语句： CREATE TABLE contacts( name varchar(100) NOT NULL, phone_number varchar(32),);-- 插入一条记录INSERT INTO contacts(name, phone_number) VALUES(Grey Li, 12345678); 如果使用ORM，我们可以使用类似下面的Python类来定义这个表：使用ORM则只需要创建一个Contact类的实例，传入对应的参数表示各个列的数据即可。下面的代码和使用上面的SQL语句效果相同： from foo_orm import Model, Column, Stringclass Contact(Model): __tablename__ = contacts name = Column(String(100), nullable=False) phone_number = Column(String(32))# 插入一条记录contact = Contact(name=Grey Li, phone_number=12345678) 除了便于使用，ORM还有下面这些优点： 灵活性好。你既能使用高层对象来操作数据库，又支持执行原生 SQL语句。 提升效率。从高层对象转换成原生SQL会牺牲一些性能，但这微不足道的性能牺牲换取的是巨大的效率提升。 可移植性好。ORM通常支持多种DBMS，包括MySQL、PostgreSQL、Oracle、SQLite等。你可以随意更换DBMS，只需要稍微 改动少量配置。 使用Python实现的ORM有SQLAlchemy、Peewee、PonyORM等。其中SQLAlchemy是Python社区使用最广泛的ORM之一，我们将介绍如何在Flask程序中使用它。SQL-Alchemy，直译过来就是SQL炼金术，下一节我们会见识到SQLAlchemy的神奇力量。 使用Flask-SQLAlchemy管理数据库扩展Flask-SQLAlchemy集成了SQLAlchemy，它简化了连接数据库服务器、管理数据库操作会话等各类工作，让Flask中的数据处理体验变得更加轻松。下面在示例程序中实例化Flask-SQLAlchemy提供的SQLAlchemy类，传入程序实例app，以完成扩展的初始化。 import osfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)app.jinja_env.trim_blocks = Trueapp.jinja_env.lstrip_blocks = Trueapp.config[SECRET_KEY] = os.getenv(SECRET_KEY, secret string)app.config[SQLALCHEMY_DATABASE_URI] = os.getenv( DATABASE_URL, sqlite:/// + os.path.join(app.root_path, data.db))app.config[SQLALCHEMY_TRACK_MODIFICATIONS] = Falsedb = SQLAlchemy(app=app) 连接数据库服务器DBMS通常会提供数据库服务器运行在操作系统中。要连接数据库服务器，首先要为我们的程序指定数据库URI（Uniform ResourceIdentifier，统一资源标识符）。数据库URI是一串包含各种属性的字符串，其中包含了各种用于连接数据库的信息。 在Flask-SQLAlchemy中，数据库的URI通过配置变量SQLALCHEMY_DATABASE_URI设置，默认为SQLite内存型数据库(sqlite:///:memory:)。SQLite是基于文件的DBMS，不需要设置数据库服务器，只需要指定数据库文件的绝对路径。 在生产环境下更换到其他类型的DBMS时，数据库URL会包含敏感 信息，所以这里优先从环境变量DATABASE_URL获取(注意这里为了便于理解使用了URL，而不是URI)。 安装并初始化Flask-SQLAlchemy后，启动程序时会看到命令行下有一行警告信息。这是因为Flask-SQLAlchemy建议你设置 SQLALCHEMY_TRACK_MODIFICATIONS配置变量，这个配置变量决定是否追踪对象的修改，这用于Flask-SQLAlchemy的事件通知系统。这 个配置键的默认值为None，如果没有特殊需要，我们可以把它设为False来关闭警告信息。 app.config[SQLALCHEMY_TRACK_MODIFICATIONS] = False 定义数据库模型用来映射到数据库表的Python类通常被称为数据库模型(model)，一个数据库模型类对应数据库中的一个表。定义模型即使用Python类定义表模式，并声明映射关系。所有的模型类都需要继承Flask-SQLAlchemy提供的db.Model基类。本章的示例程序是一个笔记程序，笔记保存到数据库中，你可以通过程序查询、添加、更新和删除笔记。 class Note(db.Model): 创建一个数据库Model id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) 在上面的模型类中，表的字段（列）由db.Column类的实例表示，字段的类型通过Column类构造方法的第一个参数传入。在这个模型中，我们创建了一个类型为db.Integer的id字段和类型为db.Text的body列，分别存储整型和文本。 字段类型一般直接声明即可，如果需要传入参数，你也可以添加括号。对于类似String的字符串列，有些数据库会要求限定长度，因此最 好为其指定长度。虽然使用Text类型可以存储相对灵活的变长文本，但从性能上考虑，我们仅在必须的情况下使用Text类型，比如用户发表的文章和评论等不限长度的内容。 一般情况下，字段的长度是由程序设计者自定的。尽管如此，也有一些既定的约束标准，比如姓名（英语）的长度一般不超过70个字符，中文名一般不超过20个字符，电子邮件地址的长度不超过254个字符，虽然各主流浏览器支持长达2048个字符的URL，但在网站中用户资料设置的限度一般为255。尽管如此，对于超过一定长度的Email和URL，比如20个字符，会在显示时添加省略号的形式。显示的用户名（username）允许重复，通常要短一些，以不超过36个字符为佳。当然，在程序中，你可以根据需要来自由设定这些限制值。 创建数据库和表如果把数据库（文件）看作一个仓库，为了方便取用，我们需要把货物按照类型分别放置在不同货架上，这些货架就是数据库中的表。创建模型类后，我们需要手动创建数据库和对应的表，也就是我们常说的建库和建表。这通过对我们的db对象调用create_all()方法实现。 数据库操作现在我们创建了模型，也生成了数据库和表，是时候来学习常用的数据库操作了。数据库操作主要是CRUD，即Create（创建）、Read（读取查询）、Update（更新）和Delete（删除）。SQLAlchemy使用数据库会话来管理数据库操作，这里的数据库会话也称为事务(transaction)。Flask-SQLAlchemy自动帮我们创建会话，可以通过db.session属性获取。数据库中的会话代表一个临时存储区，你对数据库做出的改动都会存放在这里。你可以调用add()方法将新创建的对象添加到数据库会话中，或是对会话中的对象进行更新。只有当你对数据库会话对象调用commit()方法时，改动才被提交到数据库，这确保了数据提交的一致性。另外，数据库会话也支持回滚操作。当你对会话调用rollback()方法时，添加到会话中且未提交的改动都将被撤销。 CRUD这一节我们会在Python Shell中演示CRUD操作。默认情况下，Flask-SQLAlchemy(2.3.0版本)会自动为模型类生成一个__repr__()方法。当在Python Shell中调用模型的对象时，__repr__()方法会返回一条类似“模型类名主键值”的字符串，比如Note。 Create添加一条新记录到数据库主要分为三步： 创建Python对象（实例化模型类）作为一条记录。 添加新创建的记录到数据库会话。 提交数据库会话。 Read我们已经知道了如何向数据库里添加记录，那么如何从数据库里取回数据呢？使用模型类提供的query属性附加调用各种过滤方法及查询方法可以完成这个任务。 模型类.query.过滤方法.查询方法 从某个模型类出发，通过在query属性对应的Query对象上附加的过滤方法和查询函数对模型类对应的表中的记录进行各种筛选和调整，最终返回包含对应数据库记录数据的模型类实例，对返回的实例调用属性即可获取对应的字段数据。 精确的查询，比如获取指定字段值的记录。对模型类的query属性存储的Query对象调用过滤方法将返回一个更精确的Query对象(后面我们简称为查询对象)。因为每个过滤方法都会返回新的查询对象，所以过滤器可以叠加使用。在查询对象上调用前面介绍的查询方法，即可获得一个包含过滤后的记录的列表。 Update更新一条记录非常简单，直接赋值给模型类的字段属性就可以改变 字段值，然后调用commit()方法提交会话即可。只有要插入新的记录或要将现有的记录添加到会话中时才需要使用 add()方法，单纯要更新现有的记录时只需要直接为属性赋新值，然 后提交会话。 Delete删除记录和添加记录很相似，不过要把add()方法换成delete() 方法，最后都需要调用commit()方法提交修改。 在视图函数里操作数据库在视图函数里操作数据库的方式和我们在Python Shell中的练习大致相同，只不过需要一些额外的工作。比如把查询结果作为参数传入模板渲染出来，或是获取表单的字段值作为提交到数据库的数据。在这一节，我们将把上一节学习的所有数据库操作知识运用到一个简单的笔记程序中。这个程序可以让你创建、编辑和删除笔记，并在主页列出所有保存后的笔记。 Create @app.route(/new, methods=[GET, POST])def new_note(): form = NewNoteForm() if form.validate_on_submit(): body = form.body.data note = Note(body=body) db.session.add(note) db.session.commit() flash(Your note is saved.) return redirect(url_for(index)) return render_template(new_note.html, form=form) Read @app.route(/note/all)@app.route(/)def index(): form = DeleteNoteForm() notes = Note.query.all() return render_template(index.html, notes=notes, form=form) Update @app.route(/edit/int:note_id, methods=[GET, POST])def edit_note(note_id): form = EditNoteForm() note = Note.query.get(note_id) if form.validate_on_submit(): note.body = form.body.data db.session.commit() flash(Your note is updated.) return redirect(url_for(index)) form.body.data = note.body # preset form inputs value return render_template(edit_note.html, form=form) Delete @app.route(/delete/int:note_id, methods=[POST])def delete_note(note_id): form = DeleteNoteForm() if form.validate_on_submit(): note = Note.query.get(note_id) db.session.delete(note) db.session.commit() flash(Your note is deleted.) else: abort(400) return redirect(url_for(index)) 定义关系在关系型数据库中，我们可以通过关系让不同表之间的字段建立联系。一般来说，定义关系需要两步，分别是创建外键和定义关系属性。在更复杂的多对多关系中，我们还需要定义关联表来管理关系。这一节我们会学习如何使用SQLAlchemy在模型之间建立几种基础的关系模 式。 配置Python Shell上下文在上面的许多操作中，每一次使用flask shell命令启动Python Shell后都要从app模块里导入db对象和相应的模型类。为什么不把它们自动 集成到Python Shell上下文里呢？就像Flask内置的app对象一样。这当然可以实现！我们可以使用app.shell_context_processor装饰器注册一个shell上下文处理函数。 # handlers@app.shell_context_processordef make_shell_context(): return dict(db=db, Note=Note) 一对多我们将以作者和文章来演示一对多关系：一个作者可以写作多篇文章。 Author类用来表示作者，Article类用来表示文章 class Author(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) articles = db.relationship(Article) # collectionclass Article(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) body = db.Column(db.Text) author_id = db.Column(db.Integer, db.ForeignKey(author.id)) 我们将在这两个模型之间建立一个简单的一对多关系，建立这个一对多关系的目的是在表示作者的Author类中添加一个关系属性articles，作为集合（collection）属性，当我们对特定的Author对象调用articles属性会返回所有相关的Article对象。我们会在下面介绍如何一步步定义这个一对多关系。 定义外键定义关系的第一步是创建外键。外键是（foreign key）用来在A表存储B表的主键值以便和B表建立联系的关系字段。因为外键只能存储单一数据（标量），所以外键总是在“多”这一侧定义，多篇文章属于同一个作者，所以我们需要为每篇文章添加外键存储作者的主键值以指向对应的作者。在Article模型中，我们定义一个author_id字段作为外键. 定义关系属性定义关系的第二步是使用关系函数定义关系属性。关系属性在关系 的出发侧定义，即一对多关系的“一”这一侧。一个作者拥有多篇文章， 在Author模型中，我们定义了一个articles属性来表示对应的多篇文章 建立关系建立关系有两种方式，第一种方式是为外键字段赋值，另一种方式是通过操作关系属性，将关系属性赋给实际的对象即可建立关系。 # 1.外键字段赋值spam.author_id = 1db.session.commit()# 2.关系属性赋给实际的对象foo.articles.append(spam)foo.articles.append(ham)db.session.commit() 建立双向关系我们在Author类中定义了集合关系属性articles，用来获取某个作者 拥有的多篇文章记录。在某些情况下，你也许希望能在Article类中定义 一个类似的author关系属性，当被调用时返回对应的作者记录，这类返 回单个值的关系属性被称为标量关系属性。而这种两侧都添加关系属性 获取对方记录的关系我们称之为双向关系（bidirectional relationship）。 双向关系并不是必须的，但在某些情况下会非常方便。双向关系的 建立很简单，通过在关系的另一侧也创建一个relationship()函数，我 们就可以在两个表之间建立双向关系。 # one to many + bidirectional relationshipclass Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) books = db.relationship(Book, back_populates=writer)class Book(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey(writer.id)) writer = db.relationship(Writer, back_populates=books) 使用backref简化关系定义在介绍关系函数的参数时，我们曾提到过，使用关系函数中的 backref参数可以简化双向关系的定义。以一对多关系为例，backref参数用来自动为关系另一侧添加关系属性，作为反向引用（back reference），赋予的值会作为关系另一侧的关系属性名称。比如，我们 在Author一侧的关系函数中将backref参数设为author，SQLAlchemy会自 动为Article类添加一个author属性。 # 尽管使用backref非常方便，但通常来说“显式好过隐式”，所以我们 应该尽量使用back_populates定义双向关系。# 为了便于理解，将使用back_populates来建立双向关系。# one to many + bidirectional relationship + use backref to declare bidirectional relationshipclass Singer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) songs = db.relationship(Song, backref=singer)class Song(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(50), index=True) singer_id = db.Column(db.Integer, db.ForeignKey(singer.id)) 在定义集合属性songs的关系函数中，我们将backref参数设为 singer，这会同时在Song类中添加了一个singer标量属性。这时我们仅需 要定义一个关系函数，虽然singer是一个“看不见的关系属性”，但在使用上和定义两个关系函数并使用back_populates参数的效果完全相同。需要注意的是，使用backref允许我们仅在关系一侧定义另一侧的关 系属性，但是在某些情况下，我们希望可以对在关系另一侧的关系属性进行设置，这时就需要使用backref()函数。backref()函数接收第一 个参数作为在关系另一侧添加的关系属性名，其他关键字参数会作为关 系另一侧关系函数的参数传入。比如，我们要在关系另一侧“看不见的 relationship()函数”中将uselist参数设为False。 多对一一对多关系反过来就是多对一关系，这两种关系模式分别从不同的视角出发。一个作者拥有多篇文章，反过来就是多篇文章属于同一个作者。为了便于区分，我们使用居民和城市来演示多对一关系：多个居民居住在同一个城市。 # many to oneclass Citizen(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) city_id = db.Column(db.Integer, db.ForeignKey(city.id)) city = db.relationship(City)class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) 这时定义的city关系属性是一个标量属性（返回单一数据）。当Citizen.city被调用时，SQLAlchemy会根据外键字段city_id存储的值查找对应的City对象并返回，即居民记录对应的城市记录。当建立双向关系时，如果不使用backref，那么一对多和多对一关系模式在定义上完全相同，这时可以将一对多和多对一视为同一种关系模式。在后面我们通常都会为一对多或多对一建立双向关系，这时将弱化这两种关系的区别，一律称为一对多关系。 一对一我们将使用国家和首都来演示一对一关系：每个国家只有一个首 都；反过来说，一个城市也只能作为一个国家的首都。 Country类表示国家，Capital类表示首都。建立一对一关系后，我们将在Country类中创建一个标量关系属性capital，调用它会获取单个Capital对象；我们还将在Capital类中创建一个标量关系属性country，调用它会获取单个的Country对象。 一对一关系实际上是通过建立双向关系的一对多关系的基础上转化而来。我们要确保关系两侧的关系属性都是标量属性，都只返回单个值，所以要在定义集合属性的关系函数中将uselist参数设为False，这时一对多关系将被转换为一对一关系。 # one to oneclass Country(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) capital = db.relationship(Capital, uselist=False) # collection - scalarclass Capital(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(30), unique=True) country_id = db.Column(db.Integer, db.ForeignKey(country.id)) country = db.relationship(Country) # scalar 多对多我们将使用学生和老师来演示多对多关系：每个学生有多个老师，而每个老师有多个学生。 Student类表示学生，Teacher类表示老师。在这两个模型之间建立多对多关系后，我们需要在Student类中添加一个集合关系属性teachers，调用它可以获取某个学生的多个老师，而不同的学生可以和同一个老师建立关系。 在一对多关系中，我们可以在“多”这一侧添加外键指向“一”这一 侧，外键只能存储一个记录，但是在多对多关系中，每一个记录都可以与关系另一侧的多个记录建立关系，关系两侧的模型都需要存储一组外键。在SQLAlchemy中，要想表示多对多关系，除了关系两侧的模型外，我们还需要创建一个关联表（association table）。关联表不存储数据，只用来存储关系两侧模型的外键对应关系。 class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship(Teacher, secondary=association_table, back_populates=students) # collectionclass Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) office = db.Column(db.String(20)) students = db.relationship(Student, secondary=association_table, back_populates=teachers) # collection 关联表使用db.Table类定义，传入的第一个参数是关联表的名称。我们在关联表中定义了两个外键字段：teacher_id字段存储Teacher类的主键，student_id存储Student类的主键。借助关联表这个中间人存储的外键对，我们可以把多对多关系分化成两个一对多关系，如图所示。 更新数据库表模型类（表）不是一成不变的，当你添加了新的模型类，或是在模 型类中添加了新的字段，甚至是修改了字段的名称或类型，都需要更新 表。在前面我们把数据库表类比成盛放货物的货架，这些货架是固定生 成的。当我们在操控程序（DBMSORM）上变更了货架的结构时，仓 库的货架也要根据变化相应进行调整。而且，当货架的结构产生变动 时，我们还需要考虑如何处理货架上的货物（数据）。 重新生成表重新调用create_all()方法并不会起到更新表或重新创建表的作 用。如果你并不在意表中的数据，最简单的方法是使用drop_all()方法删除表以及其中的数据，然后再使用create_all()方法重新创建 使用Flask-Migrate迁移数据库在开发时，以删除表再重建的方式更新数据库简单直接，但明显的缺陷是会丢掉数据库中的所有数据。在生产环境下，你绝对不会想让数 据库里的数据都被删除掉，这时你需要使用数据库迁移工具来完成这个工作。SQLAlchemy的开发者Michael Bayer写了一个数据库迁移工具 ——Alembic来帮助我们实现数据库的迁移，数据库迁移工具可以在不破坏数据的情况下更新数据库表的结构。蒸馏器（Alembic）是炼金术士最重要的工具，要学习SQL炼金术（SQLAlchemy），我们当然要掌 握蒸馏器的使用。 我们实例化Flask-Migrate提供的Migrate类，进行初始化操作实例化Migrate类时，除了传入程序实例app，还需要传入实例化 Flask-SQLAlchemy提供的SQLAlchemy类创建的db对象作为第二个参数。 from flask import Flask from flask_sqlalchemyimport SQLAlchemy from flask_migrateimport Migrateapp = Flask(__name__)...db = SQLAlchemy(app)migrate = Migrate(app, db)# 在db对象创建后调用 创建迁移环境在开始迁移数据之前，需要先使用下面的命令创建一个迁移环境迁移环境只需要创建一次。这会在你的项目根目录下创建一个migrations文件夹，其中包含了自动生成的配置文件和迁移版本文件夹。 flask db init 生成迁移脚本 使用migrate子命令可以自动生成迁移脚本： $ flask db migrate -m add note timestamp...INFO [alembic.autogenerate.compare] Detected added column message.timestamp Generating /Path/to/your/database/migrations/versions/c52a02014635_add note_timestamp.py...done 这条命令可以简单理解为在flask里对数据库（db）进行迁移 （migrate）。-m选项用来添加迁移备注信息。从上面的输出信息我们可以看到，Alembic检测出了模型的变化：表note新添加了一个timestamp列，并且相应生成了一个迁移脚本 c52a02014635_add_note_timestamp.py， 更新数据库 生成了迁移脚本后，使用upgrade子命令即可更新数据库 $ flask db upgrade...INFO [alembic.runtime.migration] Running upgrade - c52a02014635, add note timestamp 如果还没有创建数据库和表，这个命令会自动创建；如果已经创建，则会在不损坏数据的前提下执行更新。 开发时是否需要迁移在生产环境下，当对数据库结构进行修改后，进行数据库迁移是必要的。因为你不想损坏任何数据，毕竟数据是无价的。在生成自动迁移脚本后，执行更新之前，对迁移脚本进行检查，甚至是使用备份的数据库进行迁移测试，都是有必要的。 而在开发环境中，你可以按需要选择是否进行数据迁移。对于大多数程序来说，我们可以在开发时使用虚拟数据生成工具来生成虚拟数据，从而避免手动创建记录进行测试。这样每次更改表结构时，可以直接清除后重新生成，然后生成测试数据，这要比执行一次迁移简单很多（在后面我们甚至会学习通过一条命令完成所有工作），除非生成虚拟数据耗费的时间过长。 另外，在本地开发时通常使用SQLite作为数据库引擎。SQLite不支持ALTER语句，而这正是迁移工具依赖的工作机制。也就是说，当SQLite数据库表的字段删除或修改后，我们没法直接使用迁移工具进行更新，你需要手动添加迁移代码来进行迁移。在开发中，修改和删除列是很常见的行为，手动操作迁移会花费太多的时间。 总结本来还有一章讲邮件的，但是邮件这部分太简单就不放在这里了。基础篇（二）主要是讲数据库的知识，简单了解在Flask应用中使用数据库的方法，但数据库的内容还有很多，这里只是一个简单的介绍。如果你想了解更多具体细节，SQLAlchemy提供的入门教程是个起步的好地方。另外，如果还不熟悉SQL，那么有必要去学习一下，掌握SQL可以让你更高效地使用ORM。 这里也没有介绍在Flask中使用文档型NoSQL数据库的过程。以流行的MongoDB为例，通过使用ODM（Object Document Mapper，对象文档映射），比如MongoEngine，或是对应的扩展Flask- MongoEngine，其操作数据库的方式和使用本章要介绍的SQLAlchemy基本相同。","tags":["Flask","Python"],"categories":["IT技术"]},{"title":"Python-Flask基础篇(一)","path":"/memoirs/20200316/python/Python-100-Flask-1/","content":"第1章 初识FlaskFlask介绍搭建开发环境，编写一个最小的Flask程序并运行它，了解 Flask基本知识 这一切开始于2010年4月1日，Armin Ronacher在网上发布了一篇关 于“下一代Python微框架”的介绍文章，文章里称这个Denied框架不依赖 Python标准库，只需要复制一份deny.py放到你的项目文件夹就可以开始 编程。伴随着一本正经的介绍、名人推荐语、示例代码和演示视频，这 个“虚假”的项目让不少人都信以为真。 5天后， Flask就从这么一个愚人节玩笑诞生了。 Flask是使用Python编写的Web微框架。Web框架可以让我们不用关 心底层的请求响应处理，更方便高效地编写Web程序。因为Flask核心简 单且易于扩展，所以被称作微框架（micro framework）。Flask有两个主 要依赖，一个是WSGI（Web Server Gateway Interface，Web服务器网关 接口）工具集——Werkzeug，另一个是 Jinja2模板引擎。Flask只保留了Web开发的核 心功能，其他的功能都由外部扩展来实现，比如数据库集成、表单认 证、文件上传等。如果没有合适的扩展，你甚至可以自己动手开发。 Flask不会替你做决定，也不会限制你的选择。总之，Flask可以变成任 何你想要的东西，一切都由你做主。 Flask（瓶子，烧瓶）的命名据说是对另一个Python Web框架—— Bottle的双关语调侃，即另一种容器（另一个Python Web框架）。 Werkzeug是德语单词“工具（tool）”，而Jinja指日本神社，因为神社 （庙）的英文temple与template（模板）相近而得名。 WSGI（Web Server Gateway Interface）是Python中用来规定Web服 务器如何与Python Web程序进行沟通的标准，在本书的第三部分将进行 详细介绍。 Flask与MVC架构你也许会困惑为什么用来处理请求并生成响应的函数被称为“视图 函数（view function）”，其实这个命名并不合理。在Flask中，这个命名 的约定来自Werkzeug，而Werkzeug中URL匹配的实现主要参考了 Routes（一个URL匹配库），再往前追溯，Routes的实现又参考了Ruby on Rails。在Ruby on Rails中，术语views用来 表示MVC（Model-View-Controller，模型-视图-控制器）架构中的 View。 MVC架构最初是用来设计桌面程序的，后来也被用于Web程序，应 用了这种架构的Web框架有Django、Ruby on Rails等。在MVC架构中， 程序被分为三个组件：数据处理（Model）、用户界面（View）、交互 逻辑（Controller）。如果套用MVC架构的内容，那么Flask中视图函数 的名称其实并不严谨，使用控制器函数（Controller Function）似乎更合 适些，虽然它也附带处理用户界面。严格来说，Flask并不是MVC架构 的框架，因为它没有内置数据模型支持。为了方便表述，在本书中，使 用了app.route()装饰器的函数仍被称为视图函数，同时会使用“函数 名视图”（比如index视图）的形式来代指某个视图函数。 粗略归类，如果想要使用Flask来编写一个MVC架构的程序，那么 视图函数可以作为控制器（Controller），视图（View）则是我们将要介绍的使用Jinja2渲染的HTML模板，而模型（Model）可以使用其 他库来实现，在后面我们会介绍使用SQLAlchemy来创建数据库模型。 本章小结Flask 基础其实很简单，这次主要是复习之前的知识，基础就不过多介绍了。本章我们学习了Flask程序的运作方式和一些基本概念，这为我们进 一步学习打下了基础。下面，我们会了解隐藏在Flask背后的重要角色 ——HTTP，并学习Flask是如何与之进行交互的。 第2章 Flask与HTTPHTTP（Hypertext Transfer Protocol，超文本传输协议）定义了服务器和 客户端之间信息交流的格式和传递方式，它是万维网（World Wide Web）中数据交换的基础。 请求响应循环为了更贴近现实，我们以一个真实的URL为例： http://helloflask.com/hello 当我们在浏览器中的地址栏中输入这个URL，然后按下Enter时，稍等片刻，浏览器会显示一个问候页面。这背后到底发生了什么？你一定 可以猜想到，这背后也有一个web程序运行着。它负责接收用户的请求，并把对应的内容返回给客户端，显示在用户的浏览 器上。事实上，每一个Web应用都包含这种处理模式，即“请求-响应循 环（Request-Response Cycle）”：客户端发出请求，服务器端处理请求 并返回响应，如图所示。 这是每一个Web程序的基本工作模式，如果再进一步，这个模式又 包含着更多的工作单元，下图展示了一个Flask程序工作的实际流程。从下图中可以看出，HTTP在整个流程中起到了至关重要的作用， 它是客户端和服务器端之间沟通的桥梁。 当用户访问一个URL，浏览器便生成对应的HTTP请求，经由互联 网发送到对应的Web服务器。Web服务器接收请求，通过WSGI将HTTP 格式的请求数据转换成我们的Flask程序能够使用的Python数据。在程序中，Flask根据请求的URL执行对应的视图函数，获取返回值生成响应。响应依次经过WSGI转换生成HTTP响应，再经由Web服务器传递，最终 被发出请求的客户端接收。浏览器渲染响应中包含的HTML和CSS代 码，并执行JavaScript代码，最终把解析后的页面呈现在用户浏览器的窗口中。 HTTP请求URL是一个请求的起源。不论服务器是运行在美国洛杉矶，还是运 行在我们自己的电脑上，当我们输入指向服务器所在地址的URL，都会 向服务器发送一个HTTP请求。一个标准的URL由很多部分组成，以下面这个URL为例： http://helloflask.com/hello?name=Grey 当我们在浏览器中访问这个URL时，随之产生的是一个发向http://helloflask.com所在服务器的请求。请求的实质是发送到服务器 上的一些数据，这种浏览器与服务器之间交互的数据被称为报文(message)，请求时浏览器发送的数据被称为请求报文(request message)，而服务器返回的数据被称为响应报文(response message)。 请求报文请求报文由请求的方法、URL、协议版本、首部字段（header）以及内容实体组成。报文由报文首部和报文主体组成，两者由空行分隔，请求报文的主 体一般为空。如果URL中包含查询字符串，或是提交了表单，那么报文 主体将会是查询字符串和表单数据。报文首部包含了请求的各种信息和设置，比如客户端的类型、是否 设置缓存、语言偏好等。 Request对象现在该让Flask的请求对象request出场了，这个请求对象封装了从客 户端发来的请求报文，我们能从它获取请求报文中的所有数据。 请求解析和响应封装实际上大部分是由Werkzeug完成的，Flask子 类化Werkzeug的请求（Request）和响应（Response）对象并添加了和程 序相关的特定功能。 当Flask接收到请求后，请求对 象会提供多个属性来获取URL的各个部分，常用的属性如下表所示。 除了URL，请求报文中的其他信息都可以通过request对象提供的属性和方法获取。 在Flask中处理请求URL是指向网络上资源的地址。在Flask中，我们需要让请求的URL 匹配对应的视图函数，视图函数返回值就是URL对应的资源。 路由匹配为了便于将请求分发到对应的视图函数，程序实例中存储了一个路由表（app.url_map），其中定义了URL规则和视图函数的映射关系。当请求发来后，Flask会根据请求报文中的URL（path部分）来尝试与这个 表中的所有URL规则进行匹配，调用匹配成功的视图函数。如果没有找到匹配的URL规则，说明程序中没有处理这个URL的视图函数，Flask会 自动返回404错误响应（Not Found，表示资源未找到）。你可以尝试在 浏览器中访问http://localhost:5000/nothing ，因为我们的程序中没有视图 函数负责处理这个URL，所以你会得到404响应。 设置监听的HTTP方法通过flask routes命令打印出的路由列表可以看到，每一个 路由除了包含URL规则外，还设置了监听的HTTP方法。GET是最常用 的HTTP方法，所以视图函数默认监听的方法类型就是GET，HEAD、 OPTIONS方法的请求由Flask处理，而像DELETE、PUT等方法一般不会在程序中实现，在后面我们构建Web API时才会用到这些方法。 我们可以在app.route()装饰器中使用methods参数传入一个包含监 听的HTTP方法的可迭代对象。比如，下面的视图函数同时监听GET请 求和POST请求： @app.route(/hello, methods=[GET, POST])def hello(): return h1Hello, Flask!/h1 当某个请求的方法不符合要求时，请求将无法被正常处理。比如， 在提交表单时通常使用POST方法，而如果提交的目标URL对应的视图 函数只允许GET方法，这时Flask会自动返回一个405错误响应（Method Not Allowed，表示请求方法不允许）。3. URL处理从前面的路由列表中可以看到，除了hello，这个程序还包含许多 URL规则，比如和go_back端点对应的gobackint：year。现在请尝试 访问http://localhost:5000/goback/34 ，在URL中加入一个数字作为时光倒 流的年数，你会发现加载后的页面中有通过传入的年数计算出的年 份：“Welcome to 1984！”。仔细观察一下，你会发现URL规则中的变量 部分有一些特别，int：year表示为year变量添加了一个int转换器， Flask在解析这个URL变量时会将其转换为整型。 @app.route(goback/int:year)def go_back(year): return pWelcome to %d!/p % (2018 - year) 请求钩子有时我们需要对请求进行预处理（preprocessing）和后处理 （postprocessing），这时可以使用Flask提供的一些请求钩子 （Hook），它们可以用来注册在请求处理的不同阶段执行的处理函数 （或称为回调函数，即Callback）。这些请求钩子使用装饰器实现，通 过程序实例app调用，用法很简单：以before_request钩子（请求之前） 为例，当你对一个函数附加了app.before_request装饰器后，就会将这个 函数注册为before_request处理函数，每次执行请求前都会触发所有 before_request处理函数。 这些钩子使用起来和app.route()装饰器基本相同，每个钩子可以 注册任意多个处理函数，函数名并不是必须和钩子名称相同，下面是一 个基本示例： 假如我们创建了三个视图函数A、B、C，其中视图C使用了 after_this_request钩子，那么当请求A进入后，整个请求处理周期的请求 处理函数调用流程如图2-7所示。 下面是请求钩子的一些常见应用场景： before_first_request：在玩具程序中，运行程序前我们需要进行一 些程序的初始化操作，比如创建数据库表，添加管理员用户。这些工作 可以放到使用before_first_request装饰器注册的函数中。 before_request：比如网站上要记录用户最后在线的时间，可以通 过用户最后发送的请求时间来实现。为了避免在每个视图函数都添加更 新在线时间的代码，我们可以仅在使用before_request钩子注册的函数中 调用这段代码。 after_request：我们经常在视图函数中进行数据库操作，比如更 新、插入等，之后需要将更改提交到数据库中。提交更改的代码就可以 放到after_request钩子注册的函数中。 另一种常见的应用是建立数据库连接，通常会有多个视图函数需要 建立和关闭数据库连接，这些操作基本相同。一个理想的解决方法是在 请求之前（before_request）建立连接，在请求之后（teardown_request） 关闭连接。通过在使用相应的请求钩子注册的函数中添加代码就可以实 现。这很像单元测试中的setUp()方法和tearDown()方法。 HTTP响应在Flask程序中，客户端发出的请求触发相应的视图函数，获取返回 值会作为响应的主体，最后生成完整的响应，即响应报文。 响应报文响应报文主要由协议版本、状态码（status code）、原因短语 （reason phrase）、响应首部和响应主体组成。以发向localhost:5000hello的请求为例，服务器生成的响应报文示意如下表所示。 响应报文的首部包含一些关于响应和服务器的信息，这些内容由 Flask生成，而我们在视图函数中返回的内容即为响应报文中的主体内容。浏览器接收到响应后，会把返回的响应主体解析并显示在浏览器窗口上。HTTP状态码用来表示请求处理的结果，表2-9是常见的几种状态码 和相应的原因短语。 在Flask中生成响应响应在Flask中使用Response对象表示，响应报文中的大部分内容由 服务器处理，大多数情况下，我们只负责返回主体内容。根据我们在上一节介绍的内容，Flask会先判断是否可以找到与请求 URL相匹配的路由，如果没有则返回404响应。如果找到，则调用对应 的视图函数，视图函数的返回值构成了响应报文的主体内容，正确返回 时状态码默认为200。Flask会调用make_response()方法将视图函数返 回值转换为响应对象。完整地说，视图函数可以返回最多由三个元素组成的元组：响应主 体、状态码、首部字段。其中首部字段可以为字典，或是两元素元组组成的列表。 比如，普通的响应可以只包含主体内容： @app.route(/hello)def hello(): ... return h1Hello, Flask!/h1 默认的状态码为200，下面指定了不同的状态码： @app.route(/hello)def hello(): ... return h1Hello, Flask!/h1, 201 有时你会想附加或修改某个首部字段。比如，要生成状态码为3XX 的重定向响应，需要将首部中的Location字段设置为重定向的目标 URL： @app.route(/hello)def hello(): return , 302, Location, http://www.example.com 现在访问http://localhost:5000/hello ，会重定向 到http://www.example.com 。在多数情况下，除了响应主体，其他部分我们通常只需要使用默认值即可。 重定向在Web程序中，我们经常需要进行重定向。比如，当某个用户在没 有经过认证的情况下访问需要登录后才能访问的资源，程序通常会重定向到登录页面。对于重定向这一类特殊响应，Flask提供了一些辅助函数。除了像前面那样手动生成302响应，我们可以使用Flask提供的redirect（）函数来生成重定向响应，重定向的目标URL作为第一个参数。前面的例子可以简化为： from flask import Flask, redirect@app.route(/hello)def hello(): return redirect(http://www.example.com) 使用redirect()函数时，默认的状态码为302，即临时重定向。如果你想修改状态码，可以在redirect()函数中作为第二个参数或使用code关键字传入。 如果要在程序内重定向到其他视图，那么只需在redirect()函数中使用url_for()函数生成目标URL即可 from flask import Flask, redirect, url_for...@app.route(/hi)def hi(): ... return redierct(url_for(hello))# 重定向到/hello 错误响应大多数情况下，Flask会自动处理常见的错误响应。HTTP错误对应的异常类在Werkzeug的werkzeug.exceptions模块中定义，抛出这些异常即可返回对应的错误响应。如果你想手动返回错误响应，更方便的方法 是使用Flask提供的abort()函数。 在abort()函数中传入状态码即可返回对应的错误响应 from flask import Flask, abort...@app.route(/404)def not_found(): abort(404) 响应格式在HTTP响应中，数据可以通过多种格式传输。大多数情况下，我 们会使用HTML格式，这也是Flask中的默认设置。在特定的情况下，我 们也会使用其他格式。MIME类型（又称为media type或content type）是一种用来标识文件 类型的机制，它与文件扩展名相对应，可以让客户端区分不同的内容类型，并执行不同的操作。一般的格式为“类型名子类型名”，其中的子类 型名一般为文件扩展名。比如，HTML的MIME类型为“texthtml”，png图片的MIME类型为“imagepng”。完整的标准MIME类型列表可以在这 里看到：https://www.iana.org/assignments/media-types/media-types.xhtml。 如果你想使用其他MIME类型，可以通过Flask提供的 make_response（）方法生成响应对象，传入响应的主体作为参数，然后 使用响应对象的mimetype属性设置MIME类型 from flask import make_response@app.route(/foo)def foo(): response = make_response(Hello, World!) response.mimetype = text/plain return response 你也可以直接设置首部字段，比如response.headers[Content-Type]=text/xml；charset=utf-8。但操作mimetype属性更加方便，而且不用设置字符集（charset）选项。 常用的数据格式有纯文本、HTML、XML和JSON，下面我们分别 对这几种数据进行简单的介绍和分析。 纯文本 MIME类型：text/plain 事实上，其他几种格式本质上都是纯文本。比如同样是一行包含 HTML标签的文本h1Hello，Flask！/h1，当MIME类型设置为纯 文本时，浏览器会以文本形式显示h1Hello，Flask！/h1；当 MIME类型声明为texthtml时，浏览器则会将其作为标题1样式的HTML 代码渲染。 HTML MIME类型：text/html HTML指Hypertext Markup Language（超文本标记语言），是最常用的数据格式，也是Flask返回响 应的默认数据类型。从我们在本书一开始的最小程序中的视图函数返回 的字符串，到我们后面会学习的HTML模板，都是HTML。当数据类型 为HTML时，浏览器会自动根据HTML标签以及样式类定义渲染对应的 样式。 因为HTML常常包含丰富的信息，我们可以直接将HTML嵌入页面 中，处理起来比较方便。因此，在普通的HTTP请求中我们使用HTTP作 为响应的内容，这也是默认的数据类型。 XML MIME类型：application/xml XML指Extensible Markup Language（可扩展标记语言），它是一种简单灵活的文本格式，被设计 用来存储和交换数据。XML的出现主要就是为了弥补HTML的不足：对 于仅仅需要数据的请求来说，HTML提供的信息太过丰富了，而且不易 于重用。XML和HTML一样都是标记性语言，使用标签来定义文本，但 HTML中的标签用于显示内容，而XML中的标签只用于定义数据。 XML一般作为AJAX请求的响应格式，或是Web API的响应格式。 JSON MIME类型：application/json JSON指JavaScript Object Notation（JavaScript对 象表示法），是一种流行的、轻量的数据交换格式。它的出现又弥补了 XML的诸多不足：XML有较高的重用性，但XML相对于其他文档格式 来说体积稍大，处理和解析的速度较慢。JSON轻量，简洁，容易阅读 和解析，而且能和Web默认的客户端语言JavaScript更好地兼容。JSON 的结构基于“键值对的集合”和“有序的值列表”，这两种数据结构类似 Python中的字典（dictionary）和列表（list）。正是因为这种通用的数据 结构，使得JSON在同样基于这些结构的编程语言之间交换成为可能。 来一块CookieHTTP是无状态（stateless）协议。也就是说，在一次请求响应结束后，服务器不会留下任何关于对方状态的信息。但是对于某些Web程序来说，客户端的某些信息又必须被记住，比如用户的登录状态，这样才可以根据用户的状态来返回不同的响应。为了解决这类问题，就有了Cookie技术。Cookie技术通过在请求和响应报文中添加Cookie数据来保 存客户端的状态信息。 在Flask中，如果想要在响应中添加一个cookie，最方便的方法是使 用Response类提供的set_cookie()方法。要使用这个方法，我们需要先 使用make_response()方法手动生成一个响应对象，传入响应主体作为 参数。这个响应对象默认实例化内置的Response类。 set_cookie视图用来设置cookie，它会将URL中的name变量的值设置 到名为name的cookie里 from flask import Flask, make_response, url_for...@app.route(/set/name)def set_cookie(name): response = make_response(redirect(url_for(hello))) response.set_cookie(name, name) return response 当浏览器保存了服务器端设置的Cookie后，浏览器再次发送到该服 务器的请求会自动携带设置的Cookie信息，Cookie的内容存储在请求首部的Cookie字段中，整个交互过程由上到下如下图所示。 在Flask中，Cookie可以通过请求对象的cookies属性读取。在修改后 的hello视图中，如果没有从查询参数中获取到name的值，就从Cookie中寻找： from flask import Flask, request@app.route(/)@app.route(/hello)def hello(): name = request.args.get(name) if name is None: name = request.cookies.get(name, Human) # 从Cookie中获取name值 return h1Hello, %s/h1 % name session：安全的CookieCookie在Web程序中发挥了很大的作用，其中最重要的功能是存储 用户的认证信息。我们先来看看基于浏览器的用户认证是如何实现的。当我们使用浏览器登录某个社交网站时，会在登录表单中填写用户名和 密码，单击登录按钮后，这会向服务器发送一个包含认证数据的请求。服务器接收请求后会查找对应的账户，然后验证密码是否匹配，如果匹 配，就在返回的响应中设置一个cookie，比如，login_user：greyli。响应被浏览器接收后，cookie会被保存在浏览器中。当用户再次向 这个服务器发送请求时，根据请求附带的Cookie字段中的内容，服务器 上的程序就可以判断用户的认证状态，并识别出用户。但是这会带来一个问题，在浏览器中手动添加和修改Cookie是很容 易的事，仅仅通过浏览器插件就可以实现。所以，如果直接把认证信息 以明文的方式存储在Cookie里，那么恶意用户就可以通过伪造cookie的 内容来获得对网站的权限，冒用别人的账户。为了避免这个问题，我们 需要对敏感的Cookie内容进行加密。方便的是，Flask提供了session对象 用来将Cookie数据加密储存。 设置程序密钥session通过密钥对数据进行签名以加密数据，因此，我们得先设置 一个密钥。这里的密钥就是一个具有一定复杂度和随机性的字符串，比 如“Drmhze6EPcv0fN_81Bj-nA”。程序的密钥可以通过Flask.secret_key属性或配置变量SECRET_KEY 设置，比如：更安全的做法是把密钥写进系统环境变量（在命令行中使用export 或set命令），或是保存在.env文件中： app.secret_key = secret stringSECRET_KEY=secret stringapp.secret_key = SECRET_KEY 然后在程序脚本中使用os模块提供的getenv（）方法获取： import os# ...app.secret_key = os.getenv(SECRET_KEY, secret string) 模拟用户认证下面我们会使用session模拟用户的认证功能。代码清单2-5是用来 登入用户的login视图。 from flask import redirect, session, url_for@app.route(/login)def login(): session[logged_in] = True # 写入session return redirect(url_for(hello)) 这个登录视图只是简化的示例，在实际的登录中，我们需要在页面 上提供登录表单，供用户填写账户和密码，然后在登录视图里验证账户和密码的有效性。session对象可以像字典一样操作，我们向session中添 加一个logged-in cookie，将它的值设为True，表示用户已认证。当我们使用session对象添加cookie时，数据会使用程序的密钥对其 进行签名，加密后的数据存储在一块名为session的cookie里。 Flask上下文我们可以把编程中的上下文理解为当前环境（environment）的快照 （snapshot）。如果把一个Flask程序比作一条可怜的生活在鱼缸里的鱼 的话，那么它当然离不开身边的环境。 上下文全局变量每一个视图函数都需要上下文信息，在前面我们学习过Flask将请求 报文封装在request对象中。按照一般的思路，如果我们要在视图函数中使用它，就得把它作为参数传入视图函数，就像我们接收URL变量一 样。但是这样一来就会导致大量的重复，而且增加了视图函数的复杂度。 在前面的示例中，我们并没有传递这个参数，而是直接从Flask导入 一个全局的request对象，然后在视图函数里直接调用request的属性获取数据。你一定好奇，我们在全局导入时request只是一个普通的Python对 象，为什么在处理请求时，视图函数里的request就会自动包含对应请求 的数据？这是因为Flask会在每个请求产生后自动激活当前请求的上下文，激活请求上下文后，request被临时设为全局可访问。而当每个请求结束后，Flask就销毁对应的请求上下文。 我们在前面说request是全局对象，但这里的“全局”并不是实际意义 上的全局。我们可以把这些变量理解为动态的全局变量。在多线程服务器中，在同一时间可能会有多个请求在处理。假设有 三个客户端同时向服务器发送请求，这时每个请求都有各自不同的请求报文，所以请求对象也必然是不同的。因此，请求对象只在各自的线程 内是全局的。Flask通过本地线程（thread local）技术将请求对象在特定 的线程和请求中全局可访问。具体内容和应用我们会在后面进行详细介绍。 我们在前面对session和request都了解得差不多了，这里简单介绍一 下current_app和g。你在这里也许会疑惑，既然有了程序实例app对象，为什么还需要 current_app变量。在不同的视图函数中，request对象都表示和视图函数 对应的请求，也就是当前请求（current request）。而程序也会有多个程 序实例的情况，为了能获取对应的程序实例，而不是固定的某一个程序实例，我们就需要使用current_app变量，后面会详细介绍。 因为g存储在程序上下文中，而程序上下文会随着每一个请求的进入而激活，随着每一个请求的处理完毕而销毁，所以每次请求都会重设 这个值。我们通常会使用它结合请求钩子来保存每个请求处理前所需要 的全局变量，比如当前登入的用户对象，数据库连接等。在前面的示例中，我们在hello视图中从查询字符串获取name的值，如果每一个视图都需要这个值，那么就要在每个视图重复这行代码。借助g我们可以将这 个操作移动到before_request处理函数中执行，然后保存到g的任意属性上： from flask import g@app.before_requestdef get_name(): g.name = request.args.get(name) 设置这个函数后，在其他视图中可以直接使用g.name获取对应的值。另外，g也支持使用类似字典的get()、pop()以及setdefault()方法进行操作。 激活上下文阳光柔和，鱼儿在水里欢快地游动，这一切都是上下文存在后的美好景象。如果没有上下文，我们的程序只能直挺挺地躺在鱼缸里。在下 面这些情况下，Flask会自动帮我们激活程序上下文： 当我们使用flask run命令启动程序时。 使用旧的app.run()方法启动程序时。 执行使用@app.cli.command()装饰器注册的flask命令时。 使用flask shell命令启动Python Shell时。 当请求进入时，Flask会自动激活请求上下文，这时我们可以使用request和session变量。另外，当请求上下文被激活时，程序上下文也被自动激活。当请求处理完毕后，请求上下文和程序上下文也会自动销毁。也就是说，在请求处理时这两者拥有相同的生命周期。结合Python的代码执行机制理解，这也就意味着，我们可以在视图 函数中或在视图函数内调用的函数方法中使用所有上下文全局变量。在使用flask shell命令打开的Python Shell中，或是自定义的flask命令函数 中，我们可以使用current_app和g变量，也可以手动激活请求上下文来使用request和session。如果我们在没有激活相关上下文时使用这些变量，Flask就会抛出 RuntimeError异常：RuntimeError：Working outside of application context.或是RuntimeError：Working outside of request context.。 上下文钩子在前面我们学习了请求生命周期中可以使用的几种钩子，Flask也为上下文提供了一个teardown_appcontext钩子，使用它注册的回调函数会 在程序上下文被销毁时调用，而且通常也会在请求上下文被销毁时调用。比如，你需要在每个请求处理结束后销毁数据库连接： @app.teardown_appcontextdef teardown_db(exception): ... db.close() 使用app.teardown_appcontext装饰器注册的回调函数需要接收异常 对象作为参数，当请求被正常处理时这个参数值将是None，这个函数的 返回值将被忽略。上下文是Flask的重要话题，在这里我们也只是简单了解一下，后面我们会详细了解上下文的实现原理。 HTTP进阶实践重定向回上一个页面在前面的示例程序中，我们使用redirect()函数生成重定向响应。 比如，在login视图中，登入用户后我们将用户重定向到hello页面。在 复杂的应用场景下，我们需要在用户访问某个URL后重定向到上一个页 面。最常见的情况是，用户单击某个需要登录才能访问的链接，这时程 序会重定向到登录页面，当用户登录后合理的行为是重定向到用户登录 前浏览的页面，以便用户执行未完成的操作，而不是直接重定向到主页。在示例程序中，我们创建了两个视图函数foo和bar，分别显示一个 Foo页面和一个Bar页面。 @app.route(/foo)def foo(): return h1Foo page/h1a href=%sDo something/a % url_for(do_something)app.route(/bar)def bar(): return h1Bar page/h1a href=%sDo something /a % url_for(do_something)@app.route(/do_something)def do_something(): # do something return redirect(url_for(hello)) 获取上一个页面的URL 要重定向回上一个页面，最关键的是获取上一个页面的URL。上一 个页面的URL一般可以通过两种方式获取： （1）HTTP refererHTTP referer（起源为referrer在HTTP规范中的错误拼写）是一个用来记录请求发源地址的HTTP首部字段（HTTP_REFERER），即访问来源。当用户在某个站点单击链接，浏览器向新链接所在的服务器发起请求，请求的数据中包含的HTTP_REFERER字段记录了用户所在的原站点URL。这个值通常会用来追踪用户，比如记录用户进入程序的外部站点，以此来更有针对性地进行营销。在Flask中，referer的值可以通过请求对象的referrer属性获取，即request.referrer（正确拼写形式）。 return redirect(request.referrer)return redirect(request.referrer or url_for(hello)) （2）查询参数除了自动从referrer获取，另一种更常见的方式是在URL中手动加入包含当前页面URL的查询参数，这个查询参数一般命名为next。比如，下面在foo和bar视图的返回值中的URL后添加next参数 from flask import request@app.route(/foo)def foo(): return h1Foo page/h1a href=%sDo something and redirect/a % url_for(do_something, next=request.full_path)@app.route(/bar)def bar(): return h1Bar page/h1a href=%sDo something and redirect/a % url_for(do_something, next=request.full_path)return redirect(request.args.get(next))return redirect(request.args.get(next, url_for(hello))) 对URL进行安全验证虽然我们已经实现了重定向回上一个页面的功能，但安全问题不容 小觑，鉴于referer和next容易被篡改的特性，如果我们不对这些值进行 验证，则会形成开放重定向（Open Redirect）漏洞。 以URL中的next参数为例，next变量以查询字符串的方式写在URL里，因此任何人都可以发给某个用户一个包含next变量指向任何站点的链接。举个简单的例子，如果你访问下面的URL： http://localhost:5000/do-something?next=http://helloflask.com 程序会被重定向到http://helloflask.com 。也就是说，如果我们不验 证next变量指向的URL地址是否属于我们的应用内，那么程序很容易就 会被重定向到外部地址。 假设我们的应用是一个银行业务系统（下面简称网站A），某个攻击者模仿我们的网站外观做了一个几乎一模一样的网站（下面简称网站 B）。接着，攻击者伪造了一封电子邮件，告诉用户网站A账户信息需要更新，然后向用户提供一个指向网站A登录页面的链接，但链接中包 含一个重定向到网站B的next变量，比如：http://exampleA.com/login?next=http://maliciousB.com。当用户在A网站登录后，如果A网站重定向到next对应的URL，那么就会导致重定向到攻击者编写的B网站。因为B网站完全模仿A网站的外观，攻击者就可以在重定向后的B网站诱导用户输入敏感信息，比如银行卡号及密码。确保URL安全的关键就是判断URL是否属于程序内部，我们创建了一个URL验证函数is_safe_url()，用来验证next变 量值是否属于程序内部URL。 from urlparse import urlparse, urljoin# Python3需要从urllib.parse导入from flask import requestdef is_safe_url(target): ref_url = urlparse(request.host_url) test_url = urlparse(urljoin(request.host_url, target)) return test_url.scheme in (http, https) and ref_url.netloc == test_url.netloc 使用AJAX技术发送异步请求在传统的Web应用中，程序的操作都是基于请求响应循环来实现的。每当页面状态需要变动，或是需要更新数据时，都伴随着一个发向服务器的请求。当服务器返回响应时，整个页面会重载，并渲染新页面。这种模式会带来一些问题。首先，频繁更新页面会牺牲性能，浪费 服务器资源，同时降低用户体验。另外，对于一些操作性很强的程序来说，重载页面会显得很不合理。比如我们做了一个Web计算器程序，所有的按钮和显示屏幕都很逼真，但当我们单击“等于”按钮时，要等到页面重新加载后才在显示屏幕上看到结果，这显然会严重影响用户体验。我们这一节要学习的AJAX技术可以完美地解决这些问题。 HTTP服务器端推送不论是传统的HTTP请求-响应式的通信模式，还是异步的AJAX式请求，服务器端始终处于被动的应答状态，只有在客户端发出请求的情况下，服务器端才会返回响应。这种通信模式被称为客户端拉取 （client pull）。在这种模式下，用户只能通过刷新页面或主动单击加载 按钮来拉取新数据。 然而，在某些场景下，我们需要的通信模式是服务器端的主动推送 （server push）。比如，一个聊天室有很多个用户，当某个用户发送消息后，服务器接收到这个请求，然后把消息推送给聊天室的所有用户。 类似这种关注实时性的情况还有很多，比如社交网站在导航栏实时显示新提醒和私信的数量，用户的在线状态更新，股价行情监控、显示商品 库存信息、多人游戏、文档协作等。 Web安全防范无论是简单的博客，还是大型的社交网站，Web安全都应该放在首位。Web安全问题涉及广泛，我们在这里介绍其中常见的几种攻击（attack）和其他常见的漏洞（vulnerability）。 对于Web程序的安全问题，一个首要的原则是：永远不要相信你的用户。大部分Web安全问题都是因为没有对用户输入的内容进行“消 毒”造成的。 注入攻击在OWASP（Open Web Application Security Project，开放式Web程 序安全项目）发布的最危险的Web程序安全风险Top 10中，无论是最新 的2017年的排名，2013年的排名还是最早的2010年，注入攻击 （Injection）都位列第一。注入攻击包括系统命令（OS Command）注 入、SQL（Structured Query Language，结构化查询语言）注入（SQL Injection）、NoSQL注入、ORM（Object Relational Mapper，对象关系 映射）注入等。我们这里重点介绍的是SQL注入。 XSS攻击XSS（Cross-Site Scripting，跨站脚本）攻击历史悠久，最远可以追溯到90年代，但至今仍然是危害范围非常广的攻击方式。在OWASP TOP 10中排名第7。 CSRF攻击CSRF（Cross Site Request Forgery，跨站请求伪造）是一种近年来才逐渐被大众了解的网络攻击方式，又被称为One-Click Attack或Session Riding。在OWASP上一次（2013）的TOP 10 Web程序安全风险中，它位列第8。随着大部分程序的完善，各种框架都内置了对CSRF保护的支 持，但目前仍有5%的程序受到威胁。 本章小结HTTP是各种Web程序的基础，本章只是简要介绍了和Flask相关的部分，没有涉及HTTP底层的TCPIP或DNS协议。建议你通过阅读相关 书籍来了解完整的Web原理，这将有助于编写更完善和安全的Web程序。 在下一章，我们会学习使用Flask的模板引擎——Jinja2，通过学习运用模板和静态文件，我们可以让程序变得更加丰富和完善。现在前后端分离的架构下，Jinja2我们就简单的介绍一下。 Jinja模板在动态Web程序中，视图函数返回的HTML数据往往需要根据相应的变量（比如查询参数）动态生成。当HTML代码保存到单独的文件中时，我们没法再使用字符串格式化或拼接字符串的方式来在HTML代码中插入变量，这时我们需要使用模板引擎（template engine）。借助模板引擎，我们可以在HTML文件中使用特殊的语法来标记出变量，这类包含固定内容和动态部分的可重用文件称为模板（template）。模板引擎的作用就是读取并执行模板中的特殊语法标记，并根据传入的数据将变量替换为实际值，输出最终的HTML页面，这个过程被称为渲染（rendering）。Flask默认使用的模板引擎是Jinja2，它是一个功 能齐全的Python模板引擎，除了设置变量，还允许我们在模板中添加if判断，执行for迭代，调用函数等，以各种方式控制模板的输出。对于Jinja2来说，模板可以是任何格式的纯文本文件，比如HTML、XML、 CSV、LaTeX等。 模板基本用法user = username: Grey Li, bio: A boy who loves movies and music.,movies = [ name: My Neighbor Totoro, year: 1988, name: Three Colours trilogy, year: 1993, name: Forrest Gump, year: 1994, name: Perfect Blue, year: 1997, name: The Matrix, year: 1999, name: Memento, year: 2000, name: The Bucket list, year: 2007, name: Black Swan, year: 2010, name: Gone Girl, year: 2014, name: CoCo, year: 2017,] 我们在templates目录下创建一个watchlist.html作为模板文件，然后 使用Jinja2支持的语法在模板中操作这些变量 !DOCTYPE htmlhtml lang=enhead meta charset=utf-8 title user.username s Watchlist/title/headbody a href= url_for(index) larr; Return/a h2 user.username /h2% if user.bio % i user.bio /i% else % iThis user has not provided a bio./i% endif % # 下面是电影清单（这是注释） # h5 user.username s Watchlist ( movies|length ):/h5 ul% for movie in movies % li movie.name - movie.year /li % endfor % /ul/body/html Jinja2 的用法很多，其实和Java的那个jsp用法差不多，具体的用法可以查询文档 Jinja2文档 Jinja2 其实跟jsp的优缺点也很像，在复杂的页面并不太好用，还是用Web API和Vue比较适合我。 总结上面的3章介绍的都是Flask的基础知识，比较简单也比较枯燥，主要的篇幅放在了HTTP上面，其他两章在官方的文档中介绍的很详细。基础篇还剩一部分，将会在后面介绍，剩下的基础篇会结合基础知识和实际的用途，以及代码来介绍。","tags":["Flask","Python"],"categories":["IT技术"]},{"title":"Python-100天(三)-数据库基础和进阶","path":"/memoirs/20200312/python/Python-100-3/","content":"关系数据库入门 关系数据库概述 数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。 数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL数据库。 1970年，IBM的研究员E.F.Codd在Communication of the ACM上发表了名为A Relational Model of Data for Large Shared Data Banks的论文，提出了关系模型的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。 关系数据库特点。 理论基础：集合论和关系代数。 具体表象：用二维表（有行和列）组织数据。 编程语言：结构化查询语言（SQL）。 ER模型（实体关系模型）和概念模型图。ER模型，全称为实体关系模型（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式. 实体 - 矩形框 属性 - 椭圆框 关系 - 菱形框 重数 - 1:1（一对一） 1:N（一对多） M:N（多对多） 实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是ER模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出SQL或直接生成数据表）。 关系数据库产品。 Oracle - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在Oracle最新的12c版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。 DB2 - IBM公司开发的、主要运行于Unix（包括IBM自家的AIX）、Linux、以及Windows服务器版等系统的关系数据库产品。DB2历史悠久且被认为是最早使用SQL的数据库产品，它拥有较为强大的商业智能功能。 SQL Server - 由Microsoft开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。 MySQL - MySQL是开放源代码的，任何人都可以在GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。 PostgreSQL - 在BSD许可证下发行的开放源代码的关系数据库产品。 MySQL简介MySQL最早是由瑞典的MySQL AB公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此在这之后MySQL成为了Oracle旗下产品。 MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着MySQL的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了MySQL来提供数据持久化服务。 甲骨文公司收购后昇阳微系统公司，大幅调涨MySQL商业版的售价，且甲骨文公司不再支持另一个自由软件项目OpenSolaris的发展，因此导致自由软件社区对于Oracle是否还会持续支持MySQL社区版（MySQL的各个发行版本中唯一免费的版本）有所担忧，MySQL的创始人麦克尔·维德纽斯以MySQL为基础，成立分支计划MariaDB（以他女儿的名字命名的数据库）。有许多原来使用MySQL数据库的公司（例如：维基百科）已经陆续完成了从MySQL数据库到MariaDB数据库的迁移。 安装和配置 说明：下面的安装和配置都是以CentOS Linux环境为例，如果需要在其他系统下安装MySQL，读者可以自行在网络上查找对应的安装教程）。 刚才说过，MySQL有一个分支版本名叫MariaDB，该数据库旨在继续保持MySQL数据库在GNU GPL下开源。如果要使用MariaDB作为MySQL的替代品，可以使用下面的命令进行安装。 yum install mariadb mariadb-server 如果要安装官方版本的MySQL，可以在MySQL官方网站下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接。下面以MySQL 5.7.26版本和Red Hat Enterprise Linux为例，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。 wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar 如果系统上有MariaDB相关的文件，需要先移除MariaDB相关的文件。 yum list installed | grep mariadb | awk print $1 | xargs yum erase -y 接下来可以按照如下所示的顺序用RPM（Redhat Package Manager）工具安装MySQL。 rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm 可以使用下面的命令查看已经安装的MySQL相关的包。 rpm -qa | grep mysql 配置MySQL。 MySQL的配置文件在/etc目录下，名为my.cnf，默认的配置文件内容如下所示。如果对这个文件不理解并没有关系，什么时候用到这个配置文件什么时候再了解它就行了。 cat /etc/my.cnf # For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 启动MySQL服务。 可以使用下面的命令来启动MySQL。 service mysqld start 在CentOS 7中，更推荐使用下面的命令来启动MySQL。 systemctl start mysqld 启动MySQL成功后，可以通过下面的命令来检查网络端口使用情况，MySQL默认使用3306端口。 netstat -ntlp | grep mysql 也可以使用下面的命令查找是否有名为mysqld的进程。 pgrep mysqld 使用MySQL客户端工具连接服务器。 命令行工具： mysql -u root -p 说明：启动客户端时，-u参数用来指定用户名，MySQL默认的超级管理账号为root；-p表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用-h来指定连接主机的主机名或IP地址。 如果是首次安装MySQL，可以使用下面的命令来找到默认的初始密码。 cat /var/log/mysqld.log | grep password 上面的命令会查看MySQL的日志带有password的行，在显示的结果中root@localhost:后面的部分就是默认设置的初始密码。 修改超级管理员（root）的访问口令为123456。 set global validate_password_policy=0;set global validate_password_length=6;alter user root@localhost identified by 123456; 说明：MySQL较新的版本默认不允许使用弱口令作为用户口令，所以我们通过上面的前两条命令修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，攻击数据库窃取数据和劫持数据库勒索比特币的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是不要让数据库服务器暴露在公网上（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好root账号的口令，应用系统需要访问数据库时，通常不使用root账号进行访问，而是创建其他拥有适当权限的账号来访问。 再次使用客户端工具连接MySQL服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接MySQL服务器，包括： MySQL Workbench（官方提供的工具） Navicat for MySQL（界面简单优雅，功能直观强大） SQLyog for MySQL（强大的MySQL数据库管理员工具） 常用命令。 查看服务器版本。 select version(); 查看所有数据库。 show databases; 切换到指定数据库。 use mysql; 查看数据库下所有表。 show tables; 获取帮助。 ? contents;? functions;? numeric functions;? round;? data types;? longblob; SQL详解基本操作我们通常可以将SQL分为三类：DDL（数据定义语言）、DML（数据操作语言）和DCL（数据控制语言）。DDL主要用于创建（create）、删除（drop）、修改（alter）数据库中的对象，比如创建、删除和修改二维表；DML主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）；DCL通常用于授予权限（grant）和召回权限（revoke）。 说明：SQL是不区分大小写的语言，为了书写方便，下面的SQL都使用了小写字母来书写。 DDL（数据定义语言） -- 如果存在名为school的数据库就删除它drop database if exists school;-- 创建名为school的数据库并设置默认的字符集和排序方式create database school default charset utf8;-- 切换到school数据库上下文环境use school;-- 创建学院表create table tb_college(collid int auto_increment comment 编号,collname varchar(50) not null comment 名称,collintro varchar(500) default comment 介绍,primary key (collid));-- 创建学生表create table tb_student(stuid int not null comment 学号,stuname varchar(20) not null comment 姓名,stusex boolean default 1 comment 性别,stubirth date not null comment 出生日期,stuaddr varchar(255) default comment 籍贯,collid int not null comment 所属学院,primary key (stuid),foreign key (collid) references tb_college (collid));-- 创建教师表create table tb_teacher(teaid int not null comment 工号,teaname varchar(20) not null comment 姓名,teatitle varchar(10) default 助教 comment 职称,collid int not null comment 所属学院,primary key (teaid),foreign key (collid) references tb_college (collid));-- 创建课程表create table tb_course(couid int not null comment 编号,couname varchar(50) not null comment 名称,coucredit int not null comment 学分,teaid int not null comment 授课老师,primary key (couid),foreign key (teaid) references tb_teacher (teaid));-- 创建选课记录表create table tb_record(recid int auto_increment comment 选课记录编号,sid int not null comment 选课学生,cid int not null comment 所选课程,seldate datetime default now() comment 选课时间日期,score decimal(4,1) comment 考试成绩,primary key (recid),foreign key (sid) references tb_student (stuid),foreign key (cid) references tb_course (couid),unique (sid, cid)); 上面的DDL有几个地方需要强调一下： 创建数据库时，我们通过default charset utf8指定了数据库默认使用的字符集，我们推荐使用该字符集，因为utf8能够支持国际化编码。如果将来数据库中用到的字符可能包括类似于Emoji这样的图片字符，也可以将默认字符集设定为utf8mb4（最大4字节的utf-8编码）。查看MySQL支持的字符集可以执行下面的语句。 show character set; +----------+---------------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+---------------------------------+---------------------+--------+| big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 || latin1 | cp1252 West European | latin1_swedish_ci | 1 || latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 || swe7 | 7bit Swedish | swe7_swedish_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || ujis | EUC-JP Japanese | ujis_japanese_ci | 3 || sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 || hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 || tis620 | TIS620 Thai | tis620_thai_ci | 1 || euckr | EUC-KR Korean | euckr_korean_ci | 2 || koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 || gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 || greek | ISO 8859-7 Greek | greek_general_ci | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 || latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 || armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || utf8 | UTF-8 Unicode | utf8_general_ci | 3 || ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 || cp866 | DOS Russian | cp866_general_ci | 1 || keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 || macce | Mac Central European | macce_general_ci | 1 || macroman | Mac West European | macroman_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 || utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 || cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || utf16 | UTF-16 Unicode | utf16_general_ci | 4 || utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || utf32 | UTF-32 Unicode | utf32_general_ci | 4 || binary | Binary pseudo charset | binary | 1 || geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 || gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec) 如果要设置MySQL服务启动时默认使用的字符集，可以修改MySQL的配置并添加以下内容 [mysqld]character-set-server=utf8 在创建表的时候，我们可以在右圆括号的后面通过engine=XXX来指定表的存储引擎，MySQL支持多种存储引擎，可以通过show engines命令进行查看。MySQL 5.5以后的版本默认使用的存储引擎是InnoDB，它正好也就是我们推荐大家使用的存储引擎（因为InnoDB更适合互联网应用对高并发、性能以及事务支持等方面的需求）。 show engines\\G *************************** 1. row *************************** Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES XA: YES Savepoints: YES*************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tablesTransactions: NO XA: NO Savepoints: NO*************************** 3. row *************************** Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO XA: NO Savepoints: NO*************************** 4. row *************************** Engine: BLACKHOLE Support: YES Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO XA: NO Savepoints: NO*************************** 5. row *************************** Engine: MyISAM Support: YES Comment: MyISAM storage engineTransactions: NO XA: NO Savepoints: NO*************************** 6. row *************************** Engine: CSV Support: YES Comment: CSV storage engineTransactions: NO XA: NO Savepoints: NO*************************** 7. row *************************** Engine: ARCHIVE Support: YES Comment: Archive storage engineTransactions: NO XA: NO Savepoints: NO*************************** 8. row *************************** Engine: PERFORMANCE_SCHEMA Support: YES Comment: Performance SchemaTransactions: NO XA: NO Savepoints: NO*************************** 9. row *************************** Engine: FEDERATED Support: NO Comment: Federated MySQL storage engineTransactions: NULL XA: NULL Savepoints: NULL9 rows in set (0.00 sec) 下面的表格对MySQL几种常用的数据引擎进行了简单的对比。 特性 InnoDB MRG_MYISAM MEMORY MyISAM 存储限制 有 没有 有 有 事务 支持 锁机制 行锁 表锁 表锁 表锁 B树索引 支持 支持 支持 支持 哈希索引 支持 全文检索 支持（5.6+） 支持 集群索引 支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 支持 数据可压缩 支持 内存使用 高 低 中 低 存储空间使用 高 低 低 批量插入性能 低 高 高 高 是否支持外键 支持 通过上面的比较我们可以了解到，InnoDB是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且它也是较新的MySQL版本中默认使用的存储引擎。 在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过MySQL的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。 ? data types You asked for help about help category: Data TypesFor more information, type help item, where item is one of the followingtopics: AUTO_INCREMENT BIGINT BINARY BIT BLOB BLOB DATA TYPE BOOLEAN CHAR CHAR BYTE DATE DATETIME DEC DECIMAL DOUBLE DOUBLE PRECISION ENUM FLOAT INT INTEGER LONGBLOB LONGTEXT MEDIUMBLOB MEDIUMINT MEDIUMTEXT SET DATA TYPE SMALLINT TEXT TIME TIMESTAMP TINYBLOB TINYINT TINYTEXT VARBINARY VARCHAR YEAR DATA TYPE ? varchar Name: VARCHARDescription:[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATEcollation_name]A variable-length string. M represents the maximum column length incharacters. The range of M is 0 to 65,535. The effective maximum lengthof a VARCHAR is subject to the maximum row size (65,535 bytes, which isshared among all columns) and the character set used. For example, utf8characters can require up to three bytes per character, so a VARCHARcolumn that uses the utf8 character set can be declared to be a maximumof 21,844 characters. Seehttp://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plusdata. The length prefix indicates the number of bytes in the value. AVARCHAR column uses one length byte if values require no more than 255bytes, two length bytes if values may require more than 255 bytes.*Note*:MySQL follows the standard SQL specification, and does not removetrailing spaces from VARCHAR values.VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is thestandard SQL way to define that a VARCHAR column should use somepredefined character set. MySQL uses utf8 as this predefined characterset. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.NVARCHAR is shorthand for NATIONAL VARCHAR.URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html 在数据类型的选择上，保存字符串数据通常都使用VARCHAR和CHAR两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于InnoDB存储引擎，行存储格式没有区分固定长度和可变长度列，因此VARCHAR类型好CHAR类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用TEXT类型；如果要保存很大的字节串，可以使用BLOB（二进制大对象）类型。在MySQL中，TEXT和BLOB又分别包括TEXT、MEDIUMTEXT、LONGTEXT和BLOB、MEDIUMBLOB、LONGBLOB三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用FLOAT或DOUBLE类型，而保存定点数应该使用DECIMAL类型。如果要保存时间日期，DATETIME类型优于TIMESTAMP类型，因为前者能表示的时间日期范围更大。 DML -- 插入学院数据insert into tb_college (collname, collintro) values (计算机学院, 创建于1956年是我国首批建立计算机专业。学院现有计算机科学与技术一级学科和网络空间安全一级学科博士学位授予权，其中计算机科学与技术一级学科具有博士后流动站。计算机科学与技术一级学科在2017年全国第四轮学科评估中评为A；2019 U.S.News全球计算机学科排名26名；ESI学科排名0.945‰，进入全球前1‰，位列第43位。),(外国语学院, 1998年浙江大学、杭州大学、浙江农业大学、浙江医科大学四校合并，成立新的浙江大学。1999年原浙江大学外语系、原杭州大学外国语学院、原杭州大学大外部、原浙江农业大学公外部、原浙江医科大学外语教学部合并，成立浙江大学外国语学院。2003年学院更名为浙江大学外国语言文化与国际交流学院。),(经济管理学院, 四川大学经济学院历史悠久、传承厚重，其前身是创办于1905年的四川大学经济科,距今已有100多年的历史。已故著名经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代著名学者刘诗白等曾先后在此任教或学习。在长期的办学过程中，学院坚持以马克思主义的立场、观点、方法为指导，围绕建设世界一流经济学院的奋斗目标，做实“两个伟大”深度融合，不断提高党的建设质量与科学推进一流事业深度融合。);-- 插入学生数据insert into tb_student (stuid, stuname, stusex, stubirth, stuaddr, collid) values(1001, 杨逍, 1, 1990-3-4, 四川成都, 1),(1002, 任我行, 1, 1992-2-2, 湖南长沙, 1),(1033, 王语嫣, 0, 1989-12-3, 四川成都, 1),(1572, 岳不群, 1, 1993-7-19, 陕西咸阳, 1),(1378, 纪嫣然, 0, 1995-8-12, 四川绵阳, 1),(1954, 林平之, 1, 1994-9-20, 福建莆田, 1),(2035, 东方不败, 1, 1988-6-30, null, 2),(3011, 林震南, 1, 1985-12-12, 福建莆田, 3),(3755, 项少龙, 1, 1993-1-25, null, 3),(3923, 杨不悔, 0, 1985-4-17, 四川成都, 3),(4040, 隔壁老王, 1, 1989-1-1, 四川成都, 2);-- 删除学生数据delete from tb_student where stuid=4040;-- 更新学生数据update tb_student set stuname=杨过, stuaddr=湖南长沙 where stuid=1001;-- 插入老师数据insert into tb_teacher (teaid, teaname, teatitle, collid) values (1122, 张三丰, 教授, 1),(1133, 宋远桥, 副教授, 1),(1144, 杨逍, 副教授, 1),(2255, 范遥, 副教授, 2),(3366, 韦一笑, 讲师, 3);-- 插入课程数据insert into tb_course (couid, couname, coucredit, teaid) values (1111, Python程序设计, 3, 1122),(2222, Web前端开发, 2, 1122),(3333, 操作系统, 4, 1122),(4444, 计算机网络, 2, 1133),(5555, 编译原理, 4, 1144),(6666, 算法和数据结构, 3, 1144),(7777, 经贸法语, 3, 2255),(8888, 成本会计, 2, 3366),(9999, 审计学, 3, 3366);-- 插入选课数据insert into tb_record (sid, cid, seldate, score) values (1001, 1111, 2017-09-01, 95),(1001, 2222, 2017-09-01, 87.5),(1001, 3333, 2017-09-01, 100),(1001, 4444, 2018-09-03, null),(1001, 6666, 2017-09-02, 100),(1002, 1111, 2017-09-03, 65),(1002, 5555, 2017-09-01, 42),(1033, 1111, 2017-09-03, 92.5),(1033, 4444, 2017-09-01, 78),(1033, 5555, 2017-09-01, 82.5),(1572, 1111, 2017-09-02, 78),(1378, 1111, 2017-09-05, 82),(1378, 7777, 2017-09-02, 65.5),(2035, 7777, 2018-09-03, 88),(2035, 9999, default, null),(3755, 1111, default, null),(3755, 8888, default, null),(3755, 9999, 2017-09-01, 92); -- 查询所有学生信息select * from tb_student;-- 查询所有课程名称及学分(投影和别名)select couname, coucredit from tb_course;select couname as 课程名称, coucredit as 学分 from tb_course;-- 查询所有学生的姓名和性别(条件运算)select stuname as 姓名, case stusex when 1 then 男 else 女 end as 性别 from tb_student;select stuname as 姓名, if(stusex, 男, 女) as 性别 from tb_student;-- 查询所有女学生的姓名和出生日期(筛选)select stuname, stubirth from tb_student where stusex=0;-- 查询所有80后学生的姓名、性别和出生日期(筛选)select stuname, stusex, stubirth from tb_student where stubirth=1980-1-1 and stubirth=1989-12-31;select stuname, stusex, stubirth from tb_student where stubirth between 1980-1-1 and 1989-12-31;-- 查询姓杨的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like 杨%;-- 查询姓杨名字两个字的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like 杨_;-- 查询姓杨名字三个字的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like 杨__;-- 查询名字中有不字或嫣字的学生的姓名(模糊)select stuname, stusex from tb_student where stuname like %不% or stuname like %嫣%;-- 查询没有录入家庭住址的学生姓名(空值)select stuname from tb_student where stuaddr is null;-- 查询录入了家庭住址的学生姓名(空值)select stuname from tb_student where stuaddr is not null;-- 查询学生选课的所有日期(去重)select distinct seldate from tb_record;-- 查询学生的家庭住址(去重)select distinct stuaddr from tb_student where stuaddr is not null;-- 查询男学生的姓名和生日按年龄从大到小排列(排序)select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stusex=1 order by 年龄 desc;-- 查询年龄最大的学生的出生日期(聚合函数)select min(stubirth) from tb_student;-- 查询年龄最小的学生的出生日期(聚合函数)select max(stubirth) from tb_student;-- 查询男女学生的人数(分组和聚合函数)select stusex, count(*) from tb_student group by stusex;-- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)select avg(score) from tb_record where cid=1111;-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)select avg(score) from tb_record where sid=1001;-- 查询每个学生的学号和平均成绩(分组和聚合函数)select sid as 学号, avg(score) as 平均分 from tb_record group by sid;-- 查询平均成绩大于等于90分的学生的学号和平均成绩-- 分组以前的筛选使用where子句 / 分组以后的筛选使用having子句select sid as 学号, avg(score) as 平均分 from tb_record group by sid having 平均分=90;-- 查询年龄最大的学生的姓名(子查询/嵌套的查询)select stuname from tb_student where stubirth=( select min(stubirth) from tb_student );-- 查询年龄最大的学生姓名和年龄(子查询+运算)select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stubirth=( select min(stubirth) from tb_student );-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)select stuname from tb_student where stuid in ( select stuid from tb_record group by stuid having count(stuid)2 );-- 查询学生姓名、课程名称以及成绩(连接查询)select stuname, couname, score from tb_student t1, tb_course t2, tb_record t3 where stuid=sid and couid=cid and score is not null;-- 查询学生姓名、课程名称以及成绩按成绩从高到低查询第11-15条记录(内连接+分页)select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 5 offset 10;select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 10, 5;-- 查询选课学生的姓名和平均成绩(子查询和连接查询)select stuname, avgmark from tb_student, ( select sid, avg(score) as avgmark from tb_record group by sid ) temp where stuid=sid;select stuname, avgmark from tb_student inner join ( select sid, avg(score) as avgmark from tb_record group by sid ) temp on stuid=sid;-- 查询每个学生的姓名和选课数量(左外连接和子查询)select stuname, ifnull(total, 0) from tb_student left outer join ( select sid, count(sid) as total from tb_record group by sid ) temp on stuid=sid; 上面的DML有几个地方需要加以说明： MySQL中支持多种类型的运算符，包括：算术运算符（+、-、*、、%）、比较运算符（、、、、、、、BETWEEN…AND…、IN、IS NULL、IS NOT NULL、LIKE、RLIKE、REGEXP）、逻辑运算符（NOT、AND、OR、XOR）和位运算符（、|、^、~、、），我们可以在DML中使用这些运算符处理数据。 在查询数据时，可以在SELECT语句及其子句（如WHERE子句、ORDER BY子句、HAVING子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。 常用字符串函数。 函数 功能 CONCAT 将多个字符串连接成一个字符串 FORMAT 将数值格式化成字符串并指定保留几位小数 FROM_BASE64 TO_BASE64 BASE64解码编码 BIN OCT HEX 将数值转换成二进制八进制十六进制字符串 LOCATE 在字符串中查找一个子串的位置 LEFT RIGHT 返回一个字符串左边右边指定长度的字符 LENGTH CHAR_LENGTH 返回字符串的长度以字节字符为单位 LOWER UPPER 返回字符串的小写大写形式 LPAD RPAD 如果字符串的长度不足，在字符串左边右边填充指定的字符 LTRIM RTRIM 去掉字符串前面后面的空格 ORD CHAR 返回字符对应的编码返回编码对应的字符 STRCMP 比较字符串，返回-1、0、1分别表示小于、等于、大于 SUBSTRING 返回字符串指定范围的子串 常用数值函数。 函数 功能 ABS 返回一个数的绝度值 CEILING FLOOR 返回一个数上取整下取整的结果 CONV 将一个数从一种进制转换成另一种进制 CRC32 计算循环冗余校验码 EXP LOG LOG2 LOG10 计算指数对数 POW 求幂 RAND 返回[0,1)范围的随机数 ROUND 返回一个数四舍五入后的结果 SQRT 返回一个数的平方根 TRUNCATE 截断一个数到指定的精度 SIN COS TAN COT ASIN ACOS ATAN 三角函数 常用时间日期函数。 函数 功能 CURDATE CURTIME NOW 获取当前日期时间日期和时间 ADDDATE SUBDATE 将两个日期表达式相加相减并返回结果 DATE TIME 从字符串中获取日期时间 YEAR MONTH DAY 从日期中获取年月日 HOUR MINUTE SECOND 从时间中获取时分秒 DATEDIFF TIMEDIFF 返回两个时间日期表达式相差多少天小时 MAKEDATE MAKETIME 制造一个日期时间 常用流程函数。 函数 功能 IF 根据条件是否成立返回不同的值 IFNULL 如果为NULL则返回指定的值否则就返回本身 NULLIF 两个表达式相等就返回NULL否则返回第一个表达式的值 其他常用函数。 函数 功能 MD5 SHA1 SHA2 返回字符串对应的哈希摘要 CHARSET COLLATION 返回字符集校对规则 USER CURRENT_USER 返回当前用户 DATABASE 返回当前数据库名 VERSION 返回当前数据库版本 FOUND_ROWS ROW_COUNT 返回查询到的行数受影响的行数 LAST_INSERT_ID 返回最后一个自增主键的值 UUID UUID_SHORT 返回全局唯一标识符 DCL -- 创建可以远程登录的root账号并为其指定口令create user root@% identified by 123456;-- 为远程登录的root账号授权操作所有数据库所有对象的所有权限并允许其将权限再次赋予其他用户grant all privileges on *.* to root@% with grant option;-- 创建名为hellokitty的用户并为其指定口令create user hellokitty@% identified by 123123;-- 将对school数据库所有对象的所有操作权限授予hellokittygrant all privileges on school.* to hellokitty@%;-- 召回hellokitty对school数据库所有对象的insert/delete/update权限revoke insert, delete, update on school.* from hellokitty@%; 说明：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。 索引索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情（我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置）。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分的篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。 MySQL中，所有数据类型的列都可以被索引，常用的存储引擎InnoDB和MyISAM能支持每个表创建16个索引。InnoDB和MyISAM使用的索引其底层算法是B-tree（B树），B-tree是一种自平衡的树，类似于平衡二叉排序树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的操作都在对数时间内完成。 接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品道理是一样的。我们可以使用MySQL的explain关键字来查看SQL的执行计划。 explain select * from tb_student where stuname=林震南\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_student partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 11 filtered: 10.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 在上面的SQL执行计划中，有几项值得我们关注： type：MySQL在表中找到满足条件的行的方式，也称为访问类型，包括：ALL（全表扫描）、index（索引全扫描）、range（索引范围扫描）、ref（非唯一索引扫描）、eq_ref（唯一索引扫描）、constsystem、NULL。在所有的访问类型中，很显然ALL是性能最差的，它代表了全表扫描是指要扫描表中的每一行才能找到匹配的行。 possible_keys：MySQL可以选择的索引，但是有可能不会使用。 key：MySQL真正使用的索引。 rows：执行查询需要扫描的行数，这是一个预估值。 从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。 create index idx_student_name on tb_student(stuname); 再次查看刚才的SQL对应的执行计划。 explain select * from tb_student where stuname=林震南\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_student partitions: NULL type: refpossible_keys: idx_student_name key: idx_student_name key_len: 62 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL中还允许创建前缀索引，即对索引字段的前N个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，时间和空间是不可调和的矛盾），如下所示。 create index idx_student_name_1 on tb_student(stuname(1)); 上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看SQL执行计划。 explain select * from tb_student where stuname=林震南\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: tb_student partitions: NULL type: refpossible_keys: idx_student_name key: idx_student_name key_len: 5 ref: const rows: 2 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 不知道大家是否注意到，这一次扫描的行变成了2行，因为学生表中有两个姓“林”的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。 如果要删除索引，可以使用下面的SQL。 alter table tb_student drop index idx_student_name; 或者 drop index idx_student_name on tb_student; 我们简单的为大家总结一下索引的设计原则： 最适合索引的列是出现在WHERE子句和连接子句中的列。 索引列的基数越大（取值多重复值少），索引的效果就越好。 使用前缀索引可以减少索引占用的空间，内存中可以缓存更多的索引。 索引不是越多越好，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。 使用InnoDB存储引擎时，表的普通索引都会保存主键的值，所以主键要尽可能选择较短的数据类型，这样可以有效的减少索引占用的空间，利用提升索引的缓存效果。 最后，还有一点需要说明，InnoDB使用的B-tree索引，数值类型的列除了等值判断时索引会生效之外，使用、、、、BETWEEN…AND… 、时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。 视图视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的SQL语句。 使用视图可以获得以下好处： 可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。 在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。 重用SQL语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。 视图可以返回与实体数据表不同格式的数据， 创建视图。 create view vw_avg_score as select sid, round(avg(score), 1) as avgscore from tb_record group by sid;create view vw_student_score as select stuname, avgscore from tb_student, vw_avg_score where stuid=sid; 提示：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。 使用视图。 select stuname, avgscore from vw_student_score order by avgscore desc; +--------------+----------+| stuname | avgscore |+--------------+----------+| 杨过 | 95.6 || 任我行 | 53.5 || 王语嫣 | 84.3 || 纪嫣然 | 73.8 || 岳不群 | 78.0 || 东方不败 | 88.0 || 项少龙 | 92.0 |+--------------+----------+ 既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的： 使用了聚合函数（SUM、MIN、MAX、AVG、COUNT等）、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL的视图。 SELECT中包含了子查询的视图。 FROM子句中包含了一个不能更新的视图的视图。 WHERE子句的子查询引用了FROM子句中的表的视图。 删除视图。 drop view vw_student_score; 说明：如果希望更新视图，可以先用上面的命令删除视图，也可以通过create or replace view来更新视图。 视图的规则和限制。 视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。 创建视图时可以使用order by子句，但如果从视图中检索数据时也使用了order by，那么该视图中原先的order by会被覆盖。 视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。 存储过程存储过程是事先编译好存储在数据库中的一组SQL的集合，调用存储过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的SQL语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条SQL语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。 通过查询来核对库存中是否有对应的物品以及库存是否充足。 如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。 如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。 不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。 我们可以通过存储过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改存储过程即可。对于调用存储过程的用户来说，存储过程并没有暴露数据表的细节，而且执行存储过程比一条条的执行一组SQL要快得多。 下面的存储过程实现了查询某门课程的最高分、最低分和平均分。 drop procedure if exists sp_score_by_cid;delimiter $$create procedure sp_score_by_cid(\tcourseId int, out maxScore decimal(4,1), out minScore decimal(4,1),\tout avgScore decimal(4,1))begin\tselect max(score) into maxScore from tb_record where cid=courseId;\tselect min(score) into minScore from tb_record where cid=courseId;\tselect avg(score) into avgScore from tb_record where cid=courseId;end $$delimiter ;call sp_score_by_cid(1111, @a, @b, @c);select @a, @b, @c; 说明：在定义存储过程时，因为可能需要书写多条SQL，而分隔这些SQL需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义存储过程的SQL就会出现错误，所以上面我们用delimiter $$将整段代码结束的标记定义为$$，那么代码中的分号将不再表示整段代码的结束，需要马上执行，整段代码在遇到end $$时才输入完成并执行。在定义完存储过程后，通过delimiter ;将结束符重新改回成分号。 上面定义的存储过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为存储过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是out，默认情况下参数都是输入参数。 调用存储过程。 call sp_score_by_cid(1111, @a, @b, @c); 获取输出参数的值。 select @a as 最高分, @b as 最低分, @c as 平均分; 删除存储过程。 drop procedure sp_score_by_cid; 在存储过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多存储过程的好处，但是在实际开发中，如果过度的使用存储过程，将大量复杂的运算放到存储过程中，也会导致占用数据库服务器的CPU资源，造成数据库服务器承受巨大的压力。为此，我们一般会将复杂的运算和处理交给应用服务器，因为很容易部署多台应用服务器来分摊这些压力。 几个重要的概念范式理论 - 设计二维表的指导思想 第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。 第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。 第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。 数据完整性 实体完整性 - 每个实体都是独一无二的 主键（primary key） 唯一约束 唯一索引（unique） 引用完整性（参照完整性）- 关系中不允许引用不存在的实体 外键（foreign key） 域完整性 - 数据是有效的 数据类型及长度 非空约束（not null） 默认值约束（default） 检查约束（check） 说明：在MySQL数据库中，检查约束并不起作用。 数据一致性 事务：一系列对数据库进行读写的操作，这些操作要么全都成功，要么全都失败。 事务的ACID特性 原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行 一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态 隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性：已被提交的事务对数据库的修改应该永久保存在数据库中 MySQL中的事务操作 开启事务环境 start transaction 或 begin 提交事务 commit 回滚事务 rollback 其他内容大家应该能够想到，关于MySQL的知识肯定远远不止上面列出的这些，比如MySQL的性能优化、管理和维护MySQL的相关工具、MySQL数据的备份和恢复、监控MySQL、部署高可用架构等问题我们在这里都没有进行讨论。当然，这些内容也都是跟项目开发密切相关的，我们就留到后续的章节中再续点进行讲解。 Python数据库编程我们用如下所示的数据库来演示在Python中如何访问MySQL数据库。 drop database if exists hrs;create database hrs default charset utf8;use hrs;drop table if exists tb_emp;drop table if exists tb_dept;create table tb_dept(dno int not null comment 编号,dname varchar(10) not null comment 名称,dloc varchar(20) not null comment 所在地,primary key (dno));insert into tb_dept values (10, 会计部, 北京),\t(20, 研发部, 成都),\t(30, 销售部, 重庆),\t(40, 运维部, 深圳);create table tb_emp(eno int not null comment 员工编号,ename varchar(20) not null comment 员工姓名,job varchar(20) not null comment 员工职位,mgr int comment 主管编号,sal int not null comment 员工月薪,comm int comment 每月补贴,dno int comment 所在部门编号,primary key (eno));alter table tb_emp add constraint fk_emp_dno foreign key (dno) references tb_dept (dno);insert into tb_emp values (7800, 张三丰, 总裁, null, 9000, 1200, 20),\t(2056, 乔峰, 分析师, 7800, 5000, 1500, 20),\t(3088, 李莫愁, 设计师, 2056, 3500, 800, 20),\t(3211, 张无忌, 程序员, 2056, 3200, null, 20),\t(3233, 丘处机, 程序员, 2056, 3400, null, 20),\t(3251, 张翠山, 程序员, 2056, 4000, null, 20),\t(5566, 宋远桥, 会计师, 7800, 4000, 1000, 10),\t(5234, 郭靖, 出纳, 5566, 2000, null, 10),\t(3344, 黄蓉, 销售主管, 7800, 3000, 800, 30),\t(1359, 胡一刀, 销售员, 3344, 1800, 200, 30),\t(4466, 苗人凤, 销售员, 3344, 2500, null, 30),\t(3244, 欧阳锋, 程序员, 3088, 3200, null, 20),\t(3577, 杨过, 会计, 5566, 2200, null, 10),\t(3588, 朱九真, 会计, 5566, 2500, null, 10); 在Python 3中，我们通常使用纯Python的三方库PyMySQL来访问MySQL数据库，它应该是目前Python操作MySQL数据库最好的选择。 安装PyMySQL。 pip install pymysql 添加一个部门。 import pymysqldef main(): no = int(input(编号: )) name = input(名字: ) loc = input(所在地: ) # 1. 创建数据库连接对象 con = pymysql.connect(host=localhost, port=3306, database=hrs, charset=utf8, user=yourname, password=yourpass) try: # 2. 通过连接对象获取游标 with con.cursor() as cursor: # 3. 通过游标执行SQL并获得执行结果 result = cursor.execute( insert into tb_dept values (%s, %s, %s), (no, name, loc) ) if result == 1: print(添加成功!) # 4. 操作成功提交事务 con.commit() finally: # 5. 关闭连接释放资源 con.close()if __name__ == __main__: main() 删除一个部门。 import pymysqldef main(): no = int(input(编号: )) con = pymysql.connect(host=localhost, port=3306, database=hrs, charset=utf8, user=yourname, password=yourpass, autocommit=True) try: with con.cursor() as cursor: result = cursor.execute( delete from tb_dept where dno=%s, (no, ) ) if result == 1: print(删除成功!) finally: con.close()if __name__ == __main__: main() 说明：如果不希望每次SQL操作之后手动提交或回滚事务，可以像上面的代码那样，在创建连接的时候多加一个名为autocommit的参数并将它的值设置为True，表示每次执行SQL之后自动提交。如果程序中不需要使用事务环境也不希望手动的提交或回滚就可以这么做。 更新一个部门。 import pymysqldef main(): no = int(input(编号: )) name = input(名字: ) loc = input(所在地: ) con = pymysql.connect(host=localhost, port=3306, database=hrs, charset=utf8, user=yourname, password=yourpass, autocommit=True) try: with con.cursor() as cursor: result = cursor.execute( update tb_dept set dname=%s, dloc=%s where dno=%s, (name, loc, no) ) if result == 1: print(更新成功!) finally: con.close()if __name__ == __main__: main() 查询所有部门。 import pymysqlfrom pymysql.cursors import DictCursordef main(): con = pymysql.connect(host=localhost, port=3306, database=hrs, charset=utf8, user=yourname, password=yourpass) try: with con.cursor(cursor=DictCursor) as cursor: cursor.execute(select dno as no, dname as name, dloc as loc from tb_dept) results = cursor.fetchall() print(results) print(编号\\t名称\\t\\t所在地) for dept in results: print(dept[no], end=\\t) print(dept[name], end=\\t) print(dept[loc]) finally: con.close()if __name__ == __main__: main() 分页查询员工信息。 import pymysqlfrom pymysql.cursors import DictCursorclass Emp(object): def __init__(self, no, name, job, sal): self.no = no self.name = name self.job = job self.sal = sal def __str__(self): return f 编号：self.no 姓名：self.name 职位：self.job 月薪：self.sal def main(): page = int(input(页码: )) size = int(input(大小: )) con = pymysql.connect(host=localhost, port=3306, database=hrs, charset=utf8, user=yourname, password=yourpass) try: with con.cursor() as cursor: cursor.execute( select eno as no, ename as name, job, sal from tb_emp limit %s,%s, ((page - 1) * size, size) ) for emp_tuple in cursor.fetchall(): emp = Emp(*emp_tuple) print(emp) finally: con.close()if __name__ == __main__: main() NoSQL入门NoSQL概述如今，大多数的计算机系统（包括服务器、PC、移动设备等）都会产生庞大的数据量。其实，早在2012年的时候，全世界每天产生的数据量就达到了2.5EB（艾字节，$$1EB\\approx10^{18}B$$）。这些数据有很大一部分是由关系型数据库来存储和管理的。 早在1970年，E.F.Codd发表了论述关系型数据库的著名论文“A relational model of data for large shared data banks”，这篇文章奠定了关系型数据库的基础并在接下来的数十年时间内产生了深远的影响。实践证明，关系型数据库是实现数据持久化最为重要的方式，它也是大多数应用在选择持久化方案时的首选技术。 NoSQL是一项全新的数据库革命性运动，虽然它的历史可以追溯到1998年，但是NoSQL真正深入人心并得到广泛的应用是在进入大数据时候以后，业界普遍认为NoSQL是更适合大数据存储的技术方案，这才使得NoSQL的发展达到了前所未有的高度。2012年《纽约时报》的一篇专栏中写到，大数据时代已经降临，在商业、经济及其他领域中，决策将不再基于经验和直觉而是基于数据和分析而作出。事实上，在天文学、气象学、基因组学、生物学、社会学、互联网搜索引擎、金融、医疗、社交网络、电子商务等诸多领域，由于数据过于密集和庞大，在数据的分析和处理上也遇到了前所未有的限制和阻碍，这一切都使得对大数据处理技术的研究被提升到了新的高度，也使得各种NoSQL的技术方案进入到了公众的视野。 NoSQL数据库按照其存储类型可以大致分为以下几类： 类型 部分代表 特点 列族数据库 HBaseCassandraHypertable 顾名思义是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势，适合于批量数据处理和即时查询。 文档数据库 MongoDBCouchDBElasticSearch 文档数据库一般用类JSON格式存储数据，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能，但不提供对参照完整性和分布事务的支持。 KV数据库 DynamoDBRedisLevelDB 可以通过key快速查询到其value，有基于内存和基于磁盘两种实现方案。 图数据库 Neo4JFlockDBJanusGraph 使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。图数据库从设计上，就可以简单快速的检索难以在关系系统中建模的复杂层次结构。 对象数据库 db4oVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 说明：想了解更多的NoSQL数据库，可以访问http://nosql-database.org/。 Redis概述Redis是一种基于键值对的NoSQL数据库，它提供了对多种数据类型（字符串、哈希、列表、集合、有序集合、位图等）的支持，能够满足很多应用场景的需求。Redis将数据放在内存中，因此读写性能是非常惊人的。与此同时，Redis也提供了持久化机制，能够将内存中的数据保存到硬盘上，在发生意外状况时数据也不会丢掉。此外，Redis还支持键过期、地理信息运算、发布订阅、事务、管道、Lua脚本扩展等功能，总而言之，Redis的功能和性能都非常强大，如果项目中要实现高速缓存和消息队列这样的服务，直接交给Redis就可以了。目前，国内外很多著名的企业和商业项目都使用了Redis，包括：Twitter、Github、StackOverflow、新浪微博、百度、优酷土豆、美团、小米、唯品会等。 Redis简介2008年，一个名为Salvatore Sanfilippo的程序员为他开发的LLOOGG项目定制了专属的数据库（因为之前他无论怎样优化MySQL，系统性能已经无法再提升了），这项工作的成果就是Redis的初始版本。后来他将Redis的代码放到了全球最大的代码托管平台Github，从那以后，Redis引发了大量开发者的好评和关注，继而有数百人参与了Redis的开发和维护，这使得Redis的功能越来越强大和性能越来越好。 Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）： Redis的读写性能极高，并且有丰富的特性（发布订阅、事务、通知等）。 Redis支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis支持多种数据类型，包括：string、hash、list、set，zset、bitmap、hyperloglog等。 Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并自动调整配置）。 Redis支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。 Redis基于TCP提供的可靠传输服务进行通信，很多编程语言都提供了Redis客户端支持。 Redis的应用场景 高速缓存 - 将不常变化但又经常被访问的热点数据放到Redis数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。 排行榜 - 很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。 商品秒杀投票点赞 - Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或-1的操作来实现，从而避免了使用关系型数据的update操作。 分布式锁 - 利用Redis可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。 消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性，这些我们都会在后面的项目中为大家展示。 Redis的安装和配置可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。 wget http://download.redis.io/releases/redis-5.0.4.tar.gzgunzip redis-5.0.4.tar.gztar -xvf redis-5.0.4.tarcd redis-5.0.4make make install 在redis源代码目录下有一个名为redis.conf的配置文件，我们可以先查看一下该文件。 vim redis.conf 配置将Redis服务绑定到指定的IP地址和端口。配置底层有多少个数据库。配置Redis的持久化机制 - RDB。配置Redis的持久化机制 - AOF。配置访问Redis服务器的验证口令。配置Redis的主从复制，通过主从复制可以实现读写分离。配置慢查询。 上面这些内容就是Redis的基本配置，如果你对上面的内容感到困惑也没有关系，先把Redis用起来再回头去推敲这些内容就行了。如果想找一些参考书，《Redis开发与运维》是一本不错的入门读物，而《Redis实战》是不错的进阶读物。 Redis的服务器和客户端接下来启动Redis服务器，下面的方式将以默认的配置启动Redis服务。 redis-server 如果希望修改Redis的配置（如端口、认证口令、持久化方式等），可以通过下面两种方式。 方式一：通过参数指定认证口令和AOF持久化方式。 redis-server --requirepass yourpass --appendonly yes 方式二：通过指定的配置文件来修改Redis的配置。 redis-server /root/redis-5.0.4/redis.conf 下面我们使用第一种方式来启动Redis并将其置于后台运行，将Redis产生的输出重定向到名为redis.log的文件中。 redis-server --requirepass yourpass redis.log 可以通过ps或者netstat来检查Redis服务器是否启动成功。 ps -ef | grep redis-servernetstat -nap | grep redis-server 接下来，我们尝试用Redis客户端去连接服务器。 redis-cli127.0.0.1:6379 auth yourpassOK127.0.0.1:6379 pingPONG127.0.0.1:6379 Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看Redis命令参考，在这个网站上，除了Redis的命令参考，还有Redis的详细文档，其中包括了通知、事务、主从复制、持久化、哨兵、集群等内容。 说明：上面的插图来自付磊和张益军先生编著的《Redis开发与运维》一书。 127.0.0.1:6379 set username adminOK127.0.0.1:6379 get usernameadmin127.0.0.1:6379 set password 123456 ex 300OK127.0.0.1:6379 get password123456127.0.0.1:6379 ttl username(integer) -1127.0.0.1:6379 ttl password(integer) 286127.0.0.1:6379 hset stu1 name hao(integer) 0127.0.0.1:6379 hset stu1 age 38(integer) 1127.0.0.1:6379 hset stu1 gender male(integer) 1127.0.0.1:6379 hgetall stu11) name2) hao3) age4) 385) gender6) male127.0.0.1:6379 hvals stu11) hao2) 383) male127.0.0.1:6379 hmset stu2 name wang age 18 gender female tel 13566778899OK127.0.0.1:6379 hgetall stu21) name2) wang3) age4) 185) gender6) female7) tel8) 13566778899127.0.0.1:6379 lpush nums 1 2 3 4 5(integer) 5127.0.0.1:6379 lrange nums 0 -11) 52) 43) 34) 25) 1127.0.0.1:6379 lpop nums5127.0.0.1:6379 lpop nums4127.0.0.1:6379 rpop nums1127.0.0.1:6379 rpop nums2127.0.0.1:6379 sadd fruits apple banana orange apple grape grape(integer) 4127.0.0.1:6379 scard fruits(integer) 4127.0.0.1:6379 smembers fruits1) grape2) orange3) banana4) apple127.0.0.1:6379 sismember fruits apple(integer) 1127.0.0.1:6379 sismember fruits durian(integer) 0127.0.0.1:6379 sadd nums1 1 2 3 4 5(integer) 5127.0.0.1:6379 sadd nums2 2 4 6 8(integer) 4127.0.0.1:6379 sinter nums1 nums21) 22) 4127.0.0.1:6379 sunion nums1 nums21) 12) 23) 34) 45) 56) 67) 8127.0.0.1:6379 sdiff nums1 nums21) 12) 33) 5127.0.0.1:6379 zadd topsinger 5234 zhangxy 1978 chenyx 2235 zhoujl 3520 xuezq(integer) 4127.0.0.1:6379 zrange topsinger 0 -1 withscores1) chenyx2) 19783) zhoujl4) 22355) xuezq6) 35207) zhangxy8) 5234127.0.0.1:6379 zrevrange topsinger 0 -11) zhangxy2) xuezq3) zhoujl4) chenyx127.0.0.1:6379 geoadd pois 116.39738549206541 39.90862689286386 tiananmen 116.27172936413572 39.99135172904494 yiheyuan 117.27766503308104 40.65332064313784 gubeishuizhen(integer) 3127.0.0.1:6379 geodist pois tiananmen gubeishuizhen km111.5333127.0.0.1:6379 geodist pois tiananmen yiheyuan km14.1230127.0.0.1:6379 georadius pois 116.86499108288572 40.40149669363615 50 km withdist1) 1) gubeishuizhen 2) 44.7408 在Python程序中使用Redis可以使用pip安装redis模块。redis模块的核心是名为Redis的类，该类的对象代表一个Redis客户端，通过该客户端可以向Redis服务器发送命令并获取执行的结果。上面我们在Redis客户端中使用的命令基本上就是Redis对象可以接收的消息，所以如果了解了Redis的命令就可以在Python中玩转Redis。 pip3 install redispython3 import redis client = redis.Redis(host=1.2.3.4, port=6379, password=yourpass) client.set(username, admin)True client.hset(student, name, hao)1 client.hset(student, age, 38)1 client.keys(*)[busername, bstudent] client.get(username)badmin client.hgetall(student)bname: bhao, bage: b38 MongoDB概述MongoDB简介MongoDB是2009年问世的一个面向文档的数据库管理系统，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB被认为是NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。 MongoDB将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB对JSON进行了二进制处理（能够更快的定位key和value），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章《JSON and BSON》。 目前，MongoDB已经提供了对Windows、MacOS、Linux、Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python当然是其中之一。 MongoDB的安装和配置可以从MongoDB的官方下载链接下载MongoDB，官方为Windows系统提供了一个Installer程序，而Linux和MacOS则提供了压缩文件。下面简单说一下Linux系统如何安装和配置MongoDB。 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.6.5.tgzgunzip mongodb-linux-x86_64-amazon-3.6.5.tgzmkdir mongodb-3.6.5tar -xvf mongodb-linux-x86_64-amazon-3.6.5.tar --strip-components 1 -C mongodb-3.6.5/export PATH=$PATH:~/mongodb-3.6.5/binmkdir -p /data/dbmongod --bind_ip 172.18.61.2502018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] MongoDB starting : pid=1163 port=27017 dbpath=/data/db 64-bit host=iZwz97tbgo9lkabnat2lo8Z2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] db version v3.6.52018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] git version: a20ecd3e3a174162052ff99913bc2ca9a839d6182018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.0-fips29 Mar 2010...2018-06-03T18:03:28.945+0800 I NETWORK [initandlisten] waiting for connections on port 27017 说明：上面的操作中，export命令是设置PATH环境变量，这样可以在任意路径下执行mongod来启动MongoDB服务器。MongoDB默认保存数据的路径是datadb目录，为此要提前创建该目录。此外，在使用mongod启动MongoDB服务器时，–bind_ip参数用来将服务绑定到指定的IP地址，也可以用–port参数来指定端口，默认端口为27017。 MongoDB基本概念我们通过与关系型数据库进行对照的方式来说明MongoDB中的一些概念。 SQL MongoDB 解释（SQLMongoDB） database database 数据库数据库 table collection 二维表集合 row document 记录（行）文档 column field 字段（列）域 index index 索引索引 table joins — 表连接嵌套文档 primary key primary key 主键主键（_id字段） 通过Shell操作MongoDB启动服务器后可以使用交互式环境跟服务器通信，如下所示。 mongo --host 172.18.61.250MongoDB shell version v3.6.5connecting to: mongodb://172.18.61.250:27017/ 查看、创建和删除数据库。 // 显示所有数据库 show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB // 创建并切换到school数据库 use schoolswitched to db school // 删除当前数据库 db.dropDatabase() ok : 1 创建、删除和查看集合。 // 创建并切换到school数据库 use schoolswitched to db school // 创建colleges集合 db.createCollection(colleges) ok : 1 // 创建students集合 db.createCollection(students) ok : 1 // 查看所有集合 show collectionscollegesstudents // 删除colleges集合 db.colleges.drop()true 说明：在MongoDB中插入文档时如果集合不存在会自动创建集合，所以也可以按照下面的方式通过创建文档来创建集合。 文档的CRUD操作。 // 向students集合插入文档 db.students.insert(stuid: 1001, name: 骆昊, age: 38)WriteResult( nInserted : 1 ) // 向students集合插入文档 db.students.save(stuid: 1002, name: 王大锤, tel: 13012345678, gender: 男)WriteResult( nInserted : 1 ) // 查看所有文档 db.students.find() _id : ObjectId(5b13c72e006ad854460ee70b), stuid : 1001, name : 骆昊, age : 38 _id : ObjectId(5b13c790006ad854460ee70c), stuid : 1002, name : 王大锤, tel : 13012345678, gender : 男 // 更新stuid为1001的文档 db.students.update(stuid: 1001, $set: tel: 13566778899, gender: 男)WriteResult( nMatched : 1, nUpserted : 0, nModified : 1 ) // 插入或更新stuid为1003的文档 db.students.update(stuid: 1003, $set: name: 白元芳, tel: 13022223333, gender: 男, upsert=true)WriteResult( nMatched : 0, nUpserted : 1, nModified : 0, _id : ObjectId(5b13c92dd185894d7283efab)) // 查询所有文档 db.students.find().pretty() _id : ObjectId(5b13c72e006ad854460ee70b), stuid : 1001, name : 骆昊, age : 38, gender : 男, tel : 13566778899 _id : ObjectId(5b13c790006ad854460ee70c), stuid : 1002, name : 王大锤, tel : 13012345678, gender : 男 _id : ObjectId(5b13c92dd185894d7283efab), stuid : 1003, gender : 男, name : 白元芳, tel : 13022223333 // 查询stuid大于1001的文档 db.students.find(stuid: $gt: 1001).pretty() _id : ObjectId(5b13c790006ad854460ee70c), stuid : 1002, name : 王大锤, tel : 13012345678, gender : 男 _id : ObjectId(5b13c92dd185894d7283efab), stuid : 1003, gender : 男, name : 白元芳, tel : 13022223333 // 查询stuid大于1001的文档只显示name和tel字段 db.students.find(stuid: $gt: 1001, _id: 0, name: 1, tel: 1).pretty() name : 王大锤, tel : 13012345678 name : 白元芳, tel : 13022223333 // 查询name为“骆昊”或者tel为“13022223333”的文档 db.students.find($or: [name: 骆昊, tel: 13022223333], _id: 0, name: 1, tel: 1).pretty() name : 骆昊, tel : 13566778899 name : 白元芳, tel : 13022223333 // 查询学生文档跳过第1条文档只查1条文档 db.students.find().skip(1).limit(1).pretty() _id : ObjectId(5b13c790006ad854460ee70c), stuid : 1002, name : 王大锤, tel : 13012345678, gender : 男 // 对查询结果进行排序(1表示升序，-1表示降序) db.students.find(, _id: 0, stuid: 1, name: 1).sort(stuid: -1) stuid : 1003, name : 白元芳 stuid : 1002, name : 王大锤 stuid : 1001, name : 骆昊 // 在指定的一个或多个字段上创建索引 db.students.ensureIndex(name: 1) createdCollectionAutomatically : false, numIndexesBefore : 1, numIndexesAfter : 2, ok : 1 使用MongoDB可以非常方便的配置数据复制，通过冗余数据来实现数据的高可用以及灾难恢复，也可以通过数据分片来应对数据量迅速增长的需求。关于MongoDB更多的操作可以查阅官方文档 ，同时推荐大家阅读Kristina Chodorow写的《MongoDB权威指南》。 在Python程序中操作MongoDB可以通过pip安装pymongo来实现对MongoDB的操作。 pip3 install pymongopython3 from pymongo import MongoClient client = MongoClient(mongodb://127.0.0.1:27017) db = client.school for student in db.students.find():... print(学号:, student[stuid])... print(姓名:, student[name])... print(电话:, student[tel])... 学号: 1001.0姓名: 骆昊电话: 13566778899学号: 1002.0姓名: 王大锤电话: 13012345678学号: 1003.0姓名: 白元芳电话: 13022223333 db.students.find().count()3 db.students.remove()n: 3, ok: 1.0 db.students.find().count()0 coll = db.students from pymongo import ASCENDING coll.create_index([(name, ASCENDING)], unique=True)name_1 coll.insert_one(stuid: int(1001), name: 骆昊, gender: True)pymongo.results.InsertOneResult object at 0x1050cc6c8 coll.insert_many([stuid: int(1002), name: 王大锤, gender: False, stuid: int(1003), name: 白元芳, gender: True])pymongo.results.InsertManyResult object at 0x1050cc8c8 for student in coll.find(gender: True):... print(学号:, student[stuid])... print(姓名:, student[name])... print(性别:, 男 if student[gender] else 女)... 学号: 1001姓名: 骆昊性别: 男学号: 1003姓名: 白元芳性别: 男 关于PyMongo更多的知识可以通过它的官方文档进行了解，也可以使用MongoEngine这样的库来简化Python程序对MongoDB的操作，除此之外，还有以异步IO方式访问MongoDB的三方库motor都是不错的选择。","tags":["Python"],"categories":["IT技术"]},{"title":"Python-100天(二)-Python语言进阶","path":"/memoirs/20200310/python/Python-100-2/","content":"数据结构和算法 算法：解决问题的方法和步骤 评价算法的好坏：渐近时间复杂度和渐近空间复杂度。 渐近时间复杂度的大O标记： - 常量时间复杂度 - 布隆过滤器 哈希存储 - 对数时间复杂度 - 折半查找（二分查找） - 线性时间复杂度 - 顺序查找 桶排序 - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序） - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序） - 立方时间复杂度 - Floyd算法 矩阵乘法运算 - 几何级数时间复杂度 - 汉诺塔 - 阶乘时间复杂度 - 旅行经销商问题 - NP 排序算法（选择、冒泡和归并）和查找算法（顺序和折半） def select_sort(origin_items, comp=lambda x, y: x y): 简单选择排序 items = origin_items[:] for i in range(len(items) - 1): min_index = i for j in range(i + 1, len(items)): if comp(items[j], items[min_index]): min_index = j items[i], items[min_index] = items[min_index], items[i] return items def bubble_sort(origin_items, comp=lambda x, y: x y): 高质量冒泡排序(搅拌排序) items = origin_items[:] for i in range(len(items) - 1): swapped = False for j in range(i, len(items) - 1 - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] = items[j + 1], items[j] swapped = True if swapped: swapped = False for j in range(len(items) - 2 - i, i, -1): if comp(items[j - 1], items[j]): items[j], items[j - 1] = items[j - 1], items[j] swapped = True if not swapped: break return items def merge_sort(items, comp=lambda x, y: x = y): 归并排序(分治法) if len(items) 2: return items[:] mid = len(items) // 2 left = merge_sort(items[:mid], comp) right = merge_sort(items[mid:], comp) return merge(left, right, comp)def merge(items1, items2, comp): 合并(将两个有序的列表合并成一个有序的列表) items = [] index1, index2 = 0, 0 while index1 len(items1) and index2 len(items2): if comp(items1[index1], items2[index2]): items.append(items1[index1]) index1 += 1 else: items.append(items2[index2]) index2 += 1 items += items1[index1:] items += items2[index2:] return items def seq_search(items, key): 顺序查找 for index, item in enumerate(items): if item == key: return index return -1 def bin_search(items, key): 折半查找 start, end = 0, len(items) - 1 while start = end: mid = (start + end) // 2 if key items[mid]: start = mid + 1 elif key items[mid]: end = mid - 1 else: return mid return -1 使用生成式（推导式）语法 prices = AAPL: 191.88, GOOG: 1186.96, IBM: 149.24, ORCL: 48.44, ACN: 166.89, FB: 208.09, SYMC: 21.29# 用股票价格大于100元的股票构造一个新的字典prices2 = key: value for key, value in prices.items() if value 100print(prices2) 说明：生成式（推导式）可以用来生成列表、集合和字典。 嵌套的列表 names = [关羽, 张飞, 赵云, 马超, 黄忠]courses = [语文, 数学, 英语]# 录入五个学生三门课程的成绩# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit# scores = [[None] * len(courses)] * len(names)scores = [[None] * len(courses) for _ in range(len(names))]for row, name in enumerate(names): for col, course in enumerate(courses): scores[row][col] = float(input(f请输入name的course成绩: )) print(scores) Python Tutor - VISUALIZE CODE AND GET LIVE HELP heapq、itertools等的用法 从列表中找出最大的或最小的N个元素堆结构(大根堆/小根堆)import heapqlist1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]list2 = [ name: IBM, shares: 100, price: 91.1, name: AAPL, shares: 50, price: 543.22, name: FB, shares: 200, price: 21.09, name: HPQ, shares: 35, price: 31.75, name: YHOO, shares: 45, price: 16.35, name: ACME, shares: 75, price: 115.65]print(heapq.nlargest(3, list1))print(heapq.nsmallest(3, list1))print(heapq.nlargest(2, list2, key=lambda x: x[price]))print(heapq.nlargest(2, list2, key=lambda x: x[shares])) 迭代工具 - 排列 / 组合 / 笛卡尔积import itertoolsitertools.permutations(ABCD)itertools.combinations(ABCDE, 3)itertools.product(ABCD, 123) collections模块下的工具类 找出序列中出现次数最多的元素from collections import Counterwords = [ look, into, my, eyes, look, into, my, eyes, the, eyes, the, eyes, the, eyes, not, around, the, eyes, dont, look, around, the, eyes, look, into, my, eyes, youre, under]counter = Counter(words)print(counter.most_common(3)) 常用算法： 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。 贪婪法 - 在对问题求解时，总是做出在当前看来 最好的选择，不追求最优解，快速找到满意解。 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。 穷举法例子：百钱百鸡和五人分鱼。 # 公鸡5元一只 母鸡3元一只 小鸡1元三只# 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只for x in range(20): for y in range(33): z = 100 - x - y if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0: print(x, y, z)# A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉# 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份# B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份# 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼fish = 6while True: total = fish enough = True for _ in range(5): if (total - 1) % 5 == 0: total = (total - 1) // 5 * 4 else: enough = False break if enough: print(fish) break fish += 5 贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。 | 名称 | 价格（美元） | 重量（kg） | | :----: | :----------: | :--------: | | 电脑 | 200 | 20 | | 收音机 | 20 | 4 | | 钟 | 175 | 10 | | 花瓶 | 50 | 2 | | 书 | 10 | 1 | | 油画 | 90 | 9 | 贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。输入：20 6电脑 200 20收音机 20 4钟 175 10花瓶 50 2书 10 1油画 90 9class Thing(object): 物品 def __init__(self, name, price, weight): self.name = name self.price = price self.weight = weight @property def value(self): 价格重量比 return self.price / self.weightdef input_thing(): 输入物品信息 name_str, price_str, weight_str = input().split() return name_str, int(price_str), int(weight_str)def main(): 主函数 max_weight, num_of_things = map(int, input().split()) all_things = [] for _ in range(num_of_things): all_things.append(Thing(*input_thing())) all_things.sort(key=lambda x: x.value, reverse=True) total_weight = 0 total_price = 0 for thing in all_things: if total_weight + thing.weight = max_weight: print(f小偷拿走了thing.name) total_weight += thing.weight total_price += thing.price print(f总价值: total_price美元)if __name__ == __main__: main() 分治法例子：快速排序。 快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大def quick_sort(origin_items, comp=lambda x, y: x = y): items = origin_items[:] _quick_sort(items, 0, len(items) - 1, comp) return itemsdef _quick_sort(items, start, end, comp): if start end: pos = _partition(items, start, end, comp) _quick_sort(items, start, pos - 1, comp) _quick_sort(items, pos + 1, end, comp)def _partition(items, start, end, comp): pivot = items[end] i = start - 1 for j in range(start, end): if comp(items[j], pivot): i += 1 items[i], items[j] = items[j], items[i] items[i + 1], items[end] = items[end], items[i + 1] return i + 1 回溯法例子：骑士巡逻。 递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。import sysimport timeSIZE = 5total = 0def print_board(board): for row in board: for col in row: print(str(col).center(4), end=) print()def patrol(board, row, col, step=1): if row = 0 and row SIZE and \\ col = 0 and col SIZE and \\ board[row][col] == 0: board[row][col] = step if step == SIZE * SIZE: global total total += 1 print(f第total种走法: ) print_board(board) patrol(board, row - 2, col - 1, step + 1) patrol(board, row - 1, col - 2, step + 1) patrol(board, row + 1, col - 2, step + 1) patrol(board, row + 2, col - 1, step + 1) patrol(board, row + 2, col + 1, step + 1) patrol(board, row + 1, col + 2, step + 1) patrol(board, row - 1, col + 2, step + 1) patrol(board, row - 2, col + 1, step + 1) board[row][col] = 0def main(): board = [[0] * SIZE for _ in range(SIZE)] patrol(board, SIZE - 1, SIZE - 1)if __name__ == __main__: main() 动态规划例子1：斐波拉切数列。（不使用动态规划将会是几何级数复杂度） 动态规划 - 适用于有重叠子问题和最优子结构性质的问题使用动态规划方法所耗时间往往远少于朴素解法(用空间换取时间)def fib(num, temp=): 用递归计算Fibonacci数 if num in (1, 2): return 1 try: return temp[num] except KeyError: temp[num] = fib(num - 1) + fib(num - 2) return temp[num] 动态规划例子2：子列表元素之和的最大值。（使用动态规划可以避免二重循环） 说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如： 输入：1 -2 3 5 -3 2 输出：8 输入：0 -2 3 5 -1 2 输出：9 输入：-9 -2 -3 -5 -3 输出：-2 def main(): items = list(map(int, input().split())) size = len(items) overall, partial = , overall[size - 1] = partial[size - 1] = items[size - 1] for i in range(size - 2, -1, -1): partial[i] = max(items[i], partial[i + 1] + items[i]) overall[i] = max(partial[i], overall[i + 1]) print(overall[0])if __name__ == __main__: main() 函数的使用方式 将函数视为“一等公民” 函数可以赋值给变量 函数可以作为函数的参数 函数可以作为函数的返回值 高阶函数的用法（filter、map以及它们的替代品） items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))items2 = [x ** 2 for x in range(1, 10) if x % 2] 位置参数、可变参数、关键字参数、命名关键字参数 参数的元信息（代码可读性问题） 匿名函数和内联函数的用法（lambda函数） 闭包和作用域问题 Python搜索变量的LEGB顺序（Local – Embedded – Global – Built-in） global和nonlocal关键字的作用global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。nonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。 装饰器函数（使用装饰器和取消装饰器） 例子：输出函数执行时间的装饰器。 def record_time(func): 自定义装饰函数的装饰器 @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) print(ffunc.__name__: time() - start秒) return result return wrapper 如果装饰器不希望跟print函数耦合，可以编写带参数的装饰器。 from functools import wrapsfrom time import timedef record(output): 自定义带参数的装饰器def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapperreturn decorate from functools import wrapsfrom time import timeclass Record(): 自定义装饰器类(通过__call__魔术方法使得对象可以当成函数调用) def __init__(self, output): self.output = output def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) self.output(func.__name__, time() - start) return result return wrapper 说明：由于对带装饰功能的函数添加了@wraps装饰器，可以通过func.__wrapped__方式获得被装饰之前的函数或类来取消装饰器的作用。 例子：用装饰器来实现单例模式。 from functools import wrapsdef singleton(cls): 装饰类的装饰器 instances = @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass President(): 总统(单例类) pass 说明：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？ from functools import wrapsfrom threading import Lockdef singleton(cls): 线程安全的单例装饰器 instances = locker = Lock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with locker: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper 面向对象相关知识 三大支柱：封装、继承、多态 例子：工资结算系统。 月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成from abc import ABCMeta, abstractmethodclass Employee(metaclass=ABCMeta): 员工(抽象类) def __init__(self, name): self.name = name @abstractmethod def get_salary(self): 结算月薪(抽象方法) passclass Manager(Employee): 部门经理 def get_salary(self): return 15000.0class Programmer(Employee): 程序员 def __init__(self, name, working_hour=0): self.working_hour = working_hour super().__init__(name) def get_salary(self): return 200.0 * self.working_hourclass Salesman(Employee): 销售员 def __init__(self, name, sales=0.0): self.sales = sales super().__init__(name) def get_salary(self): return 1800.0 + self.sales * 0.05class EmployeeFactory(): 创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合） @staticmethod def create(emp_type, *args, **kwargs): 创建员工 emp_type = emp_type.upper() emp = None if emp_type == M: emp = Manager(*args, **kwargs) elif emp_type == P: emp = Programmer(*args, **kwargs) elif emp_type == S: emp = Salesman(*args, **kwargs) return empdef main(): 主函数 emps = [ EmployeeFactory.create(M, 曹操), EmployeeFactory.create(P, 荀彧, 120), EmployeeFactory.create(P, 郭嘉, 85), EmployeeFactory.create(S, 典韦, 123000), ] for emp in emps: print(%s: %.2f元 % (emp.name, emp.get_salary()))if __name__ == __main__: main() 类与类之间的关系 is-a关系：继承 has-a关系：关联 聚合 合成 use-a关系：依赖 例子：扑克游戏。 经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择from enum import Enum, uniqueimport random@uniqueclass Suite(Enum): 花色 SPADE, HEART, CLUB, DIAMOND = range(4) def __lt__(self, other): return self.value other.valueclass Card(): 牌 def __init__(self, suite, face): 初始化方法 self.suite = suite self.face = face def show(self): 显示牌面 suites = [♠️, ♥️, ♣️, ♦️] faces = [, A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K] return fsuites[self.suite.value] faces[self.face] def __str__(self): return self.show() def __repr__(self): return self.show()class Poker(): 扑克 def __init__(self): self.index = 0 self.cards = [Card(suite, face) for suite in Suite for face in range(1, 14)] def shuffle(self): 洗牌（随机乱序） random.shuffle(self.cards) self.index = 0 def deal(self): 发牌 card = self.cards[self.index] self.index += 1 return card @property def has_more(self): return self.index len(self.cards)class Player(): 玩家 def __init__(self, name): self.name = name self.cards = [] def get_one(self, card): 摸一张牌 self.cards.append(card) def sort(self, comp=lambda card: (card.suite, card.face)): 整理手上的牌 self.cards.sort(key=comp)def main(): 主函数 poker = Poker() poker.shuffle() players = [Player(东邪), Player(西毒), Player(南帝), Player(北丐)] while poker.has_more: for player in players: player.get_one(poker.deal()) for player in players: player.sort() print(player.name, end=: ) print(player.cards)if __name__ == __main__: main() 说明：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。 对象的复制（深复制深拷贝深度克隆和浅复制浅拷贝影子克隆） 垃圾回收、循环引用和弱引用Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。 typedef struct_object /* 引用计数 */ int ob_refcnt; /* 对象指针 */ struct_typeobject *ob_type; PyObject; /* 增加引用计数的宏定义 */#define Py_INCREF(op) ((op)-ob_refcnt++)/* 减少引用计数的宏定义 */#define Py_DECREF(op) \\ //减少计数 if (--(op)-ob_refcnt != 0) \\ ; \\ else \\ __Py_Dealloc((PyObject *)(op)) 导致引用计数+1的情况： - 对象被创建，例如a = 23 - 对象被引用，例如b = a - 对象被作为参数，传入到一个函数中，例如f(a) - 对象作为一个元素，存储在容器中，例如list1 = [a, a] 导致引用计数-1的情况： - 对象的别名被显式销毁，例如`del a` - 对象的别名被赋予新的对象，例如`a = 24` - 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会） - 对象所在的容器被销毁，或从容器中删除对象 引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。 # 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效# 如果不想造成循环引用可以使用弱引用list1 = []list2 = [] list1.append(list2)list2.append(list1) 以下情况会导致垃圾回收： - 调用`gc.collect()` - gc模块的计数器达到阀值 - 程序退出 如果循环引用中两个对象都定义了`__del__`方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的`__del__`方法，这个问题在Python 3.6中得到了解决。 也可以通过`weakref`模块构造弱引用的方式来解决循环引用的问题。 魔法属性和方法（请参考《Python魔法方法指南》） 有几个小问题请大家思考： - 自定义的对象能不能使用运算符做运算？ - 自定义的对象能不能放到set中？能去重吗？ - 自定义的对象能不能作为dict的键？ - 自定义的对象能不能使用上下文语法？ 混入（Mixin） 例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。 class SetOnceMappingMixin: 自定义混入类 __slots__ = () def __setitem__(self, key, value): if key in self: raise KeyError(str(key) + already set) return super().__setitem__(key, value)class SetOnceDict(SetOnceMappingMixin, dict): 自定义字典 passmy_dict= SetOnceDict()try: my_dict[username] = jackfrued my_dict[username] = hellokittyexcept KeyError: passprint(my_dict) 元编程和元类 例子：用元类实现单例模式。 import threadingclass SingletonMeta(type): 自定义元类 def __init__(cls, *args, **kwargs): cls.__instance = None cls.__lock = threading.Lock() super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: with cls.__lock: if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instanceclass President(metaclass=SingletonMeta): 总统(单例类) pass 面向对象设计原则 单一职责原则 （SRP）- 一个类只做该做的事情（类的设计要高内聚） 开闭原则 （OCP）- 软件实体应该对扩展开发对修改关闭 依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化） 里氏替换原则（LSP） - 任何时候可以用子类对象替换掉父类对象 接口隔离原则（ISP）- 接口要小而专不要大而全（Python中没有接口的概念） 合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码 最少知识原则（迪米特法则，LoD）- 不要给没有必然联系的对象发消息 说明：上面加粗的字母放在一起称为面向对象的SOLID原则。 GoF设计模式 创建型模式：单例、工厂、建造者、原型 结构型模式：适配器、门面（外观）、代理 行为型模式：迭代器、观察者、状态、策略 例子：可插拔的哈希算法。 class StreamHasher(): 哈希摘要生成器(策略模式) def __init__(self, alg=md5, size=4096): self.size = size alg = alg.lower() self.hasher = getattr(__import__(hashlib), alg.lower())() def __call__(self, stream): return self.to_digest(stream) def to_digest(self, stream): 生成十六进制形式的摘要 for buf in iter(lambda: stream.read(self.size), b): self.hasher.update(buf) return self.hasher.hexdigest()def main(): 主函数 hasher1 = StreamHasher() with open(Python-3.7.1.tgz, rb) as stream: print(hasher1.to_digest(stream)) hasher2 = StreamHasher(sha1) with open(Python-3.7.1.tgz, rb) as stream: print(hasher2(stream))if __name__ == __main__: main() 迭代器和生成器 和迭代器相关的魔术方法（__iter__和__next__） 两种创建生成器的方式（生成器表达式和yield关键字） def fib(num): 生成器 a, b = 0, 1 for _ in range(num): a, b = b, a + b yield aclass Fib(object): 迭代器 def __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx self.num: self.a, self.b = self.b, self.a + self.b self.idx += 1 return self.a raise StopIteration() 并发编程Python中实现并发编程的三种方案：多线程、多进程和异步IO。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。 面试题：进程和线程的区别和联系？进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程线程 - 操作系统分配CPU的基本单位并发编程（concurrent programming）1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行2. 改善用户体验 - 让耗时间的操作不会造成程序的假死import globimport osimport threadingfrom PIL import ImagePREFIX = thumbnailsdef generate_thumbnail(infile, size, format=PNG): 生成指定图片文件的缩略图file, ext = os.path.splitext(infile)file = file[file.rfind(/) + 1:]outfile = fPREFIX/file_size[0]_size[1].extimg = Image.open(infile)img.thumbnail(size, Image.ANTIALIAS)img.save(outfile, format)def main(): 主函数if not os.path.exists(PREFIX): os.mkdir(PREFIX)for infile in glob.glob(images/*.png): for size in (32, 64, 128): # 创建并启动线程 threading.Thread( target=generate_thumbnail, args=(infile, (size, size)) ).start() if __name__ == __main__:main() 多个线程竞争资源的情况 多线程程序如果没有竞争资源处理起来通常也比较简单当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱说明：临界资源就是被多个线程竞争的资源import timeimport threadingfrom concurrent.futures import ThreadPoolExecutorclass Account(object): 银行账户 def __init__(self): self.balance = 0.0 self.lock = threading.Lock() def deposit(self, money): # 通过锁保护临界资源 with self.lock: new_balance = self.balance + money time.sleep(0.001) self.balance = new_balanceclass AddMoneyThread(threading.Thread): 自定义线程类 def __init__(self, account, money): self.account = account self.money = money # 自定义线程的初始化方法中必须调用父类的初始化方法 super().__init__() def run(self): # 线程启动之后要执行的操作 self.account.deposit(self.money)def main(): 主函数 account = Account() # 创建线程池 pool = ThreadPoolExecutor(max_workers=10) futures = [] for _ in range(100): # 创建线程的第1种方式 # threading.Thread( # target=account.deposit, args=(1, ) # ).start() # 创建线程的第2种方式 # AddMoneyThread(account, 1).start() # 创建线程的第3种方式 # 调用线程池中的线程来执行特定的任务 future = pool.submit(account.deposit, 1) futures.append(future) # 关闭线程池 pool.shutdown() for future in futures: future.result() print(account.balance)if __name__ == __main__: main() 修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用threading模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示： 多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）多个线程竞争多个资源（线程数资源数） - 信号量（Semaphore）多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Conditionfrom concurrent.futures import ThreadPoolExecutorfrom random import randintfrom time import sleepimport threadingclass Account(): 银行账户 def __init__(self, balance=0): self.balance = balance lock = threading.Lock() self.condition = threading.Condition(lock) def withdraw(self, money): 取钱 with self.condition: while money self.balance: self.condition.wait() new_balance = self.balance - money sleep(0.001) self.balance = new_balance def deposit(self, money): 存钱 with self.condition: new_balance = self.balance + money sleep(0.001) self.balance = new_balance self.condition.notify_all()def add_money(account): while True: money = randint(5, 10) account.deposit(money) print(threading.current_thread().name, :, money, ====, account.balance) sleep(0.5)def sub_money(account): while True: money = randint(10, 30) account.withdraw(money) print(threading.current_thread().name, :, money, ====, account.balance) sleep(1)def main(): account = Account() with ThreadPoolExecutor(max_workers=10) as pool: for _ in range(5): pool.submit(add_money, account) pool.submit(sub_money, account)if __name__ == __main__: main() 多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。 多进程和进程池的使用多线程因为GIL的存在不能够发挥CPU的多核特性对于计算密集型任务应该考虑使用多进程time python3 example22.pyreal 0m11.512suser 0m39.319ssys 0m0.169s使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPUimport concurrent.futuresimport mathPRIMES = [ 1116281, 1297337, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419] * 5def is_prime(n): 判断素数 if n % 2 == 0: return False sqrt_n = int(math.floor(math.sqrt(n))) for i in range(3, sqrt_n + 1, 2): if n % i == 0: return False return Truedef main(): 主函数 with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print(%d is prime: %s % (number, prime))if __name__ == __main__: main() 说明：多线程和多进程的比较。 以下情况需要使用多线程： 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。 程序会花费大量时间在IO操作上，没有太多并行计算的需求且不需占用太多的内存。 以下情况需要使用多进程： 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。 程序的输入可以并行的分成块，并且可以将运算结果合并。 程序在内存使用方面没有任何限制且不强依赖于IO操作（如：读写文件、套接字等）。 异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者future对象来获取任务执行的结果。Python 3通过asyncio模块和await和async关键字（在Python 3.7中正式被列为关键字）来支持异步处理。 异步I/O - async / awaitimport asynciodef num_generator(m, n): 指定范围的数字生成器 yield from range(m, n + 1)async def prime_filter(m, n): 素数过滤器 primes = [] for i in num_generator(m, n): flag = True for j in range(2, int(i ** 0.5 + 1)): if i % j == 0: flag = False break if flag: print(Prime =, i) primes.append(i) await asyncio.sleep(0.001) return tuple(primes)async def square_mapper(m, n): 平方映射器 squares = [] for i in num_generator(m, n): print(Square =, i * i) squares.append(i * i) await asyncio.sleep(0.001) return squaresdef main(): 主函数 loop = asyncio.get_event_loop() future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100)) future.add_done_callback(lambda x: print(x.result())) loop.run_until_complete(future) loop.close()if __name__ == __main__: main() 说明：上面的代码使用get_event_loop函数获得系统默认的事件循环，通过gather函数可以获得一个future对象，future对象的add_done_callback可以添加执行完成时的回调函数，loop对象的run_until_complete方法可以等待通过future对象获得协程执行结果。 Python中有一个名为aiohttp的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟asyncio模块一起工作，并提供了对Future对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。 import asyncioimport reimport aiohttpPATTERN = re.compile(r\\title\\(?Ptitle.*)\\\\/title\\)async def fetch_page(session, url): async with session.get(url, ssl=False) as resp: return await resp.text()async def show_title(url): async with aiohttp.ClientSession() as session: html = await fetch_page(session, url) print(PATTERN.search(html).group(title))def main(): urls = (https://www.python.org/, https://git-scm.com/, https://www.jd.com/, https://www.taobao.com/, https://www.douban.com/) loop = asyncio.get_event_loop() tasks = [show_title(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close()if __name__ == __main__: main() 说明：异步IO与多进程的比较。 当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。 Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。 要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。","tags":["Python"],"categories":["IT技术"]},{"title":"Python-100天(一)","path":"/memoirs/20200305/python/Python-100-1/","content":"之前Python就已经学过了，Flask也玩的一溜一溜的。但是间隔时间有些长，所以就找个一个项目重新温习一下，顺便记录一下。这个系列文章会根据 Python - 100天 的流程走下去，当然其中有一些重复性的我就不介绍了，Django这个就不介绍了，因为跟Flask重复了，而且Django体量太大，不适合拿来用于学习。 Python简介Python的历史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了完整的垃圾回收，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。 目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为《Python简史》的博文。 Python的优缺点Python的优点很多，简单的可以总结为以下几点。 简单和明确，做一件事只有一种方法。 学习曲线低，跟其他很多语言相比，Python更容易上手。 开放源代码，拥有强大的社区和生态圈。 解释型语言，天生具有平台可移植性。 对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。 可扩展性和可嵌入性，例如在Python中可以调用C/C++代码。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。 Python的缺点主要集中在以下几点。 执行效率稍低，因此计算密集型任务可以由C/C++编写。 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 Python的应用领域目前Python在Web应用开发、云基础设施、DevOps、网络数据采集（爬虫）、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、自然语言处理、图像识别等一系列相关的职位。 100天计划 - Day01~15基础知识就不详细介绍了，这个可以在下面这个网站上学习。Python教程 Day01~15 - Python语言基础 当然也可以查看已经整理好的简要文档 Day01 - 初识Python Python简介 - Python的历史 Python的优缺点 Python的应用领域 搭建编程环境 - Windows环境 Linux环境 MacOS环境 从终端运行Python程序 - Hello, world print函数 运行程序 使用IDLE - 交互式环境(REPL) 编写多行代码 运行程序 退出IDLE 注释 - 注释的作用 单行注释 多行注释 Day02 - 语言元素 程序和进制 - 指令和程序 冯诺依曼机 二进制和十进制 八进制和十六进制 变量和类型 - 变量的命名 变量的使用 input函数 检查变量类型 类型转换 数字和字符串 - 整数 浮点数 复数 字符串 字符串基本操作 字符编码 运算符 - 数学运算符 赋值运算符 比较运算符 逻辑运算符 身份运算符 运算符的优先级 应用案例 - 华氏温度转换成摄氏温度 输入圆的半径计算周长和面积 输入年份判断是否是闰年 Day03 - 分支结构 分支结构的应用场景 - 条件 缩进 代码块 流程图 if语句 - 简单的if if-else结构 if-elif-else结构 嵌套的if 应用案例 - 用户身份验证 英制单位与公制单位互换 掷骰子决定做什么 百分制成绩转等级制 分段函数求值 输入三条边的长度如果能构成三角形就计算周长和面积 Day04 - 循环结构 循环结构的应用场景 - 条件 缩进 代码块 流程图 while循环 - 基本结构 break语句 continue语句 for循环 - 基本结构 range类型 循环中的分支结构 嵌套的循环 提前结束程序 应用案例 - 1~100求和 判断素数 猜数字游戏 打印九九表 打印三角形图案 猴子吃桃 百钱百鸡 Day05 - 05.构造程序逻辑 经典案例：水仙花数 百钱百鸡 Craps赌博游戏 练习题目：斐波那契数列 完美数 素数 Day06 - 函数和模块的使用 函数的作用 - 代码的坏味道 用函数封装功能模块 定义函数 - def语句 函数名 参数列表 return语句 调用自定义函数 调用函数 - Python内置函数 导入模块和函数 函数的参数 - 默认参数 可变参数 关键字参数 命名关键字参数 函数的返回值 - 没有返回值 返回单个值 返回多个值 作用域问题 - 局部作用域 嵌套作用域 全局作用域 内置作用域 和作用域相关的关键字 用模块管理函数 - 模块的概念 用自定义模块管理函数 命名冲突的时候会怎样（同一个模块和不同的模块） Day07 - 字符串和常用数据结构 字符串的使用 - 计算长度 下标运算 切片 常用方法 列表基本用法 - 定义列表 用下表访问元素 下标越界 添加元素 删除元素 修改元素 切片 循环遍历 列表常用操作 - 连接 复制(复制元素和复制数组) 长度 排序 倒转 查找 生成列表 - 使用range创建数字列表 生成表达式 生成器 元组的使用 - 定义元组 使用元组中的值 修改元组变量 元组和列表转换 集合基本用法 - 集合和列表的区别 创建集合 添加元素 删除元素 清空 集合常用操作 - 交集 并集 差集 对称差 子集 超集 字典的基本用法 - 字典的特点 创建字典 添加元素 删除元素 取值 清空 字典常用操作 - keys()方法 values()方法 items()方法 setdefault()方法 基础练习 - 跑马灯效果 列表找最大元素 统计考试成绩的平均分 Fibonacci数列 杨辉三角 综合案例 - 双色球选号 井字棋 Day08 - 面向对象编程基础 类和对象 - 什么是类 什么是对象 面向对象其他相关概念 定义类 - 基本结构 属性和方法 构造器 析构器 __str__方法 使用对象 - 创建对象 给对象发消息 面向对象的四大支柱 - 抽象 封装 继承 多态 基础练习 - 定义学生类 定义时钟类 定义图形类 定义汽车类 Day09 - 面向对象进阶 属性 - 类属性 实例属性 属性访问器 属性修改器 属性删除器 使用__slots__ 类中的方法 - 实例方法 类方法 静态方法 运算符重载 - __add__ __sub__ __or__ __getitem__ __setitem__ __len__ __repr__ __gt__ __lt__ __le__ __ge__ __eq__ __ne__ __contains__ 类(的对象)之间的关系 - 关联 继承 依赖 继承和多态 - 什么是继承 继承的语法 调用父类方法 方法重写 类型判定 多重继承 菱形继承(钻石继承)和C3算法 综合案例 - 工资结算系统 图书自动折扣系统 自定义分数类 Day10 - 图形用户界面和游戏开发 使用tkinter开发GUI程序 使用pygame三方库开发游戏应用 “大球吃小球”游戏 Day11 - 文件和异常 读文件 - 读取整个文件 逐行读取 文件路径 写文件 - 覆盖写入 追加写入 文本文件 二进制文件 异常处理 - 异常机制的重要性 try-except代码块 else代码块 finally代码块 内置异常类型 异常栈 raise语句 数据持久化 - CSV文件概述 csv模块的应用 JSON数据格式 json模块的应用 Day12 - 字符串和正则表达式 字符串高级操作 - 转义字符 原始字符串 多行字符串 in和 not in运算符 is开头的方法 join和split方法 strip相关方法 pyperclip模块 不变字符串和可变字符串 StringIO的使用 正则表达式入门 - 正则表达式的作用 元字符 转义 量词 分组 零宽断言 贪婪匹配与惰性匹配懒惰 使用re模块实现正则表达式操作（匹配、搜索、替换、捕获） 使用正则表达式 - re模块 compile函数 group和groups方法 match方法 search方法 findall和finditer方法 sub和subn方法 split方法 应用案例 - 使用正则表达式验证输入的字符串 Day13 - 进程和线程 进程和线程的概念 - 什么是进程 什么是线程 多线程的应用场景 使用进程 - fork函数 multiprocessing模块 进程池 进程间通信 使用线程 - thread模块 threading模块 Thread类 Lock类 Condition类 线程池 Day14 - 网络编程入门和网络应用开发 计算机网络基础 - 计算机网络发展史 “TCP-IP”模型 IP地址 端口 协议 其他相关概念 网络应用模式 - “客户端-服务器”模式 “浏览器-服务器”模式 基于HTTP协议访问网络资源 - 网络API概述 访问URL requests模块 解析JSON格式数据 Python网络编程 - 套接字的概念 socket模块 socket函数 创建TCP服务器 创建TCP客户端 创建UDP服务器 创建UDP客户端 SocketServer模块 电子邮件 - SMTP协议 POP3协议 IMAP协议 smtplib模块 poplib模块 imaplib模块 短信服务 - 调用短信服务网关 Day15 - 图像和办公文档处理 用Pillow处理图片 - 图片读写 图片合成 几何变换 色彩转换 滤镜效果 读写Word文档 - 文本内容的处理 段落 页眉和页脚 样式的处理 读写Excel文件 - xlrd模块 xlwt模块 生成PDF文件 - pypdf2模块 reportlab模块 第一篇我们就扯一些稀奇古怪的东西 Python参考书籍先列出一些Python学习的参考书籍 入门读物 《Python基础教程》（Beginning Python From Novice to Professional） 《Python学习手册》（Learning Python） 《Python编程》（Programming Python） 《Python Cookbook》 《Python程序设计》（Python Programming: An Introduction to Computer Science） 《Modern Python Cookbook》 进阶读物 《Python核心编程》（Core Python Applications Programming） 《流畅的Python》（Fluent Python） 《Effective Python：编写高质量Python代码的59个有效方法》（Effective Python 59 Specific Ways to Write Better Python） 《Python设计模式》（Learning Python Design Patterns） 《Python高级编程》（Expert Python Programming） 《Python性能分析与优化》（Mastering Python High Performance） Web框架 《Django基础教程》（Tango with Django） 《轻量级Django》（Lightweight Django） 《Python Web开发：测试驱动方法》（Test-Driven Development with Python） 《Web Development with Django Cookbook》 《Test-Driven Development with Django》 《Django Project Blueprints 》 《Flask Web开发：基于Python的Web应用开发实战》（Flask Web Development: Developing Web Applications with Python） 《深入理解Flask》（Mastering Flask） 爬虫开发 《用Python写网络爬虫》（Web Scraping with Python） 《精通Python爬虫框架Scrapy》（Learning Scrapy） 《Python网络数据采集》（Web Scraping with Python） 《Python爬虫开发与项目实战》 《Python 3网络爬虫开发实战》 数据分析 《利用Python进行数据分析》（Python for Data Analysis） 《Python数据科学手册》（Python Data Science Handbook） 《Python金融大数据分析》（Python for Finance） 《Python数据可视化编程实战》（Python Data Visualization Cookbook） 《Python数据处理》（Data Wrangling with Python） 机器学习 《Python机器学习基础教程》（Introduction to Machine Learning with Python） 《Python机器学习实践指南》（Python Machine Learning Blueprints） 《Python Machine Learning Case Studies》 《Python机器学习实践：测试驱动的开发方法》（Thoughtful Machine Learning with Python A Test Driven Approach） 《Python机器学习经典实例》（Python Machine Learning Cookbook） 《TensorFlow：实战Google深度学习框架》 Python编程惯例“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。 让代码既可以被导入又可以被执行。 if __name__ == __main__: 用下面的方式判断逻辑“真”或“假”。 if x:if not x: 好的代码： name = jackfruedfruits = [apple, orange, grape]owners = 1001: 骆昊, 1002: 王大锤if name and fruits and owners: print(I love fruits!) 不好的代码： name = jackfruedfruits = [apple, orange, grape]owners = 1001: 骆昊, 1002: 王大锤if name != and len(fruits) 0 and owners != : print(I love fruits!) 善于使用in运算符。 if x in items: # 包含for x in items: # 迭代 好的代码： name = Hao LUOif L in name: print(The name has an L in it.) 不好的代码： name = Hao LUOif name.find(L) != -1: print(This name has an L in it!) 不使用临时变量交换两个值。 a, b = b, a 用序列构建字符串。 好的代码： chars = [j, a, c, k, f, r, u, e, d]name = .join(chars)print(name) # jackfrued 不好的代码： chars = [j, a, c, k, f, r, u, e, d]name = for char in chars: name += charprint(name) # jackfrued EAFP优于LBYL。 EAFP - Easier to Ask Forgiveness than Permission. LBYL - Look Before You Leap. 好的代码： d = x: 5try: value = int(d[x]) print(value)except (KeyError, TypeError, ValueError): value = None 不好的代码： d = x: 5if x in d and isinstance(d[x], str) \\and d[x].isdigit(): value = int(d[x]) print(value)else: value = None 使用enumerate进行迭代。 好的代码： fruits = [orange, grape, pitaya, blueberry]for index, fruit in enumerate(fruits):print(index, :, fruit) 不好的代码： fruits = [orange, grape, pitaya, blueberry]index = 0for fruit in fruits: print(index, :, fruit) index += 1 用生成式生成列表。 好的代码： data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num 10]print(result) # [60, 45, 33] 不好的代码： data = [7, 20, 3, 15, 11]result = []for i in data: if i 10: result.append(i * 3)print(result) # [60, 45, 33] 用zip组合键和值来创建字典。 好的代码： keys = [1001, 1002, 1003]values = [骆昊, 王大锤, 白元芳]d = dict(zip(keys, values))print(d) 不好的代码： keys = [1001, 1002, 1003]values = [骆昊, 王大锤, 白元芳]d = for i, key in enumerate(keys): d[key] = values[i]print(d) 说明：这篇文章的内容来自于网络，有兴趣的读者可以阅读原文。 PEP8风格指南PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。 空格的使用 使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。 标识符命名PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。 表达式和语句在Python之禅（可以使用import this查看）中有这么一句名言：**”There should be one– and preferably only one –obvious way to do it.”**，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。 Zen of Python（Python之禅） Beautiful is better than ugly. （优美比丑陋好）Explicit is better than implicit.（清晰比晦涩好）Simple is better than complex.（简单比复杂好）Complex is better than complicated.（复杂比错综复杂好）Flat is better than nested.（扁平比嵌套好）Sparse is better than dense.（稀疏比密集好）Readability counts.（可读性很重要）Special cases aren’t special enough to break the rules.（特殊情况也不应该违反这些规则）Although practicality beats purity.（但现实往往并不那么完美）Errors should never pass silently.（异常不应该被静默处理）Unless explicitly silenced.（除非你希望如此）In the face of ambiguity, refuse the temptation to guess.（遇到模棱两可的地方，不要胡乱猜测）There should be one– and preferably only one –obvious way to do it.（肯定有一种通常也是唯一一种最佳的解决方案）Although that way may not be obvious at first unless you’re Dutch.（虽然这种方案并不是显而易见的，因为你不是那个荷兰人^这里指的是Python之父Guido^）Now is better than never.（现在开始做比不做好）Although never is often better than *right* now.（不做比盲目去做好^极限编程中的YAGNI原则^）If the implementation is hard to explain, it’s a bad idea.（如果一个实现方案难于理解，它就不是一个好的方案）If the implementation is easy to explain, it may be a good idea.（如果一个实现方案易于理解，它很有可能是一个好的方案）Namespaces are one honking great idea – let’s do more of those!（命名空间非常有用，我们应当多加利用）","tags":["Python"],"categories":["IT技术"]},{"title":"逆向工程进阶","path":"/memoirs/20200217/reverse-progression/","content":"前言如果您是iOS开发，具备相应的开发储备，除了需要了解逆向的基础，同样需要知道程序的运行原理。 下面会介绍逆向工程相关的进阶知识，理论知识比较枯燥，但是确实必须要掌握的。 程序加载在编写一个应用程序时，我们看到的入口函数是main.m里面的main函数，因此我们一般会以为程序是从这里开始执行的。其实不然，程序在执行main函数之前已经执行了+load和constructor构造函数。接下来，让我们一起看看在main函数执行之前都发生了什么。 dyld简介程序在运行时会依赖很多系统动态库。系统动态库会通过动态库加载器（默认是/usr/lib/dyld）加载到内存中，系统内核在做好启动程序的准备工作之后就会将工作交给dyld。由于很多程序都需要使用系统动态库，不可能每个程序加载时都去加载所有的系统动态库，为了优化程序启动速度和利用动态库缓存，iOS系统采用了共享缓存技术。dyld缓存在iOS系统中，位于/System/Library/Caches/com.apple.dyld/目录下，按照不同架构保存不同的文件。 dyld加载流程要想知道+load和constructor是在什么时候调用的，就需要分析dyld加载Mach-O文件的流程。dyld的代码可以从苹果开源网站下载。从dyldStartup.s文件开始执行，其中用汇编实现的__dyld_start方法里面调用了dyldbootstrap::start()方法，然后调用了dyld的main函数。 dyld的加载流程主要包括9个步骤 设置上下文信息，配置进程是否受限 配置环境变量，获取当前运行架构 加载可执行文件，生成一个ImageLoader实例对象 检查共享缓存是否映射到了共享区域 加载所有插入的库 链接主程序 链接所有插入的库，执行符号替换 执行初始化方法 寻找主程序入口 initializeMainExecutable执行初始化方法，+load和constructor方法就是在这里执行的。 Mach-O文件格式Mach-O 文件比较重要，了解Mach-O文件结构后可以更好地进行逆向工程。 Mach-O文件的基础格式Mach-O的文件结构包括：Mach-O头部、Load Command、Section、Other Data。 Mach-O头部Header部分由以下部分组成: magic: Mach-O 文件的魔数。FAT为0xcafebabe，ARMv7为0xfeedface，ARM64为0xfeedfacf（Mac是小端模式） cputype、cpusubtype: CPU架构和子版本 filetype: 文件类型。 ncmds: 加载命令的数量 sizeofcmds: 所有加载命令的大小 flags: dyld加载需要的一些标记。其中，MH_PIE表示启用地址空间布局随机化。 reserved: 64位的保留字段。 下面是微信的Header部分 Load CommandLoad Command 告诉操作系统应当如何加载文件中的数据，对系统内核加载器和动态链接器起指导作用。可以使用MachOView 查看 Load Command部分。 Load Command 包含以下部分: LC_SEGMENT_64: 定义一个段，加载后被映射到内存中，包括里面的节。 LC_DYLD_INFO_ONLY: 记录了有关链接的重要信息，包括在__LINKEDIT中动态链接相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的链接器无法识别它，程序就会出错。 LC_SYMTAB: 为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的 external 符号被链接器使用。 LC_DYSYMTAB: 将符号表中给出符号的额外符号信息提供给动态链接器。 LC_LOAD_DYLINKER: 默认的加载器路径。 LC_UUUID: 用于标识 Mach-O 文件的ID，也用于崩溃堆栈和符号文件的对应解析。 LC_VERSION_MIN_IPHONES: 系统要求的最低版本。 LC_SOURCE_VERSION: 构建二进制文件的源代码版本号。 LC_MAIN: 程序的入口。dyld获取地址，然后跳转到该处执行。 LC_ENCRYPTION_INFO_64: 文件是否加密的标志，加密内容的偏移和大小。 LC_LOAD_DYLIB: 依赖的动态库，包括动态库名称、当前版本号、兼容版本号。可以使用 otool -L xxx 命令查看。 LC_RPATH: Runpath Search Paths，@rpath 搜索的路径。 LC_FUNCTION_STARTS: 函数起始地址表，是调试器和其他程序能很容易地看到一个地址是否在函数内。 LC_DATA_IN_CODE: 定义在代码段内的非指令的表。 LC_CODE_SIGNAURE: 代码签名信息。 我们看到Load Command还包含以下4种段 __PAGEZERO: 空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用。 __TEXT: 代码段只读数据段。 __DATA: 读取和写入数据的段。 __LINKEDIT: 动态链接器需要使用的信息，包括重定位信息、绑定信息、懒加载信息等。 懒加载和非懒加载iOS系统为了加快系统启动速度，将符号分成了懒加载符号和非懒加载符号。非懒加载符号在dyld加载时就会绑定真实的值；而懒加载符号不会，只有第1次去调用它时才会绑定真实的地址，在第2次调用时直接使用真实的地址。 这也是fishhook替换符号实现逆向功能的原理，原理会以后详细介绍。 后面还有 动态库，以及逆向原理会介绍。 未完待续","tags":["逆向","iOS"],"categories":["IT技术"]},{"title":"逆向工程基础","path":"/memoirs/20200212/reverse-basics/","content":"逆向工程简介iOS 逆向工程，是指从目标应用的界面以及功能表现入手，使用不同工具和理论知识去分析其实现原理，得出应用的代码结构、整体设计、功能实现、执行流程等，然后利用iOS的系统知识和语言特性，借鉴或修改原有实现流程的技术。 前置基础知识学习逆向工程我们需要先了解设备知识，下面我们先介绍一下设备相关的基础知识。 ARM学习ARM首先要了解下CPU是什么分不清ARM和X86架构，别跟我说你懂CPUCentral Processing Unit(CPU)的组成部分 运算器（ALU- arithmetic logic unit 算术逻辑单元，马达） 控制器（Control 负责分配指定运算） 寄存器(Register ARM汇编就是操作寄存器和内存的指令集) cpu内部总线（物理）地址线路，数据线路 控制线路(内存读写命令) 地址总线 限制CPU内存地址空间的大小，地址总线宽度为32，2的32次方4GB.个内存单元，一个内存单元可以存放8位数据也就是一个字的数据。cpu访问内存单元时，要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间。每一个内存丹云在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。 N位结构。比如64位(位机，字长与结构含义相同)，描述了一个cpu具有下面几方面的结构特性 运算器一次最多可以处理64位的数据 8个byte 寄存器的最大宽度为64位 寄存器和运算器之间的通路为64位。 对于65位cpu，能一次性处理，传输，暂时存储64位的地址 总结：从字面意思看运算器就是起着运算的作用控制器就是负责发出CPU每条指令所需要的信息寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。 CPU有着处理指令、执行操作、控制时间、处理数据四大作用，打个比喻来说，CPU就像我们的大脑，帮我们完成各种各样的生理活动。因此如果没有CPU，那么电脑就是一堆废物，无法工作。移动设备其实很复杂，这些CPU需要执行数以百万计的指示，才能使它向我们期待的方向运行，而CPU的速度和功率效率是至关重要的。速度影响用户体验，而效率影响电池寿命。最完美的移动设备是高性能和低功耗相结合。 cup的模式切换，模式和模式间相对独立。说白了就是切换状态 cpu要读取一个内存单元的时候，必须先给出这个内存单元的地址。 段的概念错误认识：内存被划分成了一个一个的段，每一个段有一个段地址。正确认识：内存并没有分段，段的划分来自于CPU，由于CUP用 段地址*16 + 偏移地址 物理地址 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段。偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大64KB。 为什么需要寄存器cup切换状态时，比如funA - funB,实际上操作的是内存地址，把这些操作内存地址的指令或者内存地址直接放在cpu里，可以更好的控制和提高效率，cpu就需要寄存器来存放这些指令。 寄存器常用术语 SP（stack point）栈指针，存储栈地址，指向栈顶 LR（link register）链接寄存器 PC（program count）程序技术器 A\\C PSR（program status register）程序状态寄存器 SPSR(saved program status register)已保存程序状态寄存器 user模式没有SPSR 指令集要了解X86和ARM，就得先了解复杂指令集（CISC)和精简指令集（RISC） Complex Instruction Set Computing - CISC reduced instruction set computing 从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。 Intel和ARM处理器的第一个区别是，前者使用复杂指令集（CISC)，而后者使用精简指令集（RISC）。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。 我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。 从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。 但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。 这就是“复杂指令集”和“精简指令集”的逻辑区别。 x86多用于电脑，ARM多用于手机。 参考文章ARM汇编以及汇编语言基础介绍 汇编基础模拟器32位处理器是i386架构，模拟器64位处理器是x86_64架构，真机32位处理器是armv7,或者armv7s架构，(armv7s 是iPhone5C、armv7是iphone4之前的手机版本)真机64位处理器是arm64架构。（iPhone5s之后的手机）【接下来主要学习的】 ARM64下的寄存器功能: 进行数据的临时存储 数据执行算术及逻辑运算 操作内存(寻址) 寄存器分类: 通用寄存器（用来存放一般性的数据） x0~x30（64位） x29 又名fp（用于保存栈底的地址） x30 又名 lr（bl 跳转后就会把下一条指令地址写到lr中） w0w30（32位）这些就是x0x30的低32位 浮点寄存器（CPU中专门提供浮点数寄存器来处理浮点数） D0~D31（64位） S0S31 （32位）这些就是D0D31的低32位 向量寄存器（现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.） V0-V31（128位） 状态寄存器（又称 CPSR【current program status register】寄存器） CPSR寄存器是32位的，每一位的功能如下 31 30 29 28 27~8 7 6 5 4 3 2 1 0 N Z C V 保留 I F T M4 M3 M2 M1 M0 CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位! N【负数标志】、Z【0标志】、C【进位标志】、V【溢出标志】均为条件码标志位。 栈寄存器 SP （任意时刻会保存我们栈顶的地址） FP （用于保存栈底的地址） ARM64下常用的汇编指令(重要)基础指令 MOV - MOV X1，X0 ; 将寄存器X0的值传送到寄存器X1 ADD - ADD X0，X1，X2 ; 寄存器X1和X2的值相加后传送到X0 SUB - SUB X0，X1，X2 ; 寄存器X1和X2的值相减后传送到X0 AND - AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0 ORR - ORR X0，X0，#9 ; X0的值与9相或后的值传送到X0 EOR - EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0 堆栈操作 STR - 将数据从寄存器中读出来,存到内存中.STR - STR X0, [SP, #0x8] ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间 STP - STR 的变种指令，可以同时操作两个寄存器STP x29, x30, [sp, #0x10] ; 将x29,x30存入栈中 LDR - 将数据从内存中读出来,存到寄存器中LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5 LDP - LDR 的变种指令，可以同时操作两个寄存器LDP x29, x30, [sp, #0x10] ; 将栈中的值取出存放到x29, x30 跳转操作 BL 将下一条指令的地址放入lr(x30)寄存器 RET 默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址! CMP 比较指令，相当于SUBS，影响程序状态寄存器 B.GT 比较结果是大于，执行标号，否则不跳转 B.GE 比较结果是大于等于，执行标号，否则不跳转 B.EQ 比较结果是等于，执行标号，否则不跳转 B.HI 比较结果是无符号大于，执行标号，否则不跳转 CBZ - CBZ ; 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令） CBNZ - CBNZ ; 比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令） 逆向工具对任何平台进行逆向分析时都会借助很多工具，iOS逆向也不例外。以逆向的流程为例，会使用解密工具、class-dump、Cycript、Reveal、Charles、Hopper、IDA、Xcode、Theos等，这些工具都是必须了解的。 除了使用工具，还需要了解每个工具的实现原理，有哪些值得借鉴的地方。 效率工具 iTerm2 oh-my-zsh Go2Shell autojump Alfred 实用工具效率提升后，需要一些实用工具来帮助完成某些复杂的操作 Homebrew Cakebrew libimobiledevice tree 010 Editor 逆向工具逆向工具很重要，需要介绍一下 jtool: 查看文件结构，代码签名 capstone: 多平台、多架构支持的反汇编框架 keystone: 将汇编指令转换为 Hex 机器码 radare2: 开放源代码的逆向工程平台 mobiledevice: 安装 app 或 ipa 包 最后的总结这些只是我们接触逆向时，必要的准备工作，还有进阶的知识，后面会慢慢讲解。","tags":["逆向","iOS"],"categories":["IT技术"]},{"title":"Runtime介绍(一)","path":"/memoirs/20200208/iOS/rumtime-introduction-1/","content":"Runtime简介Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。 OC语言在编译期都会被编译为C语言的Runtime代码，二进制执行过程中执行的都是C语言代码。而OC的类本质上都是结构体，在编译时都会以结构体的形式被编译到二进制中。Runtime是一套由C、C++、汇编实现的API，所有的方法调用都叫做发送消息。 C语言中，在编译期，函数的调用就会决定调用哪个函数。而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。 Runtime使用Runtime是一个共享动态库，其目录位于/usr/include/objc，由一系列的C函数和结构体构成。和Runtime系统发生交互的方式有三种，一般都是用前两种： 使用OC源码直接使用上层OC源码，底层会通过Runtime为其提供运行支持，上层不需要关心Runtime运行。 NSObject在OC代码中绝大多数的类都是继承自NSObject的，NSProxy类例外。Runtime在NSObject中定义了一些基础操作，NSObject的子类也具备这些特性。 Runtime动态库上层的OC源码都是通过Runtime实现的，我们一般不直接使用Runtime，直接和OC代码打交道就可以。 使用Runtime需要引入下面两个头文件，一些基础方法都定义在这两个文件中。 #import objc/runtime.h#import objc/message.h 关于库函数可以在Objective-C Runtime Reference中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，那些函数里面的参数和描述都没有了。对于熟悉Runtime的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从iOS6开始开发的同学，依稀可能能感受到，关于Runtime的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从Xcode5开始，苹果就不建议我们手动调用Runtime的API，也同样希望我们不要知道具体底层实现。所以IDE上面默认代了一个参数，禁止了Runtime的代码提示，源码和文档方面也删除了一些解释。如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成NO，即可。 NSObject介绍在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。 @protocol NSObject- (BOOL)isEqual:(id)object;@property (readonly) NSUInteger hash;@property (readonly) Class superclass;- (Class)class OBJC_SWIFT_UNAVAILABLE(use type(of: anObject) instead);- (instancetype)self;- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;- (BOOL)isProxy;- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;- (BOOL)conformsToProtocol:(Protocol *)aProtocol;- (BOOL)respondsToSelector:(SEL)aSelector;- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;@property (readonly, copy) NSString *description;@optional@property (readonly, copy) NSString *debugDescription;@end@interface NSObject NSObject #pragma clang diagnostic push#pragma clang diagnostic ignored -Wobjc-interface-ivars Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop objc_class的源码如下： #if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object Class _Nonnull isa OBJC_ISA_AVAILABILITY;;struct objc_class Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。*methodLists是指向方法列表的指针。这里如果动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。 在NSObject的类中还定义了一个方法 + (IMP)instanceMethodForSelector:(SEL)aSelector; IMP则引出了另一个概念，这个后面会介绍，我们继续说NSObject。 图中实线是 super_class指针，虚线是isa指针。 Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。 每个Class都有一个isa指针指向唯一的Meta class Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。 每个Meta class的isa指针都指向Root class (meta)。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。 具体的实现需要看源代码，这里我就不讨论源代码的内容了。 相关概念上面介绍了NSObject，下面介绍一下其他的相关概念。 IMP在Runtime中IMP本质上就是一个函数指针，其定义如下。在IMP中有两个默认的参数id和SEL，id也就是方法中的self，这和objc_msgSend()函数传递的参数一样。 Runtime中提供了很多对于IMP操作的API，下面就是不分IMP相关的函数定义。我们比较常见的是method_exchangeImplementations函数，Method Swizzling就是通过这个API实现的。 /// A pointer to the function of a method implementation. #if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); #endifOBJC_EXPORT voidmethod_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT IMP _Nonnullmethod_setImplementation(Method _Nonnull m, IMP _Nonnull imp) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT IMP _Nonnullmethod_getImplementation(Method _Nonnull m) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT IMP _Nullableclass_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// .... MethodMethod用来表示方法，其包含SEL和IMP，下面可以看一下Method结构体的定义。 typedef struct method_t *Method;struct method_t SEL name; const char *types; IMP imp;; 在Xcode进行编译的时候，只会将Xcode的Compile Sources中.m声明的方法编译到Method List，而.h文件中声明的方法对Method List没有影响。 Property在Runtime中定义了属性的结构体，用来表示对象中定义的属性。@property修饰符用来修饰属性，修饰后的属性为objc_property_t类型，其本质是property_t结构体。其结构体定义如下。 typedef struct property_t *objc_property_t;struct property_t const char *name; const char *attributes;; 可以通过下面两个函数，分别获取实例对象的属性列表，和协议的属性列表。 objc_property_t * class_copyPropertyList（Class cls，unsigned int * outCount）objc_property_t * protocol_copyPropertyList（Protocol * proto，unsigned int * outCount） 可以通过下面两个方法，传入指定的Class和propertyName，获取对应的objc_property_t属性结构体。 objc_property_t class_getProperty（Class cls，const char * name）objc_property_t protocol_getProperty（Protocol * proto，const char * name，BOOL isRequiredProperty，BOOL isInstanceProperty） 未完待续","tags":["基础知识","iOS","Runtime"],"categories":["IT技术"]},{"title":"剑来！","path":"/memoirs/20200207/jianlai/","content":"剑来大千世界，无奇不有。我陈平安，唯有一剑，可搬山，倒海，降妖，镇魔，敕神，摘星，断江，摧城，开天！我叫陈平安，平平安安的平安。我是一名剑客。 o(╯□╰)o陈政华天天请假，三天一更，以至于我天天阴阳怪气的在贴吧吐槽作为剑来贴吧一个 老阴阳，吐槽归吐槽，还是有些道理可以看一看的。但是太多的纸面上的道理，看一看就行。 1、修心，亦是修行之一。顺境修力，逆境修心，缺一不可。2、天大地大，独自一人，然后遇上了某个大坎，你死活就是跨不过去，要么憋屈死，要么找死，还能怎么办？3、列星随行，日月递炤，四时代御，阴阳大化，风雨博施，万物各得其和以生，各得其养以成。4、胸中一点浩然气，天地千里快哉风。5、君子不妄动，动必有道。君子不徒语，语必有理。君子不苟求，求必有义。君子不虚行，行必有正。6、凡夫俗子不下苦功夫、死力气去努力做成一件事，根本就没资格去谈什么天赋不天赋。7、某些人和事，哪怕是路边的风景，可是只要看一眼，依然会让人觉得很美好。8、传道受业，能解一惑是一惑。书上正理，能说一理是一理。9、整个浩然天下都是你儒家的门户，贫道就偏偏要在你家里，独立开辟出一座小花园。10、一个姑娘，如果有被人喜欢，而且那个人喜欢得干干净净，怎么都是一件美好的事情。11、记住，以后不管遇到什么，你都不要对这个世界失去希望。12、世间万般讲理与不讲理，终归会落在一处，我心安处即吾乡。13、长生不朽，逍遥山海，餐霞饮露，不食五谷，已是异类也。14、江湖道义不能太多，可总该有那么点儿，半点不讲，就是条真龙，迟早也得淹死在江湖里。15、有些可惜，是没办法十全十美。有些可惜，是某些长久的遗憾。16、有心为善虽善不赏，无心为恶虽恶不罚。人力有穷尽之时，尽力又尽心了，就不用太愧疚。17、这么多年下来，陈平安活得很艰辛，但是不苦。18、是你的就好好抓住，不是你的就不要多想。天底下没谁是欠你的，但是你欠了别人，就别不当回事。19、认定一件事，即使拿十分力气都无法完成，也要拿出十二分力气去努力。20、自童年起，我就独自一人，照看历代星辰。21、有些事情，死了也要做。但有些事情，是死也不能做的。22、行走江湖，钱难挣，屎难吃，只要不是花钱买屎吃，就是好日子了。23、有些事情，不去做，陈平安心里不痛快。可有些事情，再不痛快，也只能忍着。24、溪水渐浅，井水渐冷，老槐更老，铁锁生锈，大云低垂。今年桃叶见不到桃花。25、原来是这样啊。原来是一位春风和煦暖人心的少年郎啊。26、世上除了爹娘，再没有人是理所应当对你好的。27、遇事不决，可问春风。28、归根结底，长得好，无论男女，怎么都是对的，长得不好看，大概就是万般皆罪。29、当这个世界给予自己善意的时候，一定要好好珍惜，要惜福，无论大小。30、中秋明月，豪门有，贫家也有。极慰人心。31、闲来打蚊蝇，忽起杀尽蚊蝇心。32、生死一线之间，有人贪生而怕死，审时度势，避难而退；有人舍生而取义，迎难而上，死中求活。33、总有些人，一眼看到就会心生好感，道理都讲不通。34、这一年，这座天下，春去极晚，夏来极迟。35、有些人心如花木，皆向阳而生。36、走得再远，看得再细，终究会有这样那样的错过，不可能真正将风景看遍。37、君子坐而论道，少年起而行之。38、人身即为小天地，忽起剑鸣不平声！39、世上好人的好心好意，到头来办坏事结恶果，少吗？40、水落石出，原来蛟龙盘踞。风吹草动，已是虎视眈眈。41、混吃等死，小富即安，飞黄腾达，是因为各有各的缘法，未必有高下之分。42、不被喜欢的姑娘喜欢，是一件很伤心的事情，可天没有塌下来，该怎么活，还得怎么活。43、簪子上有八个字，便是仅算粗通文墨的少女，也觉得极为动人。言念君子，温其如玉。44、月光入怀，皎皎在肩，一夜安宁。45、人情送头牛，买卖不饶针。46、但愿世间人无病，宁可架上药成灰！47、与善人居，如入芝兰之室，久而自芳矣。48、初衷是好的，你所希冀的结果也是好的，但这是你不择手段行事的理由吗？49、少年，思无邪，最最动人。50、喜欢谁，我自己又管不住自己的，你觉得轻浮就你觉得，我也不管你。51、有些人之间，注定只要相逢，就是对的。如果还能重逢，就是最好的。52、对的就是对的，错的就是错的，好的就应该珍惜，怎么珍惜都不为过。53、世间一个个文字，是有力量的。字眼组合成词，词汇串联成句，语句契合成文章。大道就在其中。54、一个人，哪能什么都不麻烦别人，偶尔有个一两次，不用太愧疚。55、我登楼观百川，入海即入我怀。56、但是两看相厌，不等于可以只看对方惹人厌的地方。两看欢喜，则一样不可以只看到好的地方。57、欲求天上宝，需用世间财。58、讲道理？他从来不喜欢。要与人讲道理，还练剑做什么？59、该是你的，就拿好别丢。不该是你的，想都别想。60、很多道理我憋在心里，想要跟这个世界好好的说上一说！61、小镇虽小，粗粮可以养胃，书籍可以养气，景致可以养心。62、有些善意，就跟春寒料峭的阳光一样，虽说在与不在，差别不是很大，可为什么要拒绝呢？63、人间万事细如毛，我有小事大如斗。64、男子下等眼光，只看女子脸面，中等眼光，看那身段，上等眼光，看女子神意。65、陈平安开心笑了。被自己认可的人认可，真是一件值得喝酒的事情哇。66、阿良无敌不无敌，暂且不好说，潇洒是真潇洒。67、浩然天下所有好看的山，好看的水，加在一起，都不如她好看！68、该省之省，一文铜钱，即是家族根本。该花则花，一掷千金，根本无需眨眼。69、如果我有天突然死了，道长能不能帮我下辈子投胎，还投胎做我爹娘的孩子？70、天下事情实在太多，不近我身，便都不是重要事。71、他喜欢的那位姑娘，即是他心头的朱砂痣，也是明月光。72、他的人生总是这样，真正在意的人，好像如何也挽留不住。73、临死去只落得孑然一身，赴阴司始问子孙安在；到头来徒留下千古骂名，来地府方知万事皆休。74、她锋利无比，注定是把无鞘剑。75、有庙无僧风扫地，有香无火月点灯。76、如果你的朋友过得比你好，好很多，好到让你望尘莫及，一辈子追不上，那么你心里头会不会一点点别扭？77、魏檗摇头道：既然拿得起，就没有放得下的道理。78、这么好的一位少年，那么他喜欢着的少女，得是多好的姑娘啊？79、真正的强者，愿意以弱者的自由为边界。80、有些人，只是夹杂在稻谷之中的一株稗草，被人看过一眼，就再无第二眼。81、既然遇上了那么好的姑娘，怎么舍得去辜负呢？82、天道崩塌，我陈平安唯有一剑，可搬山，断江，倒海，降妖，镇魔，敕神，摘星，摧城，开天。83、女子总爱在情爱一事上动脑筋，男子喜好在江山一事上花心思。84、小齐，江湖很不好，也就酒还行。85、人生路上，总会有那么几场疾风骤雨，就像是老天爷在提醒世人，你们是在寄人篱下，要乖乖低头。86、与妙人交友，如醉鬼饮醇酒，哪有清醒的可能，岂有不醉的道理？ 未完待续 格式可太麻烦了","tags":["杂谈","随便写写"]},{"title":"2020-01-28 武汉封城第五天","path":"/memoirs/20200128/wuhan/wuhan1/","content":"大年初四，同样是封城之后的第五天。 疫情并没有下降的趋势，今天应该是第二波爆发期，所以到今天武汉已经快3000确诊，6000+的疑似病例了。昨天出去了一次，买了一些消炎药和一些水果。虽然全城封闭了，外面还是有几辆车的，行人也有一些，主要是买药买水果买菜的。这个城市给我的感觉是过年时全部人员返乡之后的张江，基本没人，烟火气也没有，想吃个东西很难。偶尔也有外卖的人在送外卖，我出来个一个小时之内有1-2个美团的人在路上。总的来说，我挺适应这样的武汉，就是太安静了，安静的可怕，以前热闹的时候也还行。虽然我住的地方比不上武汉最繁华的地方，但是该有的都有，封城之后基本上没人出门了。小区里面前几天出了几个确诊的，一家人有好几个，所以现在小区也没人逛了。本来还有人喜欢在小区里面走走玩玩，偶尔去对面公园走走。这两天人少很多了，一天可能就有几个人，都是不怕的。 自我隔离中。。。","tags":["杂谈"],"categories":["武汉"]},{"title":"2020-01-23 武汉封城第一天","path":"/memoirs/20200123/wuhan/wuhan/","content":"坐标武汉。从一个武汉本地居民的视角来记录一下这次的事件。 网上的言论很多，各种用心险恶的，鼓励加油的。 从12月份开始第一例的时候我已经买了口罩，那时候全部都在说可控可控，知乎上的回答全部避重就轻的在吹武汉的抗病毒实力，所以我并不怎么相信的。真正爆发是在20号之后了，全城都很恐慌，口罩更难买了。21号基本上公司都放假了，正好关注了一些医疗机构，九州通发布声明说口罩供应不用担心，不会涨价，也可以保证足量供应。正好家附近就是九州通大厦，所以我也不是很着急买口罩，家里还有一些备用的。 今天是23号，在凌晨2点多发布消息准备暂停全部交通，关闭离汉通道。2点多我还没睡觉，本来有些活动的，基本上全部取消了。早上出门去附近的商场买物资，超市人很很多，商场基本上关门了。九州通大厦的药店排队的人也很多，大部分是买口罩的，另外也有一部分人买药。确实不用担心口罩的问题，店里面有几十箱口罩正在入库，口罩没有涨价但是限购5盒。 购买物资和口罩之后就回家睡觉了，其实我并没有多大的波动。但是有一些人为了一些自己的利益各种在群里散布恐慌谣言，然后网上有好些人想着放弃武汉，这些言论都不会放在心上。人间不值得好好地在家里自我隔离，看看书，写写代码，挺好。 封城第一天，记录一下。","tags":["杂谈"],"categories":["武汉"]},{"title":"ObjectMapper实践（一）","path":"/memoirs/20180803/iOS/objectMapper-1/","content":"前言在OC阶段使用模型转换的框架有很多，代表有：JSONModel、 YYModel、MJExtension。OC的原理主要是通过runtime 获取类的属性，在运行时获取Model的字段名集合，遍历该集合，拿Key去JSON中取值并完成赋值。而且Swift 的属性默认并不是动态属性，我们能在运行时获取一个Model实例的所有字段、字段值，但却无法给它赋值。事实上，我们拿到的value是原值的一个只读拷贝，即使获取到这个拷贝的地址写入新值，也是无效的。OC的转换方式虽然在OC中完全适用，但是缺点也很严重，一方面只能只能继承 NSObject ，并不支持Struct；还有一个更严重的问题，optional 的属性不能正确解析，反正坑还是挺多的。 所以如果是项目中有Swift的Model，就需要找到一个更好的转换方式。为了解决这些问题，很多处理JSON的开源库应运而生。在Swift中，这些开源库主要朝着两个方向努力： 保持JSON语义，直接解析JSON，但通过封装使调用方式更优雅、更安全； 预定义Model类，将JSON反序列化为类实例，再使用这些实例。 先讨论第一种方式，其实我在16年前用Swift的时候主要是用第一种方式，最初是原始的解析方式，茫茫多的guard，很傻的方法。 然后我就开始用大名鼎鼎的SwiftyJSON，它本质上仍然是根据JSON结构去取值，使用起来顺手、清晰。但是他有一个根本性的问题，如果key拼写错误，或者其他的拼写错误就会很崩溃。 第二种方式应该是最优化的，最合理的方式。每一个Model都会通过一个Mappable协议来表明JSON字典映射关系，然后实现JSON和对象的转换。当然还有一个黑魔法 HandyJSON ，通过分析Swift数据结构在内存中的布局，自动分析出映射关系，进一步降低开发者使用的成本。下面来介绍ObjectMapper 的用法，实现思路，以及源码分析。 #ObjectMapper 介绍ObjectMapper 是一个使用 Swift 编写的用于 model 对象（类和结构体）和 JSON 之间转换的框架。 ObjectMapper特性 将JSON映射到对象 将对象映射到JSON 嵌套对象（独立，在数组或字典中） 映射期间的自定义转换 结构支持 不可改变的支持 ObjectMapper可以映射由以下类型组成的类： Int Bool Double Float String RawRepresentable (Enums) ArrayAny DictionaryString, Any ObjectT: Mappable ArrayT: Mappable ArrayArrayT: Mappable SetT: Mappable DictionaryString, T: Mappable DictionaryString, ArrayT: Mappable Optionals of all the above Implicitly Unwrapped Optionals of the above 基本用法ObjectMapper中定义了一个协议Mappable Mappable协议中声明了两个方法 mutation func mapping(map: Map)init?(map: Map) ObjectMapper使用 -运算符来定义每个成员变量如何映射到JSON和从JSON映射。 class User: Mappable var username: String? var age: Int? var weight: Double! var array: [Any]? var dictionary: [String : Any] = [:] var bestFriend: User? // Nested User object var friends: [User]? // Array of Users var birthday: Date? required init?(map: Map) // Mappable func mapping(map: Map) username - map[username] age - map[age] weight - map[weight] array - map[arr] dictionary - map[dict] bestFriend - map[best_friend] friends - map[friends] birthday - (map[birthday], DateTransform()) struct Temperature: Mappable var celsius: Double? var fahrenheit: Double? init?(map: Map) mutating func mapping(map: Map) celsius - map[celsius] fahrenheit - map[fahrenheit] 如果我们的类或结构体如上面的示例一样实现了协议，我们就可以方便的进行JSON和模型之间的转换 let JSONString = \\weight\\: 180let user = User(JSONString: JSONString)user?.age = 10user?.username = ashuser?.birthday = Date()user?.weight = 180if let jsonStr = user?.toJSONString(prettyPrint: true) debugPrint(jsonStr) 当然也可以通过Mapper类来进行转换 let user = MapperUser().map(JSONString: JSONString)let JSONString = Mapper().toJSONString(user, prettyPrint: true) 嵌套对象的映射正如前面所列，ObjectMapper支持嵌套对象的映射 distance : text : 102, value : 31 我们想要直接取出distance对象中的value值，可以设置如下mapping func mapping(map: Map) distance - map[distance.value] 自定义转换规则ObjectMapper允许开发者在数据映射过程中指定转换规则 class People: Mappable var birthday: NSDate? required init?(_ map: Map) func mapping(map: Map) birthday - (map[birthday], DateTransform()) let JSON = \\birthday\\:1458117795332 let result = MapperPeople().map(JSON) 由于我们指定了birthday的转换规则，所以上述代码在解析JSON数据的时候会将long类型转换成Date类型 除了使用ObjectMapper给我们提供的转换规则外，我们还可以通过实现TransformType协议来自定义我们的转换规则ObjectMapper为我们提供了一个TransformOf类来实现转换结果，TransformOf实际就是实现了TransformType协议的，TransformOf有两个类型的参数和两个闭包参数，类型表示参与转换的数据的类型，闭包表示转换的规则 public protocol TransformType typealias Object typealias JSON func transformFromJSON(value: AnyObject?) - Object? func transformToJSON(value: Object?) - JSON?let transform = TransformOfInt, String(fromJSON: (value: String?) - Int? in , toJSON: (value: Int?) - String? in // transform value from Int? to String? if let value = value return String(value) return nil)func mapping(map: Map) id - (map[id], transform) 泛型对象ObjectMapper同样可以处理泛型类型的参数，不过这个泛型类型需要在实现了Mappable协议的基础上才可以正常使用 class User: Mappable var name: String? required init?(_ map: Map) func mapping(_ map: Map) name - map[name] class ResultT: Mappable: Mappable var result: T? required init?(_ map: Map) func mapping(map: Map) result - map[result] let JSON = \\result\\: ame\\: \\anenn\\let result = MapperResultUser().map(JSON) 基本上的大部分常用用法都介绍完了，满足日常的开发需求应该是没问题的，下面我们要研究一下源码部分 源码解析功能分类根据实现的思路来分类应该可以分成三类： Core 部分 Operators 部分 Transforms 部分 其实 core 和 Operators 也可以归为一类，但是拆开来看更加容易理解，还是拆开来吧。因为源代码比较多，这篇文章先介绍 Core 部分，了解这部分基本上的实现思路就已经很明确了，然后在最后会介绍一下 Sourcery 的自动代码生成，不然 mapping 方法中的代码写的让人很绝望。 Mappable跟Mappable相关的协议有StaticMappable、ImmutableMappable，我们先将 StaticMappable 和 ImmutableMappable 这两种协议的处理逻辑放一放，直接关注最重要的 Mappable 协议的实现，了解了 Mappable 另外两个很好理解。 /// BaseMappable should not be implemented directly. Mappable or StaticMappable should be used insteadpublic protocol BaseMappable /// This function is where all variable mappings should occur. It is executed by Mapper during the mapping (serialization and deserialization) process.\tmutating func mapping(map: Map)public protocol Mappable: BaseMappable /// This function can be used to validate JSON prior to mapping. Return nil to cancel mapping at this point init?(map: Map)public extension BaseMappable /// Initializes object from a JSON String\tpublic init?(JSONString: String, context: MapContext? = nil) if let obj: Self = Mapper(context: context).map(JSONString: JSONString) self = obj else return nil /// Initializes object from a JSON Dictionary\tpublic init?(JSON: [String: Any], context: MapContext? = nil) if let obj: Self = Mapper(context: context).map(JSON: JSON) self = obj else return nil /// Returns the JSON Dictionary for the object\tpublic func toJSON() - [String: Any] return Mapper().toJSON(self) /// Returns the JSON String for the object\tpublic func toJSONString(prettyPrint: Bool = false) - String? return Mapper().toJSONString(self, prettyPrint: prettyPrint) BaseMappable为实现 Mappable 的 Model 提供了四种实例方法，有两个是初始化方法，当然你也可以自己新建一个 Mapper 来初始化；还有两个是 Model 转 JSON 的方法。 Mapper继续看 Mapper 的代码，Mapper中核心代码为下面的方法 /// Maps a JSON dictionary to an object that conforms to Mappablepublic func map(JSON: [String: Any]) - N? let map = Map(mappingType: .fromJSON, JSON: JSON, context: context, shouldIncludeNilValues: shouldIncludeNilValues) if let klass = N.self as? StaticMappable.Type // Check if object is StaticMappable if var object = klass.objectForMapping(map: map) as? N object.mapping(map: map) return object else if let klass = N.self as? Mappable.Type // Check if object is Mappable if var object = klass.init(map: map) as? N object.mapping(map: map) return object else if let klass = N.self as? ImmutableMappable.Type // Check if object is ImmutableMappable do return try klass.init(map: map) as? N catch let error #if DEBUG let exception: NSException if let mapError = error as? MapError exception = NSException(name: .init(rawValue: MapError), reason: mapError.description, userInfo: nil) else exception = NSException(name: .init(rawValue: ImmutableMappableError), reason: error.localizedDescription, userInfo: nil) exception.raise() #endif else // Ensure BaseMappable is not implemented directly assert(false, BaseMappable should not be implemented directly. Please implement Mappable, StaticMappable or ImmutableMappable) return nil 根据N的协议类型走不同的协议方法，最终得到 object。让我们用 Mappable 来举例，先回到之前协议中的方法 mutation func mapping(map: Map)init?(map: Map) 这样对着看就很好理解了，init?(map: Map) 没有 return nil 的时候，就会调用 func mapping(map: Map) 方法来指定映射关系，那这个映射关系有什么作用呢，后面会慢慢介绍。 extension Mapper // MARK: Functions that create JSON from objects ///Maps an object that conforms to Mappable to a JSON dictionary String, Any\tpublic func toJSON(_ object: N) - [String: Any] var mutableObject = object let map = Map(mappingType: .toJSON, JSON: [:], context: context, shouldIncludeNilValues: shouldIncludeNilValues) mutableObject.mapping(map: map) return map.JSON ///Maps an array of Objects to an array of JSON dictionaries [[String: Any]]\tpublic func toJSONArray(_ array: [N]) - [[String: Any]] return array.map // convert every element in array to JSON dictionary equivalent self.toJSON($0) ///Maps a dictionary of Objects that conform to Mappable to a JSON dictionary of dictionaries.\tpublic func toJSONDictionary(_ dictionary: [String: N]) - [String: [String: Any]] return dictionary.map (arg: (key: String, value: N)) in // convert every value in dictionary to its JSON dictionary equivalent return (arg.key, self.toJSON(arg.value)) ///Maps a dictionary of Objects that conform to Mappable to a JSON dictionary of dictionaries.\tpublic func toJSONDictionaryOfArrays(_ dictionary: [String: [N]]) - [String: [[String: Any]]] return dictionary.map (arg: (key: String, value: [N])) in // convert every value (array) in dictionary to its JSON dictionary equivalent return (arg.key, self.toJSONArray(arg.value)) /// Maps an Object to a JSON string with option of pretty formatting\tpublic func toJSONString(_ object: N, prettyPrint: Bool = false) - String? let JSONDict = toJSON(object) return Mapper.toJSONString(JSONDict as Any, prettyPrint: prettyPrint) /// Maps an array of Objects to a JSON string with option of pretty formatting public func toJSONString(_ array: [N], prettyPrint: Bool = false) - String? let JSONDict = toJSONArray(array) return Mapper.toJSONString(JSONDict as Any, prettyPrint: prettyPrint) /// Converts an Object to a JSON string with option of pretty formatting\tpublic static func toJSONString(_ JSONObject: Any, prettyPrint: Bool) - String? let options: JSONSerialization.WritingOptions = prettyPrint ? .prettyPrinted : [] if let JSON = Mapper.toJSONData(JSONObject, options: options) return String(data: JSON, encoding: String.Encoding.utf8) return nil /// Converts an Object to JSON data with options\tpublic static func toJSONData(_ JSONObject: Any, options: JSONSerialization.WritingOptions) - Data? if JSONSerialization.isValidJSONObject(JSONObject) let JSONData: Data? do JSONData = try JSONSerialization.data(withJSONObject: JSONObject, options: options) catch let error print(error) JSONData = nil return JSONData return nil Mapper 还有一些 toJSON 的方法，这边的方法也很好理解，具体的实现都是在 Map 的一些方法，要知道这些方法具体实现就需要继续往下看。 MapMap 中有两个核心的方法，先看自定义下标的方法，分析一下最重要的那个自定义下标的方法 /// Sets the current mapper value and key./// The Key paramater can be a period separated string (ex. distance.value) to access sub objects.public subscript(key: String) - Map // save key and value associated to it\treturn self.subscript(key: key)public subscript(key: String, delimiter delimiter: String) - Map return self.subscript(key: key, delimiter: delimiter)public subscript(key: String, nested nested: Bool) - Map return self.subscript(key: key, nested: nested)public subscript(key: String, nested nested: Bool, delimiter delimiter: String) - Map return self.subscript(key: key, nested: nested, delimiter: delimiter)public subscript(key: String, ignoreNil ignoreNil: Bool) - Map return self.subscript(key: key, ignoreNil: ignoreNil)public subscript(key: String, delimiter delimiter: String, ignoreNil ignoreNil: Bool) - Map return self.subscript(key: key, delimiter: delimiter, ignoreNil: ignoreNil)public subscript(key: String, nested nested: Bool, ignoreNil ignoreNil: Bool) - Map return self.subscript(key: key, nested: nested, ignoreNil: ignoreNil)public subscript(key: String, nested nested: Bool?, delimiter delimiter: String, ignoreNil ignoreNil: Bool) - Map return self.subscript(key: key, nested: nested, delimiter: delimiter, ignoreNil: ignoreNil)private func `subscript`(key: String, nested: Bool? = nil, delimiter: String = ., ignoreNil: Bool = false) - Map // save key and value associated to it\tcurrentKey = key\tkeyIsNested = nested ?? key.contains(delimiter)\tnestedKeyDelimiter = delimiter if mappingType == .fromJSON // check if a value exists for the current key // do this pre-check for performance reasons if keyIsNested // break down the components of the key that are separated by delimiter (isKeyPresent, currentValue) = valueFor(ArraySlice(key.components(separatedBy: delimiter)), dictionary: JSON) else let object = JSON[key] let isNSNull = object is NSNull isKeyPresent = isNSNull ? true : object != nil currentValue = isNSNull ? nil : object // update isKeyPresent if ignoreNil is true if ignoreNil currentValue == nil isKeyPresent = false return self 另一个核心的方法就是通过自定义下标的值，从JSON字典中根据key获取了value。 /// Fetch value from JSON dictionary, loop through keyPathComponents until we reach the desired objectprivate func valueFor(_ keyPathComponents: ArraySliceString, dictionary: [String: Any]) - (Bool, Any?) // Implement it as a tail recursive function.\tif keyPathComponents.isEmpty return (false, nil) if let keyPath = keyPathComponents.first let isTail = keyPathComponents.count == 1 let object = dictionary[keyPath] if object is NSNull return (isTail, nil) else if keyPathComponents.count 1, let dict = object as? [String: Any] let tail = keyPathComponents.dropFirst() return valueFor(tail, dictionary: dict) else if keyPathComponents.count 1, let array = object as? [Any] let tail = keyPathComponents.dropFirst() return valueFor(tail, array: array) else return (isTail object != nil, object) return (false, nil)/// Fetch value from JSON Array, loop through keyPathComponents them until we reach the desired objectprivate func valueFor(_ keyPathComponents: ArraySliceString, array: [Any]) - (Bool, Any?) // Implement it as a tail recursive function. if keyPathComponents.isEmpty return (false, nil) //Try to convert keypath to Int as index\tif let keyPath = keyPathComponents.first, let index = Int(keyPath) , index = 0 index array.count let isTail = keyPathComponents.count == 1 let object = array[index] if object is NSNull return (isTail, nil) else if keyPathComponents.count 1, let array = object as? [Any] let tail = keyPathComponents.dropFirst() return valueFor(tail, array: array) else if keyPathComponents.count 1, let dict = object as? [String: Any] let tail = keyPathComponents.dropFirst() return valueFor(tail, dictionary: dict) else return (isTail, object) return (false, nil) 看到这里其实 Core 部分的代码基本上就看完了，还有一些toJSON的方法，其他的类同的方法，那些对于理解 ObjectMapper 没有影响。 写在最后Sourcery简单介绍一些 Sourcery 这个自动生成代码的工具。Sourcery 是一个 Swift 代码生成的开源命令行工具，它 (通过 SourceKitten 使用 Apple 的 SourceKit 框架，来分析你的源码中的各种声明和标注，然后套用你预先定义的 Stencil 模板 (一种语法和 Mustache 很相似的 Swift 模板语言) 进行代码生成。我们下面会先看一个使用 SourceKitten 最简单的例子，来说明如何使用这个工具。然后再针对我们的字典转换问题进行实现。 安装 SourceKitten 非常简单，brew install sourcery 即可。不过，如果你想要在实际项目中使用这个工具的话，我建议直接从发布页面下载二进制文件，放到 Xcode 项目目录中，然后添加 Run Script 的 Build Phase 来在每次编译的时候自动生成。 之前说过了 mapping 函数实现起来过于臃肿耗时，你可以用插件来生成 mapping 函数用于生成Mappable和ImmutableMappable代码的Xcode插件但是Xcode 8之后不让用插件了，除非用野路子重签名的方式安装插件，而且安装了还不一定能用，反正那个很坑，还要复制一个Xcode用来打包上传，本弱鸡电脑根本没那么多空间。两个方法我都试过了， 个人觉得 SourceKitten 更加适合，那个插件的确实不好用，还有一种方式，可以在网站上自动生成，然后复制进来。接下来就可以尝试以下书写模板代码了。可以参照 Sourcery 文档 关于单个 Type 和 Variable 的部分的内容来实现。另外，可以考虑使用 --watch 模式来在文件改变时自动生成代码，来实时观察结果。 如果声明一个struct protocol AutoMappable struct Person var firstName: String var lastName: String var birthDate: Date var friend: [String] var lalala: DictionaryString, Any var age: Int return Calendar.current.dateComponents([.year], from: birthDate, to: Date()).year ?? -1 extension Person: AutoMappable 下面是我的模版代码 import ObjectMapper% for type in types.implementing.AutoMappable|struct %// MARK: type.name Mappableextension type.name: Mappable init?(map: Map) return nil mutating func mapping(map: Map) % for variable in type.storedVariables % % if variable.isArray % variable.name - map[variable.name.0.value] % elif variable.isDictionary % variable.name - map[variable.name.value] % else % variable.name - map[variable.name] % endif % % endfor % % endfor % 自动生成的代码显示如下： import ObjectMapper// MARK: Person Mappableextension Person: Mappable init?(map: Map) return nil mutating func mapping(map: Map) firstName - map[firstName] lastName - map[lastName] birthDate - map[birthDate] friend - map[friend.0.value] lalala - map[lalala.value] 上面的这种方式显然是运行时最高效的方式，所以强烈推荐是这个方法来使用ObjectMapper。后面会继续介绍 ObjectMapper 其他源码的实现思路。 参考 Sourcery Docs 不同角度看问题 - 从 Codable 到 Swift 元编程 数据序列化框架在 Swift 日常开发中的应用 JSON的第三方库源码阅读分享(ObjectMapper, SwiftyJSON, 以及Codable)","tags":["iOS"],"categories":["IT技术"]},{"title":"Linux 基础","path":"/memoirs/20170706/linux/","content":"一、Linux的简介 Linux的概述 Linux是基于Unix的开源免费的操作系统，由于系统的稳定性和安全性几乎成为程序代码运行的最佳系统环境。Linux是由Linus Torvalds（林纳斯·托瓦兹）起初开发的，由于源代码的开放性，现在已经衍生出了千上百种不同的Linux系统。 Linux系统的应用非常广泛，不仅可以长时间的运行我们编写的程序代码，还可以安装在各种计算机硬件设备中，比如手机、平板电脑、路由器等。尤其在这里提及一下，我们熟知是Android程序最底层就是运行在linux系统上的。 Linux的分类 (1) Linux根据市场需求不同，基本分为两个方向： 1）图形化界面版：注重用户体验，类似window操作系统，但目前成熟度不够 2）服务器版：没有好看的界面，是以在控制台窗口中输入命令操作系统的，类似于DOS，是我们假设服务器的最佳选择 (2)Linux根据原生程度，又分为两种： 1）内核版本：在Linus领导下的内核小组开发维护的系统内核的版本号 2）发行版本：一些组织或公司在内核版基础上进行二次开发而重新发行的版本 二、Linux的基本命令 服务器版的Linux安装 完毕 了，但没有图形化界面，我们只能通过控制台去操作系统，我们就要使用类似DOS命令的Linux命令去操作系统，那么 下面我们就进行Linux的命令的学习。Linux命令成百上千，课程不能一一涉及，也没有必要一一涉及，根据我们程序员在日常工作中的需求，总结出如下几种供学习。 1. 目录切换命令 window中通过图形化界面和鼠标可以任意切 换需要进入的目录，但Linux必须通过cd命令切换目录。但在学习cd命令之前，我们有必要分清Linux的目录结构（linux目录结构详细说明） cd usr 切换到该目录下usr目录cd ../ 切换到上一层目录cd / 切换到系统根目录cd ~ 切换到用户主目录cd - 切换到上一个所在目录 2. 目录的操作命令（增删改查） 增加目录操作（增）命令：mkdir 目录名称示例：在根目录 下 mkdir test，就会在根目录 下产生一个test问目录 查看目录（查）命令：ls [-al] 父目录示例：在根目录 下使用ls，可以看到该目录下的所有的目录和文件示例：在根目录 下使用ls -a，可以看到该目录下的所有文件和目录，包括隐藏的示例：在根目录 下使用ls -l，可以看到该目录下的所有目录和文件的详细信息 寻找目录（查）命令：find 目录 参数示例：查找root下的与test相关的目录(文件) find root -name ‘test*’ 修改目录的名称（改）命令：mv 目录名称 新目录名称示例：test目录下有一个oldTest目录，使用mv oldTest newTest命令修改注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行\t重命名的操作 移动目录的位置—剪切（改）命令：mv 目录名称 目录的新位置示例：在test下将newTest目录剪切到 usr下面，使用mv newTest usr注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作 拷贝目录（改）命令：cp -r 目录名称 目录拷贝的目标位置 —–r代表递归拷贝示例：将usr下的newTest拷贝到根目录下的test中，使用cp -r usrnewTest test注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不\t用写-r递归 删除目录（删）命令：rm [-rf] 目录示例：删除usr下的newTest，进入usr下使用rm -r newTest示例：删除test下的newTest而不需要询问强制删除，在test下使用rm -rf newTest注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，\t无论删除任何目录或文件，都直接使用rm -rf 目录文件压缩包 3. 文件的操作命令（增删改查） 文件的创建（增）命令：touch 文件名称 —– 空文件示例：在test目录下创建一个空文件 touch aaa.txt 文件的查看（查）命令：catmorelesstail 文件示例：使用cat查看etcsudo.conf文件，只能显示最后一屏内容示例：使用more查看etcsudo.conf文件，可以显示百分比，回车可以向下一行，\t空格可以向下一页，q可以退出查看示例：使用less查看etcsudo.conf文件，可以使用键盘上的PgUp和PgDn向上\t和向下翻页，q结束查看示例：使用tail -10 查看etcsudo.conf文件的后10行，Ctrl+C结束**注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，\t会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控\t文\t件的变化 ** 修改文件的内容（改）命令：vim 文件示例：编辑test下的aaa.txt文件，使用vim aaa.txt但此时并不能编辑，因为此时处于命令模式，点击键盘iao进入编辑模式，可以\t编辑文件vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。附：《vi使用方法介绍》和《vim命令合集》关于vim使用过程：在实际开发中，使用vim编辑器主要作用就是修改配置文件vim 文件——进入文件—–命令模式——按i进入编辑模式—–编辑文件\t——-按Esc进入底行模式—–输入:wqq! 删除文件（删）同目录删除：熟记 rm -rf 文件 即可 4. 压缩文件的操作命令 打包并压缩文件Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件其中：z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名示例：打包并压缩test下的所有文件 压缩后的压缩包指定名称为xxx.tar.gztar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf xxx.tar.gz /test/* 解压压缩包**（重点）**命令：tar [-xvf] 压缩文件其中：x：代表解压示例：将test下的xxx.tar.gz解压到当前目录下tar -xvf xxx.tar.gz示例：将test下的xxx.tar.gz解压到根目录usr下tar -xvf xxx.tar.gz -C /usr------C代表指定解压的位置 5. 其他命令 显示当前所在位置pwd 搜索命令命令：grep 要搜索的字符串 要搜索的文件示例：搜索usrsudu.conf文件中包含字符串to的行示例：搜索usrsudu.conf文件中包含字符串to的行 to要高亮显示 管道命令命令：| 将前一个命令的输出作为本次目录的输入示例：查看当前系统中所有的进程中包括system字符串的进程 查看进程命令：ps -ef示例：查看当前系统中运行的进程 杀死进程命令：kill -9 进程的pid 网络通信命令查看当前系统的网卡信息：ifconfig查看与某台机器的连接情况：ping查看当前系统的端口使用：netstat -an 最后这里只是列举了Linux简单的用法，还有很多其他的用法之后会慢慢更新。Linux 命令大全","tags":["基础知识"]},{"title":"iOS GIF图片的加载和合成","path":"/memoirs/20170211/iOS/ios-gif/","content":"写在前面的 不拘一世之利以为己私分，不以王天下为已处显。显则明。万物一府，死生同状。 一颗伤心死掉的橘子树 扯淡结束开始进入文章正题iOS中GIF图片是无法像jpg，png等一样直接加载出来的，有很多的第三方库也提供了这方面的功能，这里总结一下GIF图片加载的几种方式，以及使用多张png图片合成GIF图片的方法。 加载GIF图片1.使用UIWebViewWKWebView使用UIWebViewWKWebView相当于使用coreText 将GIF的数据编码渲染到UIWebViewWKWebView上，使用data数据来加载，本地和网络图片差不多。 下面使用本地图片来举例//1.使用webview来显示GIFself.view.addSubview(webview)webview.frame = self.view.boundslet path = Bundle.main.path(forResource: timg, ofType: gif)if let data = try? Data.init(contentsOf: URL.init(fileURLWithPath: path!)) webview.load(data as Data, mimeType: image/gif, characterEncodingName: UTF-8, baseURL: Bundle.main.resourceURL!)//当然也可以直接加载文件路径,下面两种load方法都可以实现webview.load(URLRequest.init(url: URL.init(fileURLWithPath: path!)))webview.loadFileURL(URL.init(fileURLWithPath: path!), allowingReadAccessTo: Bundle.main.resourceURL!)//OC 的写法类似，就不重复写了。 小结我本地的原图的宽度是500像素的，但是从上面的效果图可以看到，图片有并没有按照像素来显示，而是根据图片比例来显示，而且宽度自动为self.view的宽度。说明GIF图片数据在渲染时并不能控制图片显示的大小，以及GIF执行的帧数和运行次数。 2.使用GIF 数据来实现也可以使用 ImageIO 系统框架来实现GIF的播放，很多第三方开源的库也是这样做的。类似SDWebImage，Kingfisher，以及YYImage 都可以实现一句话来加载GIF图片的功能，其中Kingfisher 是swift语言，另外两个是OC的。 其实两种语言都一样，这边只是介绍swift语言。 下面的方法是根据GIF的data数据来得到一个([UIImage], TimeInterval) 的元组 // MARK: - ImageIOprivate func showGif() -([UIImage], TimeInterval)? let path = Bundle.main.path(forResource: timg, ofType: gif) let data = try? Data.init(contentsOf: URL.init(fileURLWithPath: path!)) let source = CGImageSourceCreateWithData(data as! CFData, nil) let count = CGImageSourceGetCount(source!) let options: NSDictionary = [kCGImageSourceShouldCache as String: true, kCGImageSourceTypeIdentifierHint as String: kUTTypeGIF] var gifDuration = 0.0 var images = [UIImage]() func frameDuration(from gifInfo: NSDictionary) - Double let gifDefaultFrameDuration = 0.100 let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as? NSNumber let duration = unclampedDelayTime ?? delayTime guard let frameDuration = duration else return gifDefaultFrameDuration return frameDuration.doubleValue 0.011 ? frameDuration.doubleValue : gifDefaultFrameDuration for i in 0 .. count guard let imageRef = CGImageSourceCreateImageAtIndex(source!, i, options) else return nil if count == 1 //只有一张图片时 gifDuration = Double.infinity//无穷大 else // Animated GIF guard let properties = CGImageSourceCopyPropertiesAtIndex(source!, i, nil), let gifinfo = (properties as NSDictionary)[kCGImagePropertyGIFDictionary as String] as? NSDictionary else return nil gifDuration += frameDuration(from: gifinfo) images.append(UIImage.init(cgImage: imageRef, scale: UIScreen.main.scale, orientation: .up)) return (images, gifDuration) 然后在viewDidLoad 中调用下面的代码 var imageView: UIImageView?let (images, duration) = showGif()!let animatedImage = UIImage.animatedImage(with: images, duration: duration)imageView = UIImageView.init(image: animatedImage)self.view.addSubview(imageView!)imageView?.center = self.view.center 使用let animatedImage = UIImage.animatedImage(with: images, duration: duration)可以创建一个动画图片，然后使用imageView = UIImageView.init(image: animatedImage)创建一个UIImageView? （为什么用这个方法呢，因为这个不用写imageView的width和height，会根据图片的像素自动渲染大小，不用设置大小。。。） 小结原图的像素宽度为500，模拟器的屏幕为@2x的像素，所以图片显示大小应该是刚刚好的。这种相对于webView来显示就优化得多，也可以设置图片动画的持续时间。 同样的道理，我们如果用imags这个image数组 加入到ImageView动画组中，就可以设置动画的次数，就可以实现类似于新浪微博多个GIF图的微博 GIF图片会依次播放的功能。 let (images, duration) = showGif()!//let animatedImage = UIImage.animatedImage(with: images, duration: duration)imageView = UIImageView.init(image: images.first) self.view.addSubview(imageView!)imageView?.center = self.view.center imageView?.animationImages = imagesimageView?.animationDuration = durationimageView?.animationRepeatCount = 3imageView?.startAnimating() GIF图片的显示就介绍到这里 GIF的合成GIF图片合成思路：多帧图像合成GIF的过程和GIF分解多帧图像的过程互逆，GIF图片分解过程倒过来推，就是GIF图像合成的过程。从功能上来说，GIF图片的合成分为以下三个主要部分。（1）加载待处理的n张原始数据源。（2）在Document目录下构建GIF文件。（3）设置GIF文件属性，利用ImageIO编码GIF文件。 1.首先将图片加入到工程中然后将读取的图片依次加载到images中。 let bundlePath = Bundle.main.path(forResource: images, ofType: bundle)print(bundlePath === \\(bundlePath))var images = [UIImage]()for i in 1 .. 10 let path = bundlePath?.appending(/\\(i).tiff) let image = UIImage.init(contentsOfFile: path!) images.append(image!) 2.构建在Document目录下的GIF文件路径。具体实现如下所示。 //构建在Document目录下的GIF文件路径let docs = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)let documentsDirectory = docs[0] as Stringlet gifPath = documentsDirectory+/mine.gifprint(gifPath === \\(gifPath))let url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, gifPath as CFString, CFURLPathStyle.cfurlposixPathStyle, false)let destion = CGImageDestinationCreateWithURL(url!, kUTTypeGIF, images.count, nil)//CGImageDestinationCreateWithURL方法的作用是创建一个图片的目标对象，为了便于大家理解，这里把图片目标对象比喻为一个集合体。 //集合体中描述了构成当前图片目标对象的一系列参数，如图片的URL地址、图片类型、图片帧数、配置参数等。//本代码中将mine.gif的本地文件路径作为参数1传递给这个图片目标对象，参数2描述了图片的类型为GIF图片，参数3表明当前GIF图片构成的帧数，参数4暂时给它一个空值。 3.待处理图片源已经加载到代码中，GIF图片Destination也已经完成构建，下面就需要使用ImageIO框架把多帧PNG图片编码到GIF图片中，其处理流程如下。 //设置gif图片属性，利用9张tiff图片构建giflet cgimagePropertiesDic = [kCGImagePropertyGIFDelayTime as String: 0.1]//设置每帧之间播放时间let cgimagePropertiesDestDic = [kCGImagePropertyGIFDictionary as String: cgimagePropertiesDic]for cgimage in images // 依次为gif图像对象添加每一帧元素 CGImageDestinationAddImage(destion!, cgimage.cgImage!, cgimagePropertiesDestDic as CFDictionary?)let gifPropertiesDic:NSMutableDictionary = NSMutableDictionary()gifPropertiesDic.setValue(kCGImagePropertyColorModelRGB, forKey: kCGImagePropertyColorModel as String)gifPropertiesDic.setValue(16, forKey:kCGImagePropertyDepth as String)// 设置图像的颜色深度gifPropertiesDic.setValue(3, forKey:kCGImagePropertyGIFLoopCount as String)// 设置Gif执行次数, 0则为无限执行gifPropertiesDic.setValue(NSNumber.init(booleanLiteral: true), forKey: kCGImagePropertyGIFHasGlobalColorMap as String)let gifDictionaryDestDic = [kCGImagePropertyGIFDictionary as String: gifPropertiesDic]CGImageDestinationSetProperties(destion!, gifDictionaryDestDic as CFDictionary?)//为gif图像设置属性CGImageDestinationFinalize(destion!)//最后释放 目标对象 destion//生成GIF图片成功 这样就生成GIF图片成功了，最后我们来测试一下生成的GIF图片能否成功显示。 //测试一下显示GIF图片let (images2, duration) = showGif(path: gifPath)!let animatedImage = UIImage.animatedImage(with: images2, duration: duration)imageView = UIImageView.init(image: animatedImage)self.view.addSubview(imageView!)imageView?.center = self.view.center 运行之后确实是可以显示的 最后的话最后附上demo 的地址https://github.com/aichiko/Swift_Diary喜欢的话可以点赞一下。","tags":["iOS"],"categories":["IT技术"]},{"title":"问道","path":"/memoirs/20170203/问道/","content":"写在前面的话2017年了，今天是今年最开始的一天，希望新的生活到来之际，过去的种种苦难随着今年的西北风而去，不再回头。当然，那些打不倒我的。 回顾一下2016年应该是很艰难的一年，在上海工作稳定下来了，没有去年那么辛苦，却比去年更加难过。去年初六就上了去上海的高铁，很多人没来得及见一面就走了，然后一个人默默的工作，知道自己工资涨了的时候还开心好过一阵子。依然住在那个整天见不到阳光的小房间里，像一只在上海苟活着的小老鼠，见不到外面的阳光和风景。 然后的日子很简单，每天就是上班下班然后外卖睡觉，那段时间应该算是很灰暗的一段时间。前半年的加班还是挺多的，有时候回去已经11点多了，困的不行，有时候就直接睡了，然后早上起来再洗澡。那时候我就感觉自己的身体状态很不好，浑浑噩噩的一天天过去，特别是在天气变热之后全天开着空调之后。 后半年的事情就像老天突然袭击一样，让人猝不及防的懵逼了，突如其来的迅速。我有些麻木了，所以有了许多许多的莫名的情绪，我想我应该是一个很淡漠的人吧。还是因为道家的思想影响了我，我自认为也做不到庄子击缶而歌、高声大唱，大道如天兮，众生走过，其始而本无生。 我自己也是才疏学浅，无法理解南华真人的大智慧，真人风范。那些突如其来的打击确实让我心力交瘁，现在我感觉我整个人苍老了许多。 写这些其实有一个很长的时间跨度，工作的原因断断续续的写了些。本来我只是想到记录一下今年的流水账，然后我发现这流水账对我来说不重要，真的不重要。写写这在上海这一年的心路历程和心理状态也许更加的有用，以后再看的时候可能有些许收获。 这不是回顾前些天看了一步倪妮的电影，28岁未成年。我进入了白日做梦的模式，如果17的我看见现在的我肯定会很不屑。原来我长大了，然后朝着17岁的我最鄙夷的方式去了。 无为也，则用天下而有余，有为也，则为天下用而不足。 问题出在我自己身上吗。。。没关系。。。不以为真，不以为染。。。 不是最后新的一年开始了，未来不可见，这个世界总会变的。","categories":["关于世界的一切"]},{"title":"关于iOS 多线程的问题","path":"/memoirs/20161118/iOS/thread/","content":"写在前面的话ReactiveCocoa 5.0 看了两天，真是看的要吐血，网上基本上没有中文的文章,然后就只能看看git上的readme，看的晕乎乎的。我感觉ReactiveCocoa 的swift上手难度比OC要难很多，然后我看见了一个很有意思的博客主。@没故事的卓同学 膜拜一下大神 🐶🐶 我有书半卷，逍遥曰化形。挥请仙佛退，送与鬼神听。副墨闻于讴，参寥传玄冥。一指掩天地，齐物自忘情。 前言 基础知识 在iOS中每个进程启动后都会建立一个主线程（UI线程），这个线程是其他线程的父线程。由于在iOS中除了主线程，其他子线程是独立于Cocoa Touch的，所以只有主线程可以更新UI界面（新版iOS中，使用其他线程更新UI可能也能成功，但是不推荐）。最好不要尝试在子线程中更新UI。 当用户播放音频、下载资源、进行图像处理时往往希望做这些事情的时候其他操作不会被中断或者希望这些操作过程中更加顺畅。在单线程中一个线程只能做一件事情，一件事情处理不完另一件事就不能开始，这样势必影响用户体验。早在单核处理器时期就有多线程，这个时候多线程更多的用于解决线程阻塞造成的用户等待（通常是操作完UI后用户不再干涉，其他线程在等待队列中，CPU一旦空闲就继续执行，不影响用户其他UI操作），其处理能力并没有明显的变化。如今无论是移动操作系统还是PC、服务器都是多核处理器，于是“并行运算”就更多的被提及。一件事情我们可以分成多个步骤，在没有顺序要求的情况下使用多线程既能解决线程阻塞又能充分利用多核处理器运行能力。 进程和线程的关系 线程是进程的执行单元，进程的所有任务都在线程中执行！ 线程是 CPU 调用的最小单位 进程是 CPU 分配资源和调度的单位 一个程序可以对应过个进程,一个进程中可有多个线程,但至少要有一条线程 同一个进程内的线程共享进程资源 看着比较绕口，但是挺好理解的。这篇文章主要是介绍多线程的用法，剩下的串行（Serial）和 并行（Parallelism） 等等多线程的基础知识可以查看iOS开发之多线程编程总结 这篇文章，里面有详细的介绍。 多线程开发的三种方式 1.NSThread 2.NSOperation 3.GCD 三种方式是随着iOS的发展逐渐引入的，所以相比而言后者比前者更加简单易用，并且GCD也是目前苹果官方比较推荐的方式（它充分利用了多核处理器的运算性能）。 1. NSThread的使用NSThread 主要有两种直接创建方式：- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument; iOS 10 之后更新了两个新的API，可以直接将代码写在block中 + (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)); NSThread的属性@property double threadPriority NS_AVAILABLE(10_6, 4_0); // To be deprecated; use qualityOfService below//threadPriority是线程的优先级，最高是1.0，最低为0.0；默认我们创建的优先级是0.5；@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0); // read-only after the thread is started//qualityOfService 则是threadPriority 的替代属性，qualityOfService是一个枚举属性，也是代表线程的优先级。@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);//name 则是线程的名称，方便后面出现问题的追踪！ 比较常用的就是这三个属性 使用NSThread下载图片 //NSThread 的使用 //使用类方法创建 [NSThread detachNewThreadWithBlock:^ ]; [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil]; //方法1：使用对象方法 //创建一个线程，第一个参数是请求的操作，第二个参数是操作方法的参数 NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(downloadImage) object:nil]; NSThread *thread_0 = [[NSThread alloc]initWithBlock:^ ]; //启动一个线程，注意启动一个线程并非就一定立即执行，而是处于就绪状态，当系统调度时才真正执行 [thread start]; [thread_0 start];- (void)downloadImage NSURL *url = [NSURL URLWithString:@http://imgsrc.baidu.com/forum/w%3D580/sign=07bcb87477f082022d9291377bfafb8a/2da7adec54e736d185d9d05f9f504fc2d76269cd.jpg]; //线程延迟3s //线程可以设置name ，这里可以指定name 来进行休眠 [NSThread sleepForTimeInterval:3.0]; NSData *data = [NSData dataWithContentsOfURL:url]; NSLog(@downLoadImage:%@,[NSThread currentThread]);//在子线程中下载图片 /*将数据显示到UI控件,注意只能在主线程中更新UI, 另外performSelectorOnMainThread方法是NSObject的分类方法，每个NSObject对象都有此方法， 它调用的selector方法是当前调用控件的方法，例如使用UIImageView调用的时候selector就是UIImageView的方法 Object：代表调用方法的参数,不过只能传递一个参数(如果有多个参数请使用对象进行封装) waitUntilDone:是否线程任务完成执行 */ if (data) [self performSelectorOnMainThread:@selector(updateImage:) withObject:data waitUntilDone:YES]; - (void)updateImage:(NSData *)imageData //更新image UIImage *image = [UIImage imageWithData:imageData]; _imageView.image=image; demo比较简单，viewDidLoad 中启动一个新的线程，这个线程在演示中大概用了5s左右，在这5s内UI线程是不会阻塞的，用户可以进行其他操作，大约5s之后图片下载完成，此时调用UI线程将图片显示到界面中（这个过程瞬间完成）。更新UI的时候使用主线程，这里调用了NSObject的分类扩展方法，调用主线程完成更新。 如果同时用NSThread开辟多个线程来下载图片并更新UI，我们就会发现NSThread 并不能有效的管理线程的顺序。虽然可以设置优先级来进行排序，但是对于同一优先级的线程来说无法有效的管理。在多线程并发同时处理同一个数据或者资源时，就会引出另一个问题：线程的同步与线程锁。 线程的同步与锁最直接的例子就是：多个窗口同时售票的售票系统！ @interface ViewController () NSInteger _tickets;//总票数 NSInteger _soldCounts;//当前卖出去票数@property (nonatomic, strong) NSThread* ticketsThread_01;@property (nonatomic, strong) NSThread* ticketsThread_02;@property (nonatomic, strong) NSLock *ticketsLock;- (void)threadLock _tickets = 100; _soldCounts = 0; //锁对象 self.ticketsLock = [[NSLock alloc] init]; self.ticketsThread_01 = [[NSThread alloc] initWithTarget:self selector:@selector(sellAction) object:nil]; self.ticketsThread_01.name = @thread-1; [self.ticketsThread_01 start]; self.ticketsThread_02 = [[NSThread alloc] initWithTarget:self selector:@selector(sellAction) object:nil]; self.ticketsThread_02.name = @thread-2; [self.ticketsThread_02 start];- (void)sellAction while (true) //上锁 [self.ticketsLock lock]; if (_tickets = 0) [NSThread sleepForTimeInterval:0.5]; _soldCounts = 100 - _tickets; NSLog(@当前总票数是：%ld-----卖出：%ld-----线程名:%@,_tickets,_soldCounts,[NSThread currentThread]); _tickets--; else break; //解锁 [self.ticketsLock unlock]; 上面的demo中创建了两个线程来进行买票，因为有NSLock 的存在，线程会在NSLock 上锁的时候进行等待，NSLock 解锁之后才能进行操作。NSLock 还有NSCondition、NSRecursiveLock 循环锁、NSConditionLock 条件锁等几种类型，这里就不一一介绍了。 2. GCD的使用GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是目前苹果官方推荐的多线程开发方法。前面也说过三种开发中GCD抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的。对于熟悉C#异步调用的朋友对于GCD学习起来应该很快，因为它与C#中的异步调用基本是一样的。这种机制相比较于前面两种多线程开发方式最显著的优点就是它对于多核运算更加有效。 GCD 的基本概念#任务和队列 任务：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：同步执行和异步执行。两者的主要区别是：是否具备开启新线程的能力。 同步执行（sync）：只能在当前线程中执行任务，不具备开启新线程的能力 必须等待当前语句执行完毕，才会执行下一条语句 不会开启线程 在当前主线程执行 block 的任务 dispatch_sync(queue, block); 异步执行（async）：可以在新的线程中执行任务，具备开启新线程的能力 不用等待当前语句执行完毕，就可以执行下一条语句 会开启线程执行 block 的任务 异步是多线程的代名词 dispatch_async(queue, block); 队列：这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有四种队列：串行队列、并发队列、主队列、全局队列。 串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。 dispatch_queue_create(queue, NULL); 或者dispatch_queue_create(queue, DISPATCH_QUEUE_SERIAL); 2. 并发队列：有多个线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。 dispatch_queue_create(queue, DISPATCH_QUEUE_CONCURRENT);并发功能只有在异步（dispatch_async）函数下才有效 主队列：主线程 dispatch_get_main_queue(); 全局队列 执行过程和并发队列一致，参考并发队列 dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 全局队列有四种线程优先级#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 串行队列（Serial Dispatch Queue）#pragma mark - 串行队列同步和串行队列异步//串行队列同步- (void)serialQueueSyncMethod //创建队列 dispatch_queue_t queue = dispatch_queue_create(serialQueueSyncMethod, DISPATCH_QUEUE_SERIAL); //执行任务 for (int i = 0; i 6; i++) NSLog(@mainThread---%d,i); dispatch_sync(queue, ^ NSLog(@Current Thread=%@----%d-----,[NSThread currentThread],i); ); NSLog(@串行队列同步end);//串行队列异步- (void)serialQueueAsyncMethod dispatch_queue_t queue = dispatch_queue_create(serialQueueAsyncMethod, DISPATCH_QUEUE_SERIAL); for (int i = 0; i 6; i++) NSLog(@mainThread---%d,i); dispatch_async(queue, ^ NSLog(@Current Thread=%@----%d-----,[NSThread currentThread],i); ); NSLog(@串行队列异步end); 如果需要更新UI还使用了GCD方法的主线程队列dispatch_get_main_queue()，切换到主线程来更新UI。从上面的例子可以看出虽然串行队列是按照顺序依次执行的，但是串行队列同步执行不会开辟线程，而串行队列异步执行会仅会开辟一个新的线程，所有block任务之间是同步执行的。 并发队列（Concurrent Dispatch Queue）- (void)layoutUI //创建多个图片控件用于显示图片 _imageViews=[NSMutableArray array]; for (int i = 0; i 3; i++) for (int j = 0; j 2; j++) UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(10+110*i, 100+110*j, 100, 100)]; [self.view addSubview:imageView]; [_imageViews addObject:imageView]; #pragma mark - 并行队列同步和并行队列异步//并行队列同步- (IBAction)concurrentQueueSyncMethod:(id)sender dispatch_queue_t queue = dispatch_queue_create(concurrentQueueSyncMethod, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i 6; i++) dispatch_sync(queue, ^ NSLog(@Current Thread=%@----%d-----,[NSThread currentThread],i); [self loadImage:i]; ); NSLog(@并行队列同步end);//并行队列异步- (IBAction)concurrentQueueAsyncMethod:(id)sender dispatch_queue_t queue = dispatch_queue_create(concurrentQueueAsyncMethod, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i 6; i++) dispatch_async(queue, ^ NSLog(@Current Thread=%@----%d-----,[NSThread currentThread],i); [self loadImage:i]; ); NSLog(@并行队列异步end); #pragma mark 加载图片-(void)loadImage:(int)index NSURL *url = [NSURL URLWithString:@http://imgsrc.baidu.com/forum/w%3D580/sign=07bcb87477f082022d9291377bfafb8a/2da7adec54e736d185d9d05f9f504fc2d76269cd.jpg]; //如果在串行队列中会发现当前线程打印变化完全一样，因为他们在一个线程中 NSLog(@thread is :%@,[NSThread currentThread]); //请求数据 NSData *data = [NSData dataWithContentsOfURL:url]; //更新UI界面,此处调用了GCD主线程队列的方法 if ([NSThread isMainThread]) [self updateImageWithData:data andIndex:index]; else dispatch_queue_t mainQueue= dispatch_get_main_queue(); dispatch_sync(mainQueue, ^ [self updateImageWithData:data andIndex:index]; ); #pragma mark 将图片显示到界面-(void)updateImageWithData:(NSData *)data andIndex:(int )index UIImage *image=[UIImage imageWithData:data]; UIImageView *imageView= _imageViews[index]; imageView.image=image; 并行队列小结 并发队列同步执行和串行队列同步执行一样，都不会开辟新线程，block任务之间是同步执行的！所以点击并行队列同步并不会开辟新线程，所以点击后会出现所有图片的加载全部在主线程中（可以打印线程查看），主线程被阻塞，造成图片最终是一次性显示。 并发队列异步执行结果中看到开辟了多个线程，并且执行顺序也不是顺序执行。因为异步开多线程的代名词，并发是开多条线程的代名词 在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行。 串行队列可以按顺序执行，并行队列的异步方法无法确定执行顺序。 全局队列全局队列是所有应用程序都能够使用的并发队列（Concurrent Dispatch Queue），原理和用法跟并发队列相同。大家可以参照上面的demo来看。 其他任务执行方法 dispatch_apply():重复执行某个任务，但是注意这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）。 dispatch_once():单次执行一个任务，此方法中的任务只会执行一次，重复调用也没办法重复执行（单例模式中常用此方法）。 dispatch_after()：延迟一定的时间后执行。 dispatch_barrier_async()：使用此方法创建的任务首先会查看队列中有没有别的任务要执行，如果有，则会等待已有任务执行完毕再执行；同时在此方法后添加的任务必须等待此方法中任务执行后才能执行。（利用这个方法可以控制执行顺序，例如前面先加载最后一张图片的需求就可以先使用这个方法将最后一张图片加载的操作添加到队列，然后调用dispatch_async()添加其他图片加载任务） dispatch_group_async()：实现对任务分组管理，如果一组任务全部完成可以通过dispatch_group_notify()方法获得完成通知（需要定义dispatch_group_t作为分组标识）。 任务组Dispatch Group这里介绍一下Dispatch Group ，其他的几种执行方法比较简单，就不一一介绍了。GCD的任务组在开发中是经常被使用到，当你一组任务结束后再执行一些操作时，使用任务组在合适不过了。dispatch_group的职责就是当队列中的所有任务都执行完毕后在去做一些操作，也就是说在任务组中执行的队列，当队列中的所有任务都执行完毕后就会发出一个通知来告诉用户任务组中所执行的队列中的任务执行完毕了。 //创建方法dispatch_group_t group = dispatch_group_create();//dispatch_group_t 相关联的有四个方法voiddispatch_group_async(dispatch_group_t group,\tdispatch_queue_t queue,\tdispatch_block_t block);//将线程加入dispatch_group_t中longdispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);//group等待voiddispatch_group_notify(dispatch_group_t group,\tdispatch_queue_t queue,\tdispatch_block_t block);//group 完成后通知执行voiddispatch_group_enter(dispatch_group_t group);//手动进入dispatch_group_tvoiddispatch_group_leave(dispatch_group_t group);//手动离开dispatch_group_t 下面会通过demo来详细介绍四种方法。 //自动执行任务组- (void)GCDAutoDispatchGroupMethod dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); for (int i = 0; i 6; i++) dispatch_group_async(group, queue, ^ NSLog(@current Thread = %@-----%d,[NSThread currentThread],i); [self loadImage:i]; ); dispatch_group_notify(group, dispatch_get_main_queue(), ^ NSLog(@current Thread = %@-----group完成后执行,[NSThread currentThread]); UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@ message:@图片加载完成 preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *sureAction = [UIAlertAction actionWithTitle:@确定 style:UIAlertActionStyleDefault handler:nil]; [alertController addAction:sureAction]; [self presentViewController:alertController animated:YES completion:nil]; ); 上面的demo中将多个加载图片的放在group中，在图片加载完成后会立即运行dispatch_group_notify的block块。另一种方式是手动的将队列与组进行关联然后使用异步将队列进行执行，也就是dispatch_group_enter()与dispatch_group_leave()方法的使用。 //手动执行任务组- (void)GCDManualDispatchGroupMethod dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); for (int i = 0; i 6; i++) dispatch_group_enter(group);//进入队列组 dispatch_async(queue, ^ NSLog(@current Thread = %@-----%d,[NSThread currentThread],i); dispatch_group_leave(group);//离开队列组 ); dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)); long result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);//阻塞当前线程，直到所有任务执行完毕才会继续往下执行 if (result == 0) //属于Dispatch Group 的block任务全部处理结束 NSLog(@Dispatch Group全部处理完毕); else //属于Dispatch Group 的block任务还在处理中 NSLog(@Dispatch Group正在处理); for (int i = 0; i 6; i++) dispatch_group_enter(group);//进入队列组 dispatch_async(queue, ^ NSLog(@current Thread = %@-----%d,[NSThread currentThread],i); dispatch_group_leave(group);//离开队列组 ); dispatch_group_notify(group, dispatch_get_main_queue(), ^ NSLog(@current Thread = %@-----这是最后执行,[NSThread currentThread]); ); dispatch_group_wait()函数，该函数的职责就是阻塞当前线程，来等待任务组中的任务执行完毕。 dispatch_group_wait可以使用 DISPATCH_TIME_FOREVER，也可以用dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)( 1 * NSEC_PER_SEC));来阻塞具体时间，直到上面的任务执行完成。 使用GCD解决资源抢占问题在GCD中提供了一种信号机制，也可以解决资源抢占问题（和同步锁的机制并不一样）。GCD中信号量是dispatch_semaphore_t类型，支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。根据这个原理我们可以初始化一个信号量变量，默认信号量设置为1，每当有线程进入“加锁代码”之后就调用信号等待命令（此时信号量为0）开始等待，此时其他线程无法进入，执行完后发送信号通知（此时信号量为1），其他线程开始进入执行，如此一来就达到了线程同步目的。 /*初始化信号量 参数是信号量初始值 */_semaphore=dispatch_semaphore_create(1);/*信号等待 第二个参数：等待时间 */dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);//这里加入修改信息的代码//使用方法跟NSLock类似//信号通知dispatch_semaphore_signal(_semaphore); 3. NSOperation的使用使用NSOperation和NSOperationQueue进行多线程开发类似于C#中的线程池，只要将一个NSOperation（实际开中需要使用其子类NSInvocationOperation、NSBlockOperation）放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易的管理线程总数和控制线程之间的依赖关系。 NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但是是后者使用Block形式进行代码组织，使用相对方便。 把NSOperation 放在最后一方面是我自己用这个用的很少，然后NSOperation 的API也是比较简单的，NSInvocationOperation和NSBlockOperation的用法一目了然。 NSInvocationOperation 的使用 /*创建一个调用操作 object:调用方法参数 */NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中//[invocationOperation start];//创建操作队列NSOperationQueue *operationQueue = [[NSOperationQueue alloc]init];//注意添加到操作队后，队列会开启一个线程执行此操作[operationQueue addOperation:invocationOperation]; NSBlockOperation 的使用 //创建操作队列 NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init]; operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数 //创建多个线程用于填充图片 for (int i=0; icount; ++i) //方法1：创建操作块添加到队列// //创建多线程操作// NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^// [self loadImage:[NSNumber numberWithInt:i]];// ];// //创建操作队列//// [operationQueue addOperation:blockOperation]; //方法2：直接使用操队列添加操作 [operationQueue addOperationWithBlock:^ [self loadImage:[NSNumber numberWithInt:i]]; ]; NSOperation 的优势在于可以用添加依赖来控制线程运行的顺序。 - (IBAction)loadImageWithMultiThread:(id)sender //创建操作队列 NSOperationQueue *operationQueue = [[NSOperationQueue alloc]init]; operationQueue.maxConcurrentOperationCount = 5;//设置最大并发线程数 NSBlockOperation *lastBlockOperation = [NSBlockOperation blockOperationWithBlock:^ [self loadImage:5]; ]; //创建多个线程用于填充图片 for (int i=0; i6-1; ++i) //方法1：创建操作块添加到队列 //创建多线程操作 NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^ [self loadImage:i]; ]; //设置依赖操作为最后一张图片加载操作 [blockOperation addDependency:lastBlockOperation]; [operationQueue addOperation:blockOperation]; //将最后一个图片的加载操作加入线程队列 [operationQueue addOperation:lastBlockOperation]; 可以看到虽然加载最后一张图片的操作最后被加入到操作队列，但是它却是被第一个执行的。操作依赖关系可以设置多个，例如A依赖于B、B依赖于C…但是千万不要设置为循环依赖关系（例如A依赖于B，B依赖于C，C又依赖于A），否则是不会被执行的。 总结 NSThread适合轻量级多线程开发，控制线程顺序比较难，同时线程总数无法控制（每次创建并不能重用之前的线程，只能创建一个新的线程）。 NSOperation进行多线程开发可以控制线程总数及线程依赖关系。 NSOperation是对GCD面向对象的ObjC封装，但是相比GCD基于C语言开发，效率却更高，建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。 在GCD中串行队列中的任务被安排到一个单一线程执行（不是主线程），可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。 在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行（如果是并行队列使用同步方法调用则会在主线程中执行）。 demo 下载地址：https://github.com/aichiko/Thread_demo 参考资料：iOS开发系列–并行开发其实很容易iOS开发之多线程编程","tags":["iOS"],"categories":["IT技术"]},{"title":"关于我","path":"/memoirs/about/index.html","content":"o(╯□╰)o 我的简历 主要搞iOS开发\b，写点前端，搞些逆向开发，写点Flutter。 佛系程序员。 我有书半卷，逍遥曰化形。挥请仙佛退，送与鬼神听。副墨闻于讴，参寥传玄冥。一指掩天地，齐物自忘情。"}]
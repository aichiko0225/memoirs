<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>关于iOS 多线程的问题 | ash</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写在前面的话ReactiveCocoa 5.0 看了两天，真是看的要吐血，网上基本上没有中文的文章,然后就只能看看git上的readme，看的晕乎乎的。我感觉ReactiveCocoa 的swift上手难度比OC要难很多，然后我看见了一个很有意思的博客主。@没故事的卓同学  膜拜一下大神 🐶🐶  我有书半卷，逍遥曰化形。挥请仙佛退，送与鬼神听。副墨闻于讴，参寥传玄冥。一指掩天地，齐物自忘情。">
<meta property="og:type" content="article">
<meta property="og:title" content="关于iOS 多线程的问题">
<meta property="og:url" content="https://aichiko0225.github.com/memoirs/2016/11/18/iOS/thread/index.html">
<meta property="og:site_name" content="ash">
<meta property="og:description" content="写在前面的话ReactiveCocoa 5.0 看了两天，真是看的要吐血，网上基本上没有中文的文章,然后就只能看看git上的readme，看的晕乎乎的。我感觉ReactiveCocoa 的swift上手难度比OC要难很多，然后我看见了一个很有意思的博客主。@没故事的卓同学  膜拜一下大神 🐶🐶  我有书半卷，逍遥曰化形。挥请仙佛退，送与鬼神听。副墨闻于讴，参寥传玄冥。一指掩天地，齐物自忘情。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2478081-c04df3a56ad26ccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2016-11-17T16:00:00.000Z">
<meta property="article:modified_time" content="2020-02-04T06:31:15.512Z">
<meta property="article:author" content="ash">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2478081-c04df3a56ad26ccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/memoirs/atom.xml" title="ash" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/memoirs/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/memoirs/" id="logo">ash</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/memoirs/">Home</a>
        
          <a class="main-nav-link" href="/memoirs/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/memoirs/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://aichiko0225.github.com/memoirs"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-iOS/thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/memoirs/2016/11/18/iOS/thread/" class="article-date">
  <time datetime="2016-11-17T16:00:00.000Z" itemprop="datePublished">2016-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/memoirs/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      关于iOS 多线程的问题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p><code>ReactiveCocoa</code> 5.0 看了两天，真是看的要吐血，网上基本上没有中文的文章,然后就只能看看git上的readme，看的晕乎乎的。我感觉ReactiveCocoa 的swift上手难度比OC要难很多，然后我看见了一个很有意思的博客主。<br><a target="_blank" rel="noopener" href="http://www.jianshu.com/users/88a056103c02/latest_articles">@没故事的卓同学</a>  膜拜一下大神 🐶🐶</p>
<blockquote>
<p>我有书半卷，逍遥曰化形。<br>挥请仙佛退，送与鬼神听。<br>副墨闻于讴，参寥传玄冥。<br>一指掩天地，齐物自忘情。 </p>
</blockquote>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4></li>
</ul>
<p> 在iOS中每个进程启动后都会建立一个主线程（UI线程），这个线程是其他线程的父线程。由于在iOS中除了主线程，其他子线程是独立于Cocoa Touch的，所以只有主线程可以更新UI界面（新版iOS中，使用其他线程更新UI可能也能成功，但是不推荐）。最好不要尝试在子线程中更新UI。</p>
<p> 当用户播放音频、下载资源、进行图像处理时往往希望做这些事情的时候其他操作不会被中断或者希望这些操作过程中更加顺畅。在单线程中一个线程只能做一件事情，一件事情处理不完另一件事就不能开始，这样势必影响用户体验。早在单核处理器时期就有多线程，这个时候多线程更多的用于解决线程阻塞造成的用户等待（通常是操作完UI后用户不再干涉，其他线程在等待队列中，CPU一旦空闲就继续执行，不影响用户其他UI操作），其处理能力并没有明显的变化。如今无论是移动操作系统还是PC、服务器都是多核处理器，于是“并行运算”就更多的被提及。一件事情我们可以分成多个步骤，在没有顺序要求的情况下使用多线程既能解决线程阻塞又能充分利用多核处理器运行能力。</p>
<ul>
<li><h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h4></li>
</ul>
<ol>
<li>线程是进程的执行单元，进程的所有任务都在线程中执行！</li>
<li>线程是 CPU 调用的最小单位</li>
<li>进程是 CPU 分配资源和调度的单位</li>
<li>一个程序可以对应过个进程,一个进程中可有多个线程,但至少要有一条线程</li>
<li>同一个进程内的线程共享进程资源</li>
</ol>
<p>看着比较绕口，但是挺好理解的。这篇文章主要是介绍多线程的用法，剩下的串行（Serial）和 并行（Parallelism） 等等多线程的基础知识可以查看<br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/95aa5446361d">iOS开发之多线程编程总结</a> 这篇文章，里面有详细的介绍。</p>
<ul>
<li><h4 id="多线程开发的三种方式"><a href="#多线程开发的三种方式" class="headerlink" title="多线程开发的三种方式"></a>多线程开发的三种方式</h4></li>
</ul>
<p> 1.NSThread<br> 2.NSOperation<br> 3.GCD</p>
<p>三种方式是随着iOS的发展逐渐引入的，所以相比而言后者比前者更加简单易用，并且GCD也是目前苹果官方比较推荐的方式（它充分利用了多核处理器的运算性能）。</p>
<h1 id="1-NSThread的使用"><a href="#1-NSThread的使用" class="headerlink" title="1. NSThread的使用"></a>1. NSThread的使用</h1><h5 id="NSThread-主要有两种直接创建方式："><a href="#NSThread-主要有两种直接创建方式：" class="headerlink" title="NSThread 主要有两种直接创建方式："></a>NSThread 主要有两种直接创建方式：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithTarget:(<span class="type">id</span>)target selector:(SEL)selector object:(<span class="type">id</span>)argument;</span><br><span class="line">+ (<span class="type">void</span>)detachNewThreadSelector:(SEL)aSelector toTarget:(<span class="type">id</span>)aTarget withObject:(<span class="type">id</span>)anArgument;</span><br></pre></td></tr></table></figure>
<p>iOS 10 之后更新了两个新的API，可以直接将代码写在block中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)detachNewThreadWithBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br></pre></td></tr></table></figure>

<h5 id="NSThread的属性"><a href="#NSThread的属性" class="headerlink" title="NSThread的属性"></a>NSThread的属性</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">double</span> threadPriority <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0); <span class="comment">// To be deprecated; use qualityOfService below</span></span><br><span class="line"><span class="comment">//threadPriority是线程的优先级，最高是1.0，最低为0.0；默认我们创建的优先级是0.5；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSQualityOfService</span> qualityOfService <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0); <span class="comment">// read-only after the thread is started</span></span><br><span class="line"><span class="comment">//qualityOfService 则是threadPriority 的替代属性，qualityOfService是一个枚举属性，也是代表线程的优先级。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="comment">//name 则是线程的名称，方便后面出现问题的追踪！</span></span><br></pre></td></tr></table></figure>
<p>比较常用的就是这三个属性</p>
<h5 id="使用NSThread下载图片"><a href="#使用NSThread下载图片" class="headerlink" title="使用NSThread下载图片"></a>使用NSThread下载图片</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//NSThread 的使用</span></span><br><span class="line">    <span class="comment">//使用类方法创建</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(downloadImage) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法1：使用对象方法</span></span><br><span class="line">    <span class="comment">//创建一个线程，第一个参数是请求的操作，第二个参数是操作方法的参数</span></span><br><span class="line">    <span class="built_in">NSThread</span> *thread=[[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downloadImage) object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *thread_0 = [[<span class="built_in">NSThread</span> alloc]initWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//启动一个线程，注意启动一个线程并非就一定立即执行，而是处于就绪状态，当系统调度时才真正执行</span></span><br><span class="line">    [thread start];</span><br><span class="line">    [thread_0 start];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)downloadImage &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://imgsrc.baidu.com/forum/w%3D580/sign=07bcb87477f082022d9291377bfafb8a/2da7adec54e736d185d9d05f9f504fc2d76269cd.jpg&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程延迟3s</span></span><br><span class="line">    <span class="comment">//线程可以设置name ，这里可以指定name 来进行休眠</span></span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;downLoadImage:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);<span class="comment">//在子线程中下载图片</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将数据显示到UI控件,注意只能在主线程中更新UI,</span></span><br><span class="line"><span class="comment">     另外performSelectorOnMainThread方法是NSObject的分类方法，每个NSObject对象都有此方法，</span></span><br><span class="line"><span class="comment">     它调用的selector方法是当前调用控件的方法，例如使用UIImageView调用的时候selector就是UIImageView的方法</span></span><br><span class="line"><span class="comment">     Object：代表调用方法的参数,不过只能传递一个参数(如果有多个参数请使用对象进行封装)</span></span><br><span class="line"><span class="comment">     waitUntilDone:是否线程任务完成执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateImage:) withObject:data waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)updateImage:(<span class="built_in">NSData</span> *)imageData &#123;</span><br><span class="line">    <span class="comment">//更新image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">    _imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>demo比较简单，viewDidLoad 中启动一个新的线程，这个线程在演示中大概用了5s左右，在这5s内UI线程是不会阻塞的，用户可以进行其他操作，大约5s之后图片下载完成，此时调用UI线程将图片显示到界面中（这个过程瞬间完成）。更新UI的时候使用主线程，这里调用了NSObject的分类扩展方法，调用主线程完成更新。</p>
<p>如果同时用NSThread开辟多个线程来下载图片并更新UI，我们就会发现NSThread 并不能有效的管理线程的顺序。虽然可以设置优先级来进行排序，但是对于同一优先级的线程来说无法有效的管理。在多线程并发同时处理同一个数据或者资源时，就会引出另一个问题：线程的同步与线程锁。</p>
<h5 id="线程的同步与锁"><a href="#线程的同步与锁" class="headerlink" title="线程的同步与锁"></a>线程的同步与锁</h5><p>最直接的例子就是：多个窗口同时售票的售票系统！</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _tickets;<span class="comment">//总票数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> _soldCounts;<span class="comment">//当前卖出去票数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span>* ticketsThread_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span>* ticketsThread_02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *ticketsLock;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)threadLock &#123;</span><br><span class="line">    _tickets = <span class="number">100</span>;</span><br><span class="line">    _soldCounts = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">self</span>.ticketsLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketsThread_01 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(sellAction) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.ticketsThread_01.name = <span class="string">@&quot;thread-1&quot;</span>;</span><br><span class="line">    [<span class="keyword">self</span>.ticketsThread_01 start];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketsThread_02 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(sellAction) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.ticketsThread_02.name = <span class="string">@&quot;thread-2&quot;</span>;</span><br><span class="line">    [<span class="keyword">self</span>.ticketsThread_02 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sellAction &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        [<span class="keyword">self</span>.ticketsLock lock];</span><br><span class="line">        <span class="keyword">if</span> (_tickets &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.5</span>];</span><br><span class="line">            _soldCounts = <span class="number">100</span> - _tickets;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;当前总票数是：%ld-----&gt;卖出：%ld-----&gt;线程名:%@&quot;</span>,_tickets,_soldCounts,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            _tickets--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        [<span class="keyword">self</span>.ticketsLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的demo中创建了两个线程来进行买票，因为有NSLock 的存在，线程会在NSLock 上锁的时候进行等待，NSLock 解锁之后才能进行操作。NSLock 还有NSCondition、NSRecursiveLock 循环锁、NSConditionLock 条件锁等几种类型，这里就不一一介绍了。</p>
<hr>
<h1 id="2-GCD的使用"><a href="#2-GCD的使用" class="headerlink" title="2. GCD的使用"></a>2. GCD的使用</h1><p>GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是目前苹果官方推荐的多线程开发方法。前面也说过三种开发中GCD抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的。对于熟悉C#异步调用的朋友对于GCD学习起来应该很快，因为它与C#中的异步调用基本是一样的。这种机制相比较于前面两种多线程开发方式最显著的优点就是它对于多核运算更加有效。</p>
<h5 id="GCD-的基本概念"><a href="#GCD-的基本概念" class="headerlink" title="GCD 的基本概念"></a>GCD 的基本概念</h5><h5 id="任务和队列"><a href="#任务和队列" class="headerlink" title="#任务和队列"></a>#任务和队列</h5><ul>
<li>任务：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：<strong>同步执行</strong>和<strong>异步执行</strong>。两者的主要区别是：是否具备开启新线程的能力。</li>
</ul>
<ol>
<li>同步执行（sync）：只能在当前线程中执行任务，不具备开启新线程的能力</li>
</ol>
<ul>
<li>必须等待当前语句执行完毕，才会执行下一条语句</li>
<li>不会开启线程</li>
<li>在当前主线程执行 block 的任务</li>
<li><code>dispatch_sync(queue, block);</code></li>
</ul>
<ol start="2">
<li>异步执行（async）：可以在新的线程中执行任务，具备开启新线程的能力</li>
</ol>
<ul>
<li><p>不用等待当前语句执行完毕，就可以执行下一条语句</p>
</li>
<li><p>会开启线程执行 block 的任务</p>
</li>
<li><p>异步是多线程的代名词</p>
</li>
<li><p><code>dispatch_async(queue, block);</code></p>
</li>
<li><p><strong>队列</strong>：这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有四种队列：<strong>串行队列</strong>、<strong>并发队列</strong>、<strong>主队列</strong>、<strong>全局队列</strong>。</p>
<ol>
<li>串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。</li>
</ol>
<ul>
<li><code>dispatch_queue_create(&quot;queue&quot;, NULL);</code></li>
</ul>
</li>
</ul>
<p>或者<code>dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</code><br>  2.  并发队列：有多个线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。</p>
<ul>
<li><code>dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</code><br><em>并发功能只有在异步（dispatch_async）函数下才有效</em></li>
</ul>
<ol start="3">
<li>主队列：主线程</li>
</ol>
<ul>
<li><code>dispatch_get_main_queue();</code></li>
</ul>
<ol start="4">
<li>全局队列</li>
</ol>
<ul>
<li>执行过程和并发队列一致，参考并发队列</li>
<li><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code></li>
<li>全局队列有四种线程优先级<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="串行队列（Serial-Dispatch-Queue）"><a href="#串行队列（Serial-Dispatch-Queue）" class="headerlink" title="串行队列（Serial Dispatch Queue）"></a>串行队列（Serial Dispatch Queue）</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 串行队列同步和串行队列异步</span></span><br><span class="line"><span class="comment">//串行队列同步</span></span><br><span class="line">- (<span class="type">void</span>)serialQueueSyncMethod &#123;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;serialQueueSyncMethod&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;mainThread---&gt;%d&quot;</span>,i);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Current Thread=%@----&gt;%d-----&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;串行队列同步end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串行队列异步</span></span><br><span class="line">- (<span class="type">void</span>)serialQueueAsyncMethod &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;serialQueueAsyncMethod&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;mainThread---&gt;%d&quot;</span>,i);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Current Thread=%@----&gt;%d-----&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;串行队列异步end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要更新UI还使用了GCD方法的主线程队列<code>dispatch_get_main_queue()，</code>切换到主线程来更新UI。从上面的例子可以看出虽然串行队列是按照顺序依次执行的，但是<strong>串行队列同步执行</strong>不会开辟线程，而<strong>串行队列异步执行</strong>会仅会开辟一个新的线程，所有block任务之间是同步执行的。</p>
<h5 id="并发队列（Concurrent-Dispatch-Queue）"><a href="#并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="并发队列（Concurrent Dispatch Queue）"></a>并发队列（Concurrent Dispatch Queue）</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)layoutUI &#123;</span><br><span class="line">    <span class="comment">//创建多个图片控件用于显示图片</span></span><br><span class="line">    _imageViews=[<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">10</span>+<span class="number">110</span>*i, <span class="number">100</span>+<span class="number">110</span>*j, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">            [<span class="keyword">self</span>.view addSubview:imageView];</span><br><span class="line">            [_imageViews addObject:imageView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 并行队列同步和并行队列异步</span></span><br><span class="line"><span class="comment">//并行队列同步</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)concurrentQueueSyncMethod:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;concurrentQueueSyncMethod&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Current Thread=%@----&gt;%d-----&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">            [<span class="keyword">self</span> loadImage:i];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;并行队列同步end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行队列异步</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)concurrentQueueAsyncMethod:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;concurrentQueueAsyncMethod&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Current Thread=%@----&gt;%d-----&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">            [<span class="keyword">self</span> loadImage:i];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;并行队列异步end&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 加载图片</span></span><br><span class="line">-(<span class="type">void</span>)loadImage:(<span class="type">int</span>)index&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://imgsrc.baidu.com/forum/w%3D580/sign=07bcb87477f082022d9291377bfafb8a/2da7adec54e736d185d9d05f9f504fc2d76269cd.jpg&quot;</span>];</span><br><span class="line">    <span class="comment">//如果在串行队列中会发现当前线程打印变化完全一样，因为他们在一个线程中</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;thread is :%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="comment">//更新UI界面,此处调用了GCD主线程队列的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> updateImageWithData:data andIndex:index];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> mainQueue= dispatch_get_main_queue();</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> updateImageWithData:data andIndex:index];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 将图片显示到界面</span></span><br><span class="line">-(<span class="type">void</span>)updateImageWithData:(<span class="built_in">NSData</span> *)data andIndex:(<span class="type">int</span> )index&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView= _imageViews[index];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2478081-c04df3a56ad26ccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="并行队列同步和并行队列同步 请求图片 并更新UI"></p>
<h6 id="并行队列小结"><a href="#并行队列小结" class="headerlink" title="并行队列小结"></a>并行队列小结</h6><ol>
<li><strong>并发队列同步</strong>执行和串行队列同步执行一样，都不会开辟新线程，block任务之间是同步执行的！所以点击并行队列同步并不会开辟新线程，所以点击后会出现所有图片的加载全部在主线程中（可以打印线程查看），主线程被阻塞，造成图片最终是一次性显示。</li>
<li><strong>并发队列异步</strong>执行结果中看到开辟了多个线程，并且执行顺序也不是顺序执行。因为异步开多线程的代名词，并发是开多条线程的代名词</li>
<li>在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行。</li>
<li>串行队列可以按顺序执行，并行队列的异步方法无法确定执行顺序。</li>
</ol>
<h5 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h5><p><strong>全局队列</strong>是所有应用程序都能够使用的并发队列（Concurrent Dispatch Queue），原理和用法跟并发队列相同。大家可以参照上面的demo来看。</p>
<h5 id="其他任务执行方法"><a href="#其他任务执行方法" class="headerlink" title="其他任务执行方法"></a>其他任务执行方法</h5><ol>
<li><code>dispatch_apply()</code>:重复执行某个任务，但是注意这个方法没有办法异步执行（为了不阻塞线程可以使用<code>dispatch_async()</code>包装一下再执行）。</li>
<li><code>dispatch_once()</code>:单次执行一个任务，此方法中的任务只会执行一次，重复调用也没办法重复执行（单例模式中常用此方法）。</li>
<li><code>dispatch_after()</code>：延迟一定的时间后执行。</li>
<li><code>dispatch_barrier_async()</code>：使用此方法创建的任务首先会查看队列中有没有别的任务要执行，如果有，则会等待已有任务执行完毕再执行；同时在此方法后添加的任务必须等待此方法中任务执行后才能执行。（利用这个方法可以控制执行顺序，例如前面先加载最后一张图片的需求就可以先使用这个方法将最后一张图片加载的操作添加到队列，然后调用<code>dispatch_async()</code>添加其他图片加载任务）</li>
<li><code>dispatch_group_async()</code>：实现对任务分组管理，如果一组任务全部完成可以通过<code>dispatch_group_notify()</code>方法获得完成通知（需要定义<code>dispatch_group_t</code>作为分组标识）。</li>
</ol>
<h5 id="任务组Dispatch-Group"><a href="#任务组Dispatch-Group" class="headerlink" title="任务组Dispatch Group"></a>任务组Dispatch Group</h5><p>这里介绍一下Dispatch Group ，其他的几种执行方法比较简单，就不一一介绍了。<br>GCD的任务组在开发中是经常被使用到，当你一组任务结束后再执行一些操作时，使用任务组在合适不过了。dispatch_group的职责就是当队列中的所有任务都执行完毕后在去做一些操作，也就是说在任务组中执行的队列，当队列中的所有任务都执行完毕后就会发出一个通知来告诉用户任务组中所执行的队列中的任务执行完毕了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建方法</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_group_t 相关联的有四个方法</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">dispatch_group_async(dispatch_group_t group,</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">	dispatch_block_t block);</span><br><span class="line"><span class="comment">//将线程加入dispatch_group_t中</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line">dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</span><br><span class="line"><span class="comment">//group等待</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">dispatch_group_notify(dispatch_group_t group,</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">	dispatch_block_t block);</span><br><span class="line"><span class="comment">//group 完成后通知执行</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">dispatch_group_enter(dispatch_group_t group);</span><br><span class="line"><span class="comment">//手动进入dispatch_group_t</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">dispatch_group_leave(dispatch_group_t group);</span><br><span class="line"><span class="comment">//手动离开dispatch_group_t</span></span><br></pre></td></tr></table></figure>

<p>下面会通过demo来详细介绍四种方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//自动执行任务组</span></span><br><span class="line">- (<span class="type">void</span>)GCDAutoDispatchGroupMethod &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;current Thread = %@-----&gt;%d&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">            [<span class="keyword">self</span> loadImage:i];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;current Thread = %@-----&gt;group完成后执行&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@&quot;&quot;</span> message:<span class="string">@&quot;图片加载完成&quot;</span> preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">        <span class="built_in">UIAlertAction</span> *sureAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@&quot;确定&quot;</span> style:<span class="built_in">UIAlertActionStyleDefault</span> handler:<span class="literal">nil</span>];</span><br><span class="line">        [alertController addAction:sureAction];</span><br><span class="line">        [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的demo中将多个加载图片的放在group中，在图片加载完成后会立即运行<code>dispatch_group_notify</code>的block块。<br>另一种方式是手动的将队列与组进行关联然后使用异步将队列进行执行，也就是dispatch_group_enter()与dispatch_group_leave()方法的使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动执行任务组</span></span><br><span class="line">- (<span class="type">void</span>)GCDManualDispatchGroupMethod &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_group_enter(group);<span class="comment">//进入队列组</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;current Thread = %@-----&gt;%d&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">            </span><br><span class="line">            dispatch_group_leave(group);<span class="comment">//离开队列组</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    <span class="type">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);<span class="comment">//阻塞当前线程，直到所有任务执行完毕才会继续往下执行</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//属于Dispatch Group 的block任务全部处理结束</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Dispatch Group全部处理完毕&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//属于Dispatch Group 的block任务还在处理中</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Dispatch Group正在处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_group_enter(group);<span class="comment">//进入队列组</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;current Thread = %@-----&gt;%d&quot;</span>,[<span class="built_in">NSThread</span> currentThread],i);</span><br><span class="line">            </span><br><span class="line">            dispatch_group_leave(group);<span class="comment">//离开队列组</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;current Thread = %@-----&gt;这是最后执行&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_wait()</code>函数，该函数的职责就是阻塞当前线程，来等待任务组中的任务执行完毕。<br> <code>dispatch_group_wait</code>可以使用 <code>DISPATCH_TIME_FOREVER</code>，也可以用<code>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)( 1 * NSEC_PER_SEC));</code>来阻塞具体时间，直到上面的任务执行完成。</p>
<h5 id="使用GCD解决资源抢占问题"><a href="#使用GCD解决资源抢占问题" class="headerlink" title="使用GCD解决资源抢占问题"></a>使用GCD解决资源抢占问题</h5><p>在GCD中提供了一种信号机制，也可以解决资源抢占问题（和同步锁的机制并不一样）。GCD中信号量是dispatch_semaphore_t类型，支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。根据这个原理我们可以初始化一个信号量变量，默认信号量设置为1，每当有线程进入“加锁代码”之后就调用信号等待命令（此时信号量为0）开始等待，此时其他线程无法进入，执行完后发送信号通知（此时信号量为1），其他线程开始进入执行，如此一来就达到了线程同步目的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*初始化信号量</span></span><br><span class="line"><span class="comment"> 参数是信号量初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_semaphore=dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号等待</span></span><br><span class="line"><span class="comment"> 第二个参数：等待时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//这里加入修改信息的代码</span></span><br><span class="line"><span class="comment">//使用方法跟NSLock类似</span></span><br><span class="line"><span class="comment">//信号通知</span></span><br><span class="line">dispatch_semaphore_signal(_semaphore);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-NSOperation的使用"><a href="#3-NSOperation的使用" class="headerlink" title="3. NSOperation的使用"></a>3. NSOperation的使用</h1><p>使用NSOperation和NSOperationQueue进行多线程开发类似于C#中的线程池，只要将一个NSOperation（实际开中需要使用其子类NSInvocationOperation、NSBlockOperation）放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易的管理线程总数和控制线程之间的依赖关系。</p>
<p>NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但是是后者使用Block形式进行代码组织，使用相对方便。</p>
<p>把NSOperation 放在最后一方面是我自己用这个用的很少，然后NSOperation 的API也是比较简单的，NSInvocationOperation和NSBlockOperation的用法一目了然。</p>
<h6 id="NSInvocationOperation-的使用"><a href="#NSInvocationOperation-的使用" class="headerlink" title="NSInvocationOperation 的使用"></a>NSInvocationOperation 的使用</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*创建一个调用操作</span></span><br><span class="line"><span class="comment"> object:调用方法参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *invocationOperation =  [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(loadImage) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中</span></span><br><span class="line"><span class="comment">//[invocationOperation start];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建操作队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"><span class="comment">//注意添加到操作队后，队列会开启一个线程执行此操作</span></span><br><span class="line">[operationQueue addOperation:invocationOperation];</span><br></pre></td></tr></table></figure>
<h6 id="NSBlockOperation-的使用"><a href="#NSBlockOperation-的使用" class="headerlink" title="NSBlockOperation 的使用"></a>NSBlockOperation 的使用</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//创建操作队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *operationQueue=[[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    operationQueue.maxConcurrentOperationCount=<span class="number">5</span>;<span class="comment">//设置最大并发线程数</span></span><br><span class="line">    <span class="comment">//创建多个线程用于填充图片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; ++i) &#123;</span><br><span class="line">        <span class="comment">//方法1：创建操作块添加到队列</span></span><br><span class="line"><span class="comment">//        //创建多线程操作</span></span><br><span class="line"><span class="comment">//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">//            [self loadImage:[NSNumber numberWithInt:i]];</span></span><br><span class="line"><span class="comment">//        &#125;];</span></span><br><span class="line"><span class="comment">//        //创建操作队列</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        [operationQueue addOperation:blockOperation];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法2：直接使用操队列添加操作</span></span><br><span class="line">        [operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">            [<span class="keyword">self</span> loadImage:[<span class="built_in">NSNumber</span> numberWithInt:i]];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>NSOperation 的优势在于可以用添加依赖来控制线程运行的顺序。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)loadImageWithMultiThread:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">//创建操作队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    operationQueue.maxConcurrentOperationCount = <span class="number">5</span>;<span class="comment">//设置最大并发线程数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *lastBlockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        [<span class="keyword">self</span> loadImage:<span class="number">5</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//创建多个线程用于填充图片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span><span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//方法1：创建操作块添加到队列</span></span><br><span class="line">        <span class="comment">//创建多线程操作</span></span><br><span class="line">        <span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">            [<span class="keyword">self</span> loadImage:i];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//设置依赖操作为最后一张图片加载操作</span></span><br><span class="line">        [blockOperation addDependency:lastBlockOperation];</span><br><span class="line">        </span><br><span class="line">        [operationQueue addOperation:blockOperation];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最后一个图片的加载操作加入线程队列</span></span><br><span class="line">    [operationQueue addOperation:lastBlockOperation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到虽然加载最后一张图片的操作最后被加入到操作队列，但是它却是被第一个执行的。操作依赖关系可以设置多个，例如A依赖于B、B依赖于C…但是千万不要设置为循环依赖关系（例如A依赖于B，B依赖于C，C又依赖于A），否则是不会被执行的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>NSThread适合轻量级多线程开发，控制线程顺序比较难，同时线程总数无法控制（每次创建并不能重用之前的线程，只能创建一个新的线程）。</li>
<li>NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</li>
<li>NSOperation是对GCD面向对象的ObjC封装，但是相比GCD基于C语言开发，效率却更高，建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</li>
<li>在GCD中串行队列中的任务被安排到一个单一线程执行（不是主线程），可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</li>
<li>在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行（如果是并行队列使用同步方法调用则会在主线程中执行）。</li>
</ol>
<h5 id="demo-下载地址："><a href="#demo-下载地址：" class="headerlink" title="demo 下载地址："></a>demo 下载地址：</h5><p><a target="_blank" rel="noopener" href="https://github.com/aichiko/Thread_demo">https://github.com/aichiko/Thread_demo</a></p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/kenshincui/p/3983982.html#summary">iOS开发系列–并行开发其实很容易</a><br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/01a9b8c9e963">iOS开发之多线程编程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://aichiko0225.github.com/memoirs/2016/11/18/iOS/thread/" data-id="cm4i68dvf0029b6ev20wzgrjh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/memoirs/2017/02/03/%E9%97%AE%E9%81%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          问道
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/%E5%85%B3%E4%BA%8E%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%80%E5%88%87/">关于世界的一切</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8/">工作日常</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/%E6%AD%A6%E6%B1%89/">武汉</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/%E9%80%86%E5%90%91/">逆向</a></li><li class="category-list-item"><a class="category-list-link" href="/memoirs/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/">随便写写</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/Flask/" rel="tag">Flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/Runtime/" rel="tag">Runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/memoirs/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/memoirs/tags/Flask/" style="font-size: 13.33px;">Flask</a> <a href="/memoirs/tags/React/" style="font-size: 10px;">React</a> <a href="/memoirs/tags/Runtime/" style="font-size: 10px;">Runtime</a> <a href="/memoirs/tags/Web/" style="font-size: 13.33px;">Web</a> <a href="/memoirs/tags/iOS/" style="font-size: 16.67px;">iOS</a> <a href="/memoirs/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 20px;">基础知识</a> <a href="/memoirs/tags/%E6%9D%82%E8%B0%88/" style="font-size: 16.67px;">杂谈</a> <a href="/memoirs/tags/%E9%80%86%E5%90%91/" style="font-size: 13.33px;">逆向</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/memoirs/archives/2016/11/">十一月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/memoirs/2021/09/15/%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD/">乡土中国</a>
          </li>
        
          <li>
            <a href="/memoirs/2021/08/20/%E5%A5%97%E8%B7%AF%E7%9C%9F%E5%A4%9A/">套路真多</a>
          </li>
        
          <li>
            <a href="/memoirs/2021/07/29/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/">乌合之众</a>
          </li>
        
          <li>
            <a href="/memoirs/2021/06/19/ReactStack-1/">React 技术栈（一）</a>
          </li>
        
          <li>
            <a href="/memoirs/2020/11/02/JavaScript-study-record-2/">JavaScript 温习记录（二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 ash<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/memoirs/" class="mobile-nav-link">Home</a>
  
    <a href="/memoirs/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/memoirs/fancybox/jquery.fancybox.css">

  
<script src="/memoirs/fancybox/jquery.fancybox.pack.js"></script>




<script src="/memoirs/js/script.js"></script>




  </div>
</body>
</html>